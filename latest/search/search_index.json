{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"COMPAS Slicer","text":"<p>COMPAS Slicer is a slicing package for FDM 3D Printing using COMPAS.</p> <p>The package builds upon COMPAS, an open-source Python-based framework for collaboration and research in architecture, engineering and digital fabrication.</p> <p>Note</p> <p>COMPAS Slicer is a collaborative work-in-progress project and might contain bugs. If you find bugs or would like to request additional functionality, please submit an issue using the Issue Tracker.</p>"},{"location":"#authors","title":"Authors","text":"<p>COMPAS Slicer was developed at ETH Zurich by:</p> <ul> <li> <p>Ioanna Mitropoulou - Digital Building Technologies</p> </li> <li> <p>Joris Burger - Gramazio Kohler Research</p> </li> <li> <p>Andrei Jipa - Gramazio Kohler Research</p> </li> <li> <p>Jelle Feringa - Gramazio Kohler Research</p> </li> </ul> <p>The package emerged from research on non-planar 3D printing and robotic fabrication at the Institute of Technology in Architecture.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Planar Slicing - Fast CGAL-based mesh slicing with configurable layer heights</li> <li>Curved Slicing - Non-planar toolpaths following scalar fields or interpolation</li> <li>Print Organization - Generate printpoints with fabrication parameters</li> <li>G-code Generation - Export toolpaths for desktop 3D printers</li> <li>Grasshopper Integration - Visualize results in Rhino/Grasshopper</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li> <p> Installation</p> <p>Get started with COMPAS Slicer in minutes</p> <p> Install</p> </li> <li> <p> Tutorials</p> <p>Learn the fundamentals with step-by-step guides</p> <p> Tutorials</p> </li> <li> <p> Examples</p> <p>Explore complete working examples</p> <p> Examples</p> </li> <li> <p> API Reference</p> <p>Detailed documentation of all modules</p> <p> API</p> </li> </ul>"},{"location":"citing/","title":"Citing","text":"<p>If you use COMPAS Slicer in your research or projects, please cite the relevant publications.</p>"},{"location":"citing/#software-citation","title":"Software Citation","text":"<pre><code>@software{compas_slicer,\n    title  = {{COMPAS Slicer}: Slicing package for FDM 3D Printing with COMPAS},\n    author = {Mitropoulou, Ioanna and Burger, Joris},\n    url    = {https://github.com/compas-dev/compas_slicer},\n    year   = {2020}\n}\n</code></pre>"},{"location":"citing/#related-publications","title":"Related Publications","text":""},{"location":"citing/#nonplanar-3d-printing-of-bifurcating-forms","title":"Nonplanar 3D Printing of Bifurcating Forms","text":"<p> Best Paper Award - 3D Printing and Additive Manufacturing Journal</p> <p>Mitropoulou, I., Bernhard, M., &amp; Dillenburger, B. (2022). Nonplanar 3D Printing of Bifurcating Forms. 3D Printing and Additive Manufacturing, 9(3), 189\u2013202.</p> <pre><code>@article{mitropoulou2022nonplanar,\n    title     = {Nonplanar 3D Printing of Bifurcating Forms},\n    author    = {Mitropoulou, Ioanna and Bernhard, Mathias and Dillenburger, Benjamin},\n    journal   = {3D Printing and Additive Manufacturing},\n    volume    = {9},\n    number    = {3},\n    pages     = {189--202},\n    year      = {2022},\n    publisher = {Mary Ann Liebert, Inc.},\n    doi       = {10.1089/3dp.2021.0023}\n}\n</code></pre> <p> PDF</p>"},{"location":"citing/#print-paths-key-framing","title":"Print Paths Key-framing","text":"<p>Mitropoulou, I., Bernhard, M., &amp; Dillenburger, B. (2020). Print Paths Key-framing: Design for non-planar layered robotic FDM printing. In Symposium on Computational Fabrication (SCF '20), November 5\u20136, 2020. ACM.</p> <pre><code>@inproceedings{mitropoulou2020keyframing,\n    title     = {Print Paths Key-framing: Design for non-planar layered robotic FDM printing},\n    author    = {Mitropoulou, Ioanna and Bernhard, Mathias and Dillenburger, Benjamin},\n    booktitle = {Symposium on Computational Fabrication (SCF '20)},\n    year      = {2020},\n    publisher = {Association for Computing Machinery},\n    address   = {New York, NY, USA},\n    doi       = {10.1145/3424630.3425408}\n}\n</code></pre> <p> PDF</p>"},{"location":"citing/#acknowledgments","title":"Acknowledgments","text":"<p>This work was developed at ETH Zurich in the chairs of:</p> <ul> <li>Digital Building Technologies (Prof. Benjamin Dillenburger)</li> <li>Gramazio Kohler Research (Prof. Fabio Gramazio, Prof. Matthias Kohler)</li> </ul> <p>The project builds on the COMPAS framework and uses CGAL for computational geometry operations.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions to COMPAS Slicer!</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li> <p>Fork and clone the repository:</p> <pre><code>git clone https://github.com/YOUR_USERNAME/compas_slicer.git\ncd compas_slicer\n</code></pre> </li> <li> <p>Install in development mode:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre> </li> <li> <p>Verify tests pass:</p> <pre><code>pytest\n</code></pre> </li> </ol>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We use Ruff for linting and formatting:</p> <pre><code># Check for issues\nruff check src/\n\n# Auto-fix issues\nruff check --fix src/\n\n# Format code\nruff format src/\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npytest\n\n# Run with coverage\npytest --cov=compas_slicer\n\n# Run specific test file\npytest tests/test_planar_slicing.py\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Create a feature branch from <code>master</code></li> <li>Make your changes</li> <li>Ensure tests pass and code is formatted</li> <li>Add yourself to the authors in <code>pyproject.toml</code> if not already listed</li> <li>Create a pull request with a clear description</li> </ol>"},{"location":"contributing/#adding-examples","title":"Adding Examples","text":"<p>When adding new functionality:</p> <ol> <li>Add an example in <code>examples/</code> demonstrating the feature</li> <li>Ensure the example runs without errors</li> <li>Add documentation if needed</li> </ol>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Build the docs locally:</p> <pre><code>pip install -e \".[docs]\"\nmkdocs serve\n</code></pre> <p>Then open http://localhost:8000 in your browser.</p>"},{"location":"contributing/#releasing","title":"Releasing","text":"<p>Maintainers can release new versions:</p> <pre><code># Bump version (patch/minor/major)\nbump2version patch\n\n# Push with tags\ngit push &amp;&amp; git push --tags\n</code></pre>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>Open an issue</li> <li>Contact the maintainers</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>COMPAS Slicer can be installed on Windows, macOS, and Linux.</p>"},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9 or higher</li> <li>COMPAS &gt;= 2.15</li> <li>compas_cgal &gt;= 0.9</li> </ul>"},{"location":"installation/#quick-install","title":"Quick Install","text":"pipconda <pre><code>pip install compas_slicer\n</code></pre> <pre><code>conda install -c conda-forge compas_slicer\n</code></pre>"},{"location":"installation/#development-install","title":"Development Install","text":"<p>To install from source for development:</p> <pre><code># Clone the repository\ngit clone https://github.com/compas-dev/compas_slicer.git\ncd compas_slicer\n\n# Create a virtual environment (recommended)\npython -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n\n# Install in editable mode with dev dependencies\npip install -e \".[dev]\"\n</code></pre>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<p>Test that the installation works:</p> <pre><code>python -c \"import compas_slicer; print(compas_slicer.__version__)\"\n</code></pre>"},{"location":"installation/#grasshopper-integration","title":"Grasshopper Integration","text":"<p>To use COMPAS Slicer in Rhino/Grasshopper:</p> <pre><code>python -m compas_rhino.install -v 8.0\n</code></pre> <p>Tip</p> <p>Replace <code>8.0</code> with your Rhino version (e.g., <code>7.0</code> for Rhino 7).</p>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#grasshopper-components-not-working","title":"Grasshopper components not working","text":"<p>If the Grasshopper components don't load after installation, manually add the path in Rhino:</p> <ol> <li>In Rhino, type <code>EditPythonScript</code></li> <li>Go to Tools &gt; Options &gt; Add to search path</li> <li>Add: <code>&lt;path&gt;/compas_slicer/src/grasshopper_visualization</code></li> </ol>"},{"location":"installation/#microsoft-visual-c-build-tools-windows","title":"Microsoft Visual C++ Build Tools (Windows)","text":"<p>If you see:</p> <pre><code>error: Microsoft Visual C++ 14.0 or greater is required\n</code></pre> <p>Install the Microsoft C++ Build Tools.</p>"},{"location":"installation/#cgal-issues","title":"CGAL Issues","text":"<p>COMPAS Slicer requires <code>compas_cgal</code>. If you have issues:</p> <pre><code>conda install -c conda-forge compas_cgal\n</code></pre>"},{"location":"installation/#bug-reports","title":"Bug Reports","text":"<p>When reporting a bug, please include:</p> <ul> <li>Operating system and version</li> <li>Python version</li> <li>COMPAS Slicer version (<code>python -c \"import compas_slicer; print(compas_slicer.__version__)\"</code>)</li> <li>Complete error traceback</li> <li>Steps to reproduce</li> </ul>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Get started with COMPAS Slicer in under 5 minutes.</p>"},{"location":"quickstart/#basic-workflow","title":"Basic Workflow","text":"<p>COMPAS Slicer follows a simple pipeline:</p> <pre><code>graph LR\n    A[Load Mesh] --&gt; B[Slice]\n    B --&gt; C[Post-process]\n    C --&gt; D[Print Organization]\n    D --&gt; E[Export]</code></pre>"},{"location":"quickstart/#minimal-example","title":"Minimal Example","text":"<pre><code>from pathlib import Path\nfrom compas.datastructures import Mesh\nfrom compas_slicer.slicers import PlanarSlicer\nfrom compas_slicer.print_organization import PlanarPrintOrganizer\n\n# Load a mesh\nmesh = Mesh.from_obj(\"model.obj\")\n\n# Slice with 2mm layer height\nslicer = PlanarSlicer(mesh, layer_height=2.0)\nslicer.slice_model()\n\n# Create printpoints\norganizer = PlanarPrintOrganizer(slicer)\norganizer.create_printpoints()\n\n# Export\norganizer.printout_info()\n</code></pre>"},{"location":"quickstart/#complete-example-with-g-code","title":"Complete Example with G-code","text":"<pre><code>from pathlib import Path\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Point\n\nfrom compas_slicer.slicers import PlanarSlicer\nfrom compas_slicer.pre_processing import move_mesh_to_point\nfrom compas_slicer.post_processing import generate_brim, simplify_paths_rdp\nfrom compas_slicer.print_organization import PlanarPrintOrganizer, set_extruder_toggle\nfrom compas_slicer.print_organization import create_gcode_text\nfrom compas_slicer.config import GcodeConfig\n\n# Load and position mesh\nmesh = Mesh.from_obj(\"model.obj\")\nmove_mesh_to_point(mesh, Point(100, 100, 0))\n\n# Slice\nslicer = PlanarSlicer(mesh, layer_height=0.2)\nslicer.slice_model()\n\n# Post-processing\ngenerate_brim(slicer, layer_width=0.4, number_of_brim_offsets=3)\nsimplify_paths_rdp(slicer, threshold=0.1)\n\n# Print organization\norganizer = PlanarPrintOrganizer(slicer)\norganizer.create_printpoints()\nset_extruder_toggle(organizer, slicer)\n\n# Generate G-code\ngcode = create_gcode_text(organizer, GcodeConfig())\nPath(\"output.gcode\").write_text(gcode)\n</code></pre>"},{"location":"quickstart/#key-concepts","title":"Key Concepts","text":""},{"location":"quickstart/#slicers","title":"Slicers","text":"Slicer Use Case <code>PlanarSlicer</code> Standard horizontal slicing <code>InterpolationSlicer</code> Curved/non-planar slicing <code>ScalarFieldSlicer</code> Slicing along scalar field contours"},{"location":"quickstart/#post-processing","title":"Post-processing","text":"<ul> <li><code>simplify_paths_rdp()</code> - Reduce point count using RDP algorithm</li> <li><code>generate_brim()</code> - Add adhesion brim</li> <li><code>generate_raft()</code> - Add raft layers</li> <li><code>seams_align()</code> - Align layer start points</li> </ul>"},{"location":"quickstart/#print-organization","title":"Print Organization","text":"<ul> <li><code>PlanarPrintOrganizer</code> - For planar slicing</li> <li><code>InterpolationPrintOrganizer</code> - For curved slicing</li> </ul>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li> Tutorials - Learn the fundamentals</li> <li> Examples - See complete workflows</li> <li> API Reference - Detailed documentation</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete documentation of all COMPAS Slicer modules.</p> Module Description Geometry Core geometric entities: Layer, Path, PrintPoint Slicers Mesh slicing algorithms Print Organization Fabrication parameter assignment Pre-processing Mesh preparation utilities Post-processing Path modification utilities Utilities Helper functions"},{"location":"api/geometry/","title":"Geometry","text":"<p>Core geometric entities for representing sliced models.</p>"},{"location":"api/geometry/#compas_slicer.geometry","title":"geometry","text":"<p>Core geometric entities: Layer, Path, and PrintPoint.</p>"},{"location":"api/geometry/#compas_slicer.geometry.Layer","title":"Layer  <code>dataclass</code>","text":"<pre><code>Layer(paths=list(), is_brim=False, number_of_brim_offsets=None, is_raft=False, min_max_z_height=(None, None))\n</code></pre> <p>               Bases: <code>Data</code></p> <p>A Layer stores a group of ordered paths generated when a geometry is sliced.</p> <p>Layers are typically organized horizontally, but can also be organized vertically (see VerticalLayer). A Layer consists of one or multiple Paths.</p> <p>Attributes:</p> Name Type Description <code>paths</code> <code>list[Path]</code> <p>List of paths in this layer.</p> <code>is_brim</code> <code>bool</code> <p>True if this layer is a brim layer.</p> <code>number_of_brim_offsets</code> <code>int | None</code> <p>The number of brim offsets this layer has (None if no brim).</p> <code>is_raft</code> <code>bool</code> <p>True if this layer is a raft layer.</p> <code>min_max_z_height</code> <code>tuple[float | None, float | None]</code> <p>Tuple containing the min and max z height of the layer.</p>"},{"location":"api/geometry/#compas_slicer.geometry.Layer.total_number_of_points","title":"total_number_of_points  <code>property</code>","text":"<pre><code>total_number_of_points\n</code></pre> <p>Returns the total number of points within the layer.</p>"},{"location":"api/geometry/#compas_slicer.geometry.Layer.calculate_z_bounds","title":"calculate_z_bounds","text":"<pre><code>calculate_z_bounds()\n</code></pre> <p>Fills in the attribute self.min_max_z_height.</p> Source code in <code>src/compas_slicer/geometry/layer.py</code> <pre><code>def calculate_z_bounds(self) -&gt; None:\n    \"\"\"Fills in the attribute self.min_max_z_height.\"\"\"\n    if not self.paths:\n        raise ValueError(\"Cannot calculate z_bounds because the list of paths is empty.\")\n\n    # Vectorized z extraction\n    all_z = []\n    for path in self.paths:\n        for pt in path.points:\n            all_z.append(pt[2])\n\n    self.min_max_z_height = (min(all_z), max(all_z))\n</code></pre>"},{"location":"api/geometry/#compas_slicer.geometry.Layer.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(data)\n</code></pre> <p>Construct a layer from its data representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The data dictionary.</p> required <p>Returns:</p> Type Description <code>Layer</code> <p>The constructed layer.</p> Source code in <code>src/compas_slicer/geometry/layer.py</code> <pre><code>@classmethod\ndef from_data(cls, data: dict[str, Any]) -&gt; Layer:\n    \"\"\"Construct a layer from its data representation.\n\n    Parameters\n    ----------\n    data : dict\n        The data dictionary.\n\n    Returns\n    -------\n    Layer\n        The constructed layer.\n\n    \"\"\"\n    return cls.__from_data__(data)\n</code></pre>"},{"location":"api/geometry/#compas_slicer.geometry.Layer.to_data","title":"to_data","text":"<pre><code>to_data()\n</code></pre> <p>Returns a dictionary of structured data representing the layer.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The layer's data.</p> Source code in <code>src/compas_slicer/geometry/layer.py</code> <pre><code>def to_data(self) -&gt; dict[str, Any]:\n    \"\"\"Returns a dictionary of structured data representing the layer.\n\n    Returns\n    -------\n    dict\n        The layer's data.\n\n    \"\"\"\n    return self.__data__\n</code></pre>"},{"location":"api/geometry/#compas_slicer.geometry.VerticalLayer","title":"VerticalLayer  <code>dataclass</code>","text":"<pre><code>VerticalLayer(paths=list(), is_brim=False, number_of_brim_offsets=None, is_raft=False, min_max_z_height=(None, None), id=0, head_centroid=None)\n</code></pre> <p>               Bases: <code>Layer</code></p> <p>Vertical ordering layer that stores print paths sorted in vertical groups.</p> <p>It is created with an empty list of paths that is filled in afterwards.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identifier of vertical layer.</p> <code>head_centroid</code> <code>NDArray | None</code> <p>Centroid of the last path's points.</p>"},{"location":"api/geometry/#compas_slicer.geometry.VerticalLayer.append_","title":"append_","text":"<pre><code>append_(path)\n</code></pre> <p>Add path to self.paths list.</p> Source code in <code>src/compas_slicer/geometry/layer.py</code> <pre><code>def append_(self, path: Path) -&gt; None:\n    \"\"\"Add path to self.paths list.\"\"\"\n    self.paths.append(path)\n    self.compute_head_centroid()\n    self.calculate_z_bounds()\n</code></pre>"},{"location":"api/geometry/#compas_slicer.geometry.VerticalLayer.compute_head_centroid","title":"compute_head_centroid","text":"<pre><code>compute_head_centroid()\n</code></pre> <p>Find the centroid of all the points of the last path.</p> Source code in <code>src/compas_slicer/geometry/layer.py</code> <pre><code>def compute_head_centroid(self) -&gt; None:\n    \"\"\"Find the centroid of all the points of the last path.\"\"\"\n    pts = np.array(self.paths[-1].points)\n    self.head_centroid = np.mean(pts, axis=0)\n</code></pre>"},{"location":"api/geometry/#compas_slicer.geometry.VerticalLayer.printout_details","title":"printout_details","text":"<pre><code>printout_details()\n</code></pre> <p>Prints the details of the class.</p> Source code in <code>src/compas_slicer/geometry/layer.py</code> <pre><code>def printout_details(self) -&gt; None:\n    \"\"\"Prints the details of the class.\"\"\"\n    logger.info(f\"VerticalLayer id: {self.id}\")\n    logger.info(f\"Total number of paths: {len(self.paths)}\")\n</code></pre>"},{"location":"api/geometry/#compas_slicer.geometry.VerticalLayer.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(data)\n</code></pre> <p>Construct a vertical layer from its data representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The data dictionary.</p> required <p>Returns:</p> Type Description <code>VerticalLayer</code> <p>The constructed vertical layer.</p> Source code in <code>src/compas_slicer/geometry/layer.py</code> <pre><code>@classmethod\ndef from_data(cls, data: dict[str, Any]) -&gt; VerticalLayer:\n    \"\"\"Construct a vertical layer from its data representation.\n\n    Parameters\n    ----------\n    data : dict\n        The data dictionary.\n\n    Returns\n    -------\n    VerticalLayer\n        The constructed vertical layer.\n\n    \"\"\"\n    return cls.__from_data__(data)\n</code></pre>"},{"location":"api/geometry/#compas_slicer.geometry.VerticalLayer.to_data","title":"to_data","text":"<pre><code>to_data()\n</code></pre> <p>Returns a dictionary of structured data representing the vertical layer.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The vertical layer's data.</p> Source code in <code>src/compas_slicer/geometry/layer.py</code> <pre><code>def to_data(self) -&gt; dict[str, Any]:\n    \"\"\"Returns a dictionary of structured data representing the vertical layer.\n\n    Returns\n    -------\n    dict\n        The vertical layer's data.\n\n    \"\"\"\n    return self.__data__\n</code></pre>"},{"location":"api/geometry/#compas_slicer.geometry.Path","title":"Path  <code>dataclass</code>","text":"<pre><code>Path(points=list(), is_closed=False)\n</code></pre> <p>               Bases: <code>Data</code></p> <p>A Path is a connected contour within a Layer.</p> <p>A Path consists of a list of compas.geometry.Points.</p> <p>Attributes:</p> Name Type Description <code>points</code> <code>list[Point]</code> <p>List of points defining the path.</p> <code>is_closed</code> <code>bool</code> <p>True if the Path is a closed curve, False if the Path is open. If the path is closed, the first and the last point are identical.</p>"},{"location":"api/geometry/#compas_slicer.geometry.Path.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(data)\n</code></pre> <p>Construct a path from its data representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The data dictionary.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The constructed path.</p> Source code in <code>src/compas_slicer/geometry/path.py</code> <pre><code>@classmethod\ndef from_data(cls, data: dict[str, Any]) -&gt; Path:\n    \"\"\"Construct a path from its data representation.\n\n    Parameters\n    ----------\n    data : dict\n        The data dictionary.\n\n    Returns\n    -------\n    Path\n        The constructed path.\n\n    \"\"\"\n    return cls.__from_data__(data)\n</code></pre>"},{"location":"api/geometry/#compas_slicer.geometry.Path.to_data","title":"to_data","text":"<pre><code>to_data()\n</code></pre> <p>Returns a dictionary of structured data representing the path.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The path's data.</p> Source code in <code>src/compas_slicer/geometry/path.py</code> <pre><code>def to_data(self) -&gt; dict[str, Any]:\n    \"\"\"Returns a dictionary of structured data representing the path.\n\n    Returns\n    -------\n    dict\n        The path's data.\n\n    \"\"\"\n    return self.__data__\n</code></pre>"},{"location":"api/geometry/#compas_slicer.geometry.PrintPoint","title":"PrintPoint  <code>dataclass</code>","text":"<pre><code>PrintPoint(pt, layer_height, mesh_normal, up_vector=(lambda: Vector(0, 0, 1))(), frame=None, extruder_toggle=None, velocity=None, wait_time=None, blend_radius=None, closest_support_pt=None, distance_to_support=None, is_feasible=True, attributes=dict())\n</code></pre> <p>               Bases: <code>Data</code></p> <p>A PrintPoint consists of a compas.geometry.Point and printing attributes.</p> <p>Attributes:</p> Name Type Description <code>pt</code> <code>Point</code> <p>A compas Point consisting of x, y, z coordinates.</p> <code>layer_height</code> <code>float</code> <p>The distance between the point on this layer and the previous layer.</p> <code>mesh_normal</code> <code>Vector</code> <p>Normal of the mesh at this PrintPoint.</p> <code>up_vector</code> <code>Vector</code> <p>Vector in up direction.</p> <code>frame</code> <code>Frame</code> <p>Frame with x-axis pointing up, y-axis pointing towards the mesh normal.</p> <code>extruder_toggle</code> <code>bool | None</code> <p>True if extruder should be on, False if off.</p> <code>velocity</code> <code>float | None</code> <p>Velocity for printing (print speed), in mm/s.</p> <code>wait_time</code> <code>float | None</code> <p>Time in seconds to wait at this PrintPoint.</p> <code>blend_radius</code> <code>float | None</code> <p>Blend radius in mm.</p> <code>closest_support_pt</code> <code>Point | None</code> <p>Closest support point.</p> <code>distance_to_support</code> <code>float | None</code> <p>Distance to support.</p> <code>is_feasible</code> <code>bool</code> <p>Whether this print point is feasible.</p> <code>attributes</code> <code>dict[str, Any]</code> <p>Additional attributes transferred from the mesh.</p>"},{"location":"api/geometry/#compas_slicer.geometry.PrintPoint.get_frame","title":"get_frame","text":"<pre><code>get_frame()\n</code></pre> <p>Returns a Frame with x-axis pointing up, y-axis towards mesh normal.</p> Source code in <code>src/compas_slicer/geometry/print_point.py</code> <pre><code>def get_frame(self) -&gt; Frame:\n    \"\"\"Returns a Frame with x-axis pointing up, y-axis towards mesh normal.\"\"\"\n    return self._compute_frame()\n</code></pre>"},{"location":"api/geometry/#compas_slicer.geometry.PrintPoint.to_data","title":"to_data","text":"<pre><code>to_data()\n</code></pre> <p>Returns a dictionary of structured data representing the PrintPoint.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The PrintPoint's data.</p> Source code in <code>src/compas_slicer/geometry/print_point.py</code> <pre><code>def to_data(self) -&gt; dict[str, Any]:\n    \"\"\"Returns a dictionary of structured data representing the PrintPoint.\n\n    Returns\n    -------\n    dict\n        The PrintPoint's data.\n\n    \"\"\"\n    return self.__data__\n</code></pre>"},{"location":"api/geometry/#compas_slicer.geometry.PrintPoint.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(data)\n</code></pre> <p>Construct a PrintPoint from its data representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The data dictionary.</p> required <p>Returns:</p> Type Description <code>PrintPoint</code> <p>The constructed PrintPoint.</p> Source code in <code>src/compas_slicer/geometry/print_point.py</code> <pre><code>@classmethod\ndef from_data(cls, data: dict[str, Any]) -&gt; PrintPoint:\n    \"\"\"Construct a PrintPoint from its data representation.\n\n    Parameters\n    ----------\n    data : dict\n        The data dictionary.\n\n    Returns\n    -------\n    PrintPoint\n        The constructed PrintPoint.\n\n    \"\"\"\n    # Handle legacy format with \"point\" key instead of \"pt\"\n    if \"point\" in data and \"pt\" not in data:\n        data[\"pt\"] = data.pop(\"point\")\n    return cls.__from_data__(data)\n</code></pre>"},{"location":"api/post_processing/","title":"Post-processing","text":"<p>Path modification utilities after slicing.</p>"},{"location":"api/post_processing/#compas_slicer.post_processing","title":"post_processing","text":"<p>Post-processing utilities for modifying sliced paths.</p>"},{"location":"api/post_processing/#compas_slicer.post_processing.offset_polygon","title":"offset_polygon","text":"<pre><code>offset_polygon(points, offset, z)\n</code></pre> <p>Offset a polygon, using CGAL if available.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[Point]</code> <p>Points of the polygon.</p> required <code>offset</code> <code>float</code> <p>Offset distance (positive = outward).</p> required <code>z</code> <code>float</code> <p>Z coordinate for result points.</p> required <p>Returns:</p> Type Description <code>list[Point]</code> <p>Offset polygon points.</p> Source code in <code>src/compas_slicer/post_processing/generate_brim.py</code> <pre><code>def offset_polygon(points: list[Point], offset: float, z: float) -&gt; list[Point]:\n    \"\"\"Offset a polygon, using CGAL if available.\n\n    Parameters\n    ----------\n    points : list[Point]\n        Points of the polygon.\n    offset : float\n        Offset distance (positive = outward).\n    z : float\n        Z coordinate for result points.\n\n    Returns\n    -------\n    list[Point]\n        Offset polygon points.\n    \"\"\"\n    if _USE_CGAL:\n        return _offset_polygon_cgal(points, offset, z)\n    else:\n        return _offset_polygon_pyclipper(points, offset, z)\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.offset_polygon_with_holes","title":"offset_polygon_with_holes","text":"<pre><code>offset_polygon_with_holes(outer, holes, offset, z)\n</code></pre> <p>Offset a polygon with holes using CGAL straight skeleton.</p> <p>Parameters:</p> Name Type Description Default <code>outer</code> <code>list[Point]</code> <p>Points of the outer boundary (CCW orientation).</p> required <code>holes</code> <code>list[list[Point]]</code> <p>List of hole polygons (CW orientation).</p> required <code>offset</code> <code>float</code> <p>Offset distance (positive = outward, negative = inward).</p> required <code>z</code> <code>float</code> <p>Z coordinate for result points.</p> required <p>Returns:</p> Type Description <code>list[tuple[list[Point], list[list[Point]]]]</code> <p>List of (outer_boundary, holes) tuples for resulting polygons.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If CGAL is not available.</p> Source code in <code>src/compas_slicer/post_processing/generate_brim.py</code> <pre><code>def offset_polygon_with_holes(\n    outer: list[Point],\n    holes: list[list[Point]],\n    offset: float,\n    z: float\n) -&gt; list[tuple[list[Point], list[list[Point]]]]:\n    \"\"\"Offset a polygon with holes using CGAL straight skeleton.\n\n    Parameters\n    ----------\n    outer : list[Point]\n        Points of the outer boundary (CCW orientation).\n    holes : list[list[Point]]\n        List of hole polygons (CW orientation).\n    offset : float\n        Offset distance (positive = outward, negative = inward).\n    z : float\n        Z coordinate for result points.\n\n    Returns\n    -------\n    list[tuple[list[Point], list[list[Point]]]]\n        List of (outer_boundary, holes) tuples for resulting polygons.\n\n    Raises\n    ------\n    ImportError\n        If CGAL is not available.\n    \"\"\"\n    if not _USE_CGAL:\n        raise ImportError(\"offset_polygon_with_holes requires compas_cgal\")\n\n    from compas.geometry import Polygon\n\n    # CGAL expects Polygon objects with z=0, normal up for outer, down for holes\n    outer_poly = Polygon([[p[0], p[1], 0] for p in outer])\n    hole_polys = [Polygon([[p[0], p[1], 0] for p in hole]) for hole in holes]\n\n    # CGAL: negative = outward, positive = inward (opposite of our convention)\n    result = _cgal_offset_with_holes(outer_poly, hole_polys, -offset)\n\n    # Convert back to Points with z coordinate\n    output = []\n    for poly, poly_holes in result:\n        outer_pts = [Point(p[0], p[1], z) for p in poly.points]\n        if outer_pts and outer_pts[0] != outer_pts[-1]:\n            outer_pts.append(outer_pts[0])\n\n        hole_pts_list = []\n        for hole in poly_holes:\n            hole_pts = [Point(p[0], p[1], z) for p in hole.points]\n            if hole_pts and hole_pts[0] != hole_pts[-1]:\n                hole_pts.append(hole_pts[0])\n            hole_pts_list.append(hole_pts)\n\n        output.append((outer_pts, hole_pts_list))\n\n    return output\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.generate_medial_axis_infill","title":"generate_medial_axis_infill","text":"<pre><code>generate_medial_axis_infill(slicer, min_length=5.0, include_bisectors=True)\n</code></pre> <p>Generate medial axis infill paths for all layers.</p> <p>Uses CGAL's straight skeleton to compute the medial axis of each closed contour, then converts skeleton edges to infill paths.</p> <p>Parameters:</p> Name Type Description Default <code>slicer</code> <code>BaseSlicer</code> <p>Slicer with layers containing boundary paths.</p> required <code>min_length</code> <code>float</code> <p>Minimum skeleton edge length to include. Shorter edges are skipped.</p> <code>5.0</code> <code>include_bisectors</code> <code>bool</code> <p>If True, include bisector edges (skeleton to boundary connections). If False, only include inner_bisector edges (skeleton internal edges).</p> <code>True</code> Source code in <code>src/compas_slicer/post_processing/infill/medial_axis_infill.py</code> <pre><code>def generate_medial_axis_infill(\n    slicer: BaseSlicer,\n    min_length: float = 5.0,\n    include_bisectors: bool = True,\n) -&gt; None:\n    \"\"\"Generate medial axis infill paths for all layers.\n\n    Uses CGAL's straight skeleton to compute the medial axis of each\n    closed contour, then converts skeleton edges to infill paths.\n\n    Parameters\n    ----------\n    slicer : BaseSlicer\n        Slicer with layers containing boundary paths.\n    min_length : float\n        Minimum skeleton edge length to include. Shorter edges are skipped.\n    include_bisectors : bool\n        If True, include bisector edges (skeleton to boundary connections).\n        If False, only include inner_bisector edges (skeleton internal edges).\n\n    \"\"\"\n    from compas_cgal.straight_skeleton_2 import interior_straight_skeleton\n\n    logger.info(\"Generating medial axis infill\")\n\n    for layer in slicer.layers:\n        infill_paths: list[Path] = []\n\n        for path in layer.paths:\n            if not path.is_closed:\n                continue\n\n            # Convert path to 2D polygon\n            polygon_2d = _path_to_polygon_2d(path)\n            if len(polygon_2d) &lt; 3:\n                continue\n\n            z_height = path.points[0][2]\n\n            # Compute straight skeleton\n            try:\n                graph = interior_straight_skeleton(polygon_2d)\n            except Exception as e:\n                logger.warning(f\"Skeleton failed for path: {e}\")\n                continue\n\n            # Extract skeleton edges as paths\n            skeleton_paths = _skeleton_to_paths(\n                graph, z_height, min_length, include_bisectors\n            )\n            infill_paths.extend(skeleton_paths)\n\n        # Add infill paths to layer\n        layer.paths.extend(infill_paths)\n        logger.info(f\"Added {len(infill_paths)} infill paths to layer\")\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.generate_brim","title":"generate_brim","text":""},{"location":"api/post_processing/#compas_slicer.post_processing.generate_brim.offset_polygon","title":"offset_polygon","text":"<pre><code>offset_polygon(points, offset, z)\n</code></pre> <p>Offset a polygon, using CGAL if available.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[Point]</code> <p>Points of the polygon.</p> required <code>offset</code> <code>float</code> <p>Offset distance (positive = outward).</p> required <code>z</code> <code>float</code> <p>Z coordinate for result points.</p> required <p>Returns:</p> Type Description <code>list[Point]</code> <p>Offset polygon points.</p> Source code in <code>src/compas_slicer/post_processing/generate_brim.py</code> <pre><code>def offset_polygon(points: list[Point], offset: float, z: float) -&gt; list[Point]:\n    \"\"\"Offset a polygon, using CGAL if available.\n\n    Parameters\n    ----------\n    points : list[Point]\n        Points of the polygon.\n    offset : float\n        Offset distance (positive = outward).\n    z : float\n        Z coordinate for result points.\n\n    Returns\n    -------\n    list[Point]\n        Offset polygon points.\n    \"\"\"\n    if _USE_CGAL:\n        return _offset_polygon_cgal(points, offset, z)\n    else:\n        return _offset_polygon_pyclipper(points, offset, z)\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.generate_brim.offset_polygon_with_holes","title":"offset_polygon_with_holes","text":"<pre><code>offset_polygon_with_holes(outer, holes, offset, z)\n</code></pre> <p>Offset a polygon with holes using CGAL straight skeleton.</p> <p>Parameters:</p> Name Type Description Default <code>outer</code> <code>list[Point]</code> <p>Points of the outer boundary (CCW orientation).</p> required <code>holes</code> <code>list[list[Point]]</code> <p>List of hole polygons (CW orientation).</p> required <code>offset</code> <code>float</code> <p>Offset distance (positive = outward, negative = inward).</p> required <code>z</code> <code>float</code> <p>Z coordinate for result points.</p> required <p>Returns:</p> Type Description <code>list[tuple[list[Point], list[list[Point]]]]</code> <p>List of (outer_boundary, holes) tuples for resulting polygons.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If CGAL is not available.</p> Source code in <code>src/compas_slicer/post_processing/generate_brim.py</code> <pre><code>def offset_polygon_with_holes(\n    outer: list[Point],\n    holes: list[list[Point]],\n    offset: float,\n    z: float\n) -&gt; list[tuple[list[Point], list[list[Point]]]]:\n    \"\"\"Offset a polygon with holes using CGAL straight skeleton.\n\n    Parameters\n    ----------\n    outer : list[Point]\n        Points of the outer boundary (CCW orientation).\n    holes : list[list[Point]]\n        List of hole polygons (CW orientation).\n    offset : float\n        Offset distance (positive = outward, negative = inward).\n    z : float\n        Z coordinate for result points.\n\n    Returns\n    -------\n    list[tuple[list[Point], list[list[Point]]]]\n        List of (outer_boundary, holes) tuples for resulting polygons.\n\n    Raises\n    ------\n    ImportError\n        If CGAL is not available.\n    \"\"\"\n    if not _USE_CGAL:\n        raise ImportError(\"offset_polygon_with_holes requires compas_cgal\")\n\n    from compas.geometry import Polygon\n\n    # CGAL expects Polygon objects with z=0, normal up for outer, down for holes\n    outer_poly = Polygon([[p[0], p[1], 0] for p in outer])\n    hole_polys = [Polygon([[p[0], p[1], 0] for p in hole]) for hole in holes]\n\n    # CGAL: negative = outward, positive = inward (opposite of our convention)\n    result = _cgal_offset_with_holes(outer_poly, hole_polys, -offset)\n\n    # Convert back to Points with z coordinate\n    output = []\n    for poly, poly_holes in result:\n        outer_pts = [Point(p[0], p[1], z) for p in poly.points]\n        if outer_pts and outer_pts[0] != outer_pts[-1]:\n            outer_pts.append(outer_pts[0])\n\n        hole_pts_list = []\n        for hole in poly_holes:\n            hole_pts = [Point(p[0], p[1], z) for p in hole.points]\n            if hole_pts and hole_pts[0] != hole_pts[-1]:\n                hole_pts.append(hole_pts[0])\n            hole_pts_list.append(hole_pts)\n\n        output.append((outer_pts, hole_pts_list))\n\n    return output\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.generate_brim.generate_brim","title":"generate_brim","text":"<pre><code>generate_brim(slicer, layer_width, number_of_brim_offsets)\n</code></pre> <p>Creates a brim around the bottom contours of the print.</p> <p>Parameters:</p> Name Type Description Default <code>slicer</code> <code>BaseSlicer</code> <p>An instance of the compas_slicer.slicers.PlanarSlicer class</p> required <code>layer_width</code> <code>float</code> <p>A number representing the distance between brim contours (typically the width of a layer)</p> required <code>number_of_brim_offsets</code> <code>int</code> <p>Number of brim paths to add.</p> required Source code in <code>src/compas_slicer/post_processing/generate_brim.py</code> <pre><code>def generate_brim(slicer: BaseSlicer, layer_width: float, number_of_brim_offsets: int) -&gt; None:\n    \"\"\"Creates a brim around the bottom contours of the print.\n\n    Parameters\n    ----------\n    slicer: :class:`compas_slicer.slicers.PlanarSlicer`\n        An instance of the compas_slicer.slicers.PlanarSlicer class\n    layer_width: float\n        A number representing the distance between brim contours\n        (typically the width of a layer)\n    number_of_brim_offsets: int\n        Number of brim paths to add.\n    \"\"\"\n    backend = \"CGAL\" if _USE_CGAL else \"pyclipper\"\n    logger.info(f\"Generating brim with layer width: {layer_width:.2f} mm, {number_of_brim_offsets} offsets ({backend})\")\n\n    if slicer.layers[0].is_raft:\n        raise NameError(\"Raft found: cannot apply brim when raft is used, choose one\")\n\n    # (1) --- find if slicer has vertical or horizontal layers, and select which paths are to be offset.\n    if isinstance(slicer.layers[0], compas_slicer.geometry.VerticalLayer):  # Vertical layers\n        # then find all paths that lie on the print platform and make them brim.\n        paths_to_offset, layers_i = slicer.find_vertical_layers_with_first_path_on_base()\n        for i, first_path in zip(layers_i, paths_to_offset):\n            slicer.layers[i].paths.remove(first_path)  # remove first path that will become part of the brim layer\n        has_vertical_layers = True\n\n    else:  # Horizontal layers\n        # then replace the first layer with a brim layer.\n        paths_to_offset = slicer.layers[0].paths\n        has_vertical_layers = False\n\n    if len(paths_to_offset) == 0:\n        raise ValueError('Brim generator did not find any path on the base. Please check the paths of your slicer.')\n\n    # (2) --- create new empty brim_layer\n    brim_layer = Layer(paths=[])\n    brim_layer.is_brim = True\n    brim_layer.number_of_brim_offsets = number_of_brim_offsets\n\n    # (3) --- create offsets and add them to the paths of the brim_layer\n    for path in paths_to_offset:\n        z = path.points[0][2]\n\n        for i in range(number_of_brim_offsets):\n            offset_distance = i * layer_width\n            offset_pts = offset_polygon(path.points, offset_distance, z)\n\n            if offset_pts:\n                new_path = Path(points=offset_pts, is_closed=True)\n                brim_layer.paths.append(new_path)\n\n    brim_layer.paths.reverse()  # go from outside towards the object\n    brim_layer.calculate_z_bounds()\n\n    # (4) --- Add the brim layer to the slicer\n    if not has_vertical_layers:\n        slicer.layers[0] = brim_layer  # replace first layer\n    else:\n        slicer.layers.insert(0, brim_layer)  # insert brim layer as the first layer of the slicer\n\n    seams_align(slicer, align_with=\"next_path\")\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.generate_raft","title":"generate_raft","text":""},{"location":"api/post_processing/#compas_slicer.post_processing.generate_raft.generate_raft","title":"generate_raft","text":"<pre><code>generate_raft(slicer, raft_offset=10, distance_between_paths=10, direction='xy_diagonal', raft_layers=1, raft_layer_height=None)\n</code></pre> <p>Creates a raft.</p> <p>Parameters:</p> Name Type Description Default <code>slicer</code> <p>An instance of one of the compas_slicer.slicers.BaseSlicer classes.</p> required <code>raft_offset</code> <p>Distance (in mm) that the raft should be offsetted from the first layer. Defaults to 10mm</p> <code>10</code> <code>distance_between_paths</code> <p>Distance (in mm) between the printed lines of the raft. Defaults to 10mm</p> <code>10</code> <code>direction</code> <p>x_axis: Create a raft aligned with the x_axis y_axis: Create a raft aligned with the y_axis xy_diagonal: Create a raft int the diagonal direction in the xy_plane</p> <code>'xy_diagonal'</code> <code>raft_layers</code> <p>Number of raft layers to add. Defaults to 1</p> <code>1</code> <code>raft_layer_height</code> <p>Layer height of the raft layers. Defaults to same value as used in the slicer.</p> <code>None</code> Source code in <code>src/compas_slicer/post_processing/generate_raft.py</code> <pre><code>def generate_raft(slicer,\n                  raft_offset=10,\n                  distance_between_paths=10,\n                  direction=\"xy_diagonal\",\n                  raft_layers=1,\n                  raft_layer_height=None):\n    \"\"\"Creates a raft.\n\n    Parameters\n    ----------\n    slicer: :class:`compas_slicer.slicers.BaseSlicer`\n        An instance of one of the compas_slicer.slicers.BaseSlicer classes.\n    raft_offset: float\n        Distance (in mm) that the raft should be offsetted from the first layer. Defaults to 10mm\n    distance_between_paths: float\n        Distance (in mm) between the printed lines of the raft. Defaults to 10mm\n    direction: str\n        x_axis: Create a raft aligned with the x_axis\n        y_axis: Create a raft aligned with the y_axis\n        xy_diagonal: Create a raft int the diagonal direction in the xy_plane\n    raft_layers: int\n        Number of raft layers to add. Defaults to 1\n    raft_layer_height: float\n        Layer height of the raft layers. Defaults to same value as used in the slicer.\n    \"\"\"\n\n    # check if a raft_layer_height is specified, if not, use the slicer.layer_height value\n    if not raft_layer_height:\n        raft_layer_height = slicer.layer_height\n\n    logger.info(\"Generating raft\")\n\n    # find if slicer has vertical or horizontal layers, and select which paths are to be offset.\n    if isinstance(slicer.layers[0], compas_slicer.geometry.VerticalLayer):  # Vertical layers\n        # then find all paths that lie on the print platform and make them brim.\n        paths_to_offset, _ = slicer.find_vertical_layers_with_first_path_on_base()\n\n    else:  # Horizontal layers\n        # then replace the first layer with a raft layer.\n        paths_to_offset = slicer.layers[0].paths\n\n    # get flat lists of points in bottom layer\n    all_pts = []\n    for path in paths_to_offset:\n        for pt in path.points:\n            all_pts.append(pt)\n\n    # get xy bounding box of bottom layer and create offset\n    bb_xy = bounding_box_xy(all_pts)\n    bb_xy_offset = offset_polygon(bb_xy, -raft_offset)\n    # bring points in the xy_offset to the correct height\n    for pt in bb_xy_offset:\n        pt[2] = slicer.layers[0].paths[0].points[0][2]\n\n    # calculate x range, y range, and number of steps\n    x_range = abs(bb_xy_offset[0][0] - bb_xy_offset[1][0])\n    y_range = abs(bb_xy_offset[0][1] - bb_xy_offset[3][1])\n\n    # get maximum values of the bounding box\n    bb_max_x_right = bb_xy_offset[1][0]\n    bb_max_y_top = bb_xy_offset[3][1]\n\n    # get point in bottom left corner as raft start point\n    raft_start_pt = Point(bb_xy_offset[0][0], bb_xy_offset[0][1], bb_xy_offset[0][2])\n\n    # create starting line for diagonal direction\n    if direction == \"xy_diagonal\":\n        c = math.sqrt(2*(distance_between_paths**2))\n\n        pt1 = Point(raft_start_pt[0] + c, raft_start_pt[1], raft_start_pt[2])\n        pt2 = Point(pt1[0] - y_range, pt1[1] + y_range, pt1[2])\n        line = Line(pt1, pt2)\n\n    # move all points in the slicer up so that raft layers can be inserted\n    for i, layer in enumerate(slicer.layers):\n        for j, path in enumerate(layer.paths):\n            for k, pt in enumerate(path.points):\n                slicer.layers[i].paths[j].points[k] = Point(pt[0], pt[1], pt[2] + (raft_layers)*raft_layer_height)\n\n    for i in range(raft_layers):\n\n        iter = 0\n        raft_points = []\n\n        # create raft points depending on the chosen direction\n        while iter &lt; 9999:  # to avoid infinite while loop in case something is not correct\n            # ===============\n            # VERTICAL RAFT\n            # ===============\n            if direction == \"y_axis\":\n                raft_pt1 = Point(raft_start_pt[0] + iter*distance_between_paths, raft_start_pt[1], raft_start_pt[2] + i*raft_layer_height)\n                raft_pt2 = Point(raft_start_pt[0] + iter*distance_between_paths, raft_start_pt[1] + y_range, raft_start_pt[2] + i*raft_layer_height)\n\n                if raft_pt2[0] &gt; bb_max_x_right or raft_pt1[0] &gt; bb_max_x_right:\n                    break\n\n            # ===============\n            # HORIZONTAL RAFT\n            # ===============\n            elif direction == \"x_axis\":\n                raft_pt1 = Point(raft_start_pt[0], raft_start_pt[1] + iter*distance_between_paths, raft_start_pt[2] + i*raft_layer_height)\n                raft_pt2 = Point(raft_start_pt[0] + x_range, raft_start_pt[1] + iter*distance_between_paths, raft_start_pt[2] + i*raft_layer_height)\n\n                if raft_pt2[1] &gt; bb_max_y_top or raft_pt1[1] &gt; bb_max_y_top:\n                    break\n\n            # ===============\n            # DIAGONAL RAFT\n            # ===============\n            elif direction == \"xy_diagonal\":\n                # create offset of the initial diagonal line\n                offset_l = offset_line(line, iter*distance_between_paths, Vector(0, 0, -1))\n\n                # get intersections for the initial diagonal line with the left and bottom of the bb\n                int_left = intersection_line_line(offset_l, [bb_xy_offset[0], bb_xy_offset[3]])\n                int_bottom = intersection_line_line(offset_l, [bb_xy_offset[0], bb_xy_offset[1]])\n\n                # get the points at the intersections\n                raft_pt1 = Point(int_left[0][0], int_left[0][1], int_left[0][2] + i*raft_layer_height)\n                raft_pt2 = Point(int_bottom[0][0], int_bottom[0][1], int_bottom[0][2] + i*raft_layer_height)\n\n                # if the intersection goes beyond the height of the left side of the bounding box:\n                if int_left[0][1] &gt; bb_max_y_top:\n                    # create intersection with the top side\n                    int_top = intersection_line_line(offset_l, [bb_xy_offset[3], bb_xy_offset[2]])\n                    raft_pt1 = Point(int_top[0][0], int_top[0][1], int_top[0][2] + i*raft_layer_height)\n\n                    # if intersection goes beyond the length of the top side, break\n                    if raft_pt1[0] &gt; bb_max_x_right:\n                        break\n\n                # if the intersection goes beyond the length of the bottom side of the bounding box:\n                if int_bottom[0][0] &gt; bb_max_x_right:\n                    # create intersection with the right side\n                    int_right = intersection_line_line(offset_l, [bb_xy_offset[1], bb_xy_offset[2]])\n                    raft_pt2 = Point(int_right[0][0], int_right[0][1], int_right[0][2] + i*raft_layer_height)\n\n                    # if intersection goes beyond the height of the right side, break\n                    if raft_pt2[1] &gt; bb_xy_offset[2][1]:\n                        break\n\n            # append to list alternating\n            if iter % 2 == 0:\n                raft_points.extend((raft_pt1, raft_pt2))\n            else:\n                raft_points.extend((raft_pt2, raft_pt1))\n\n            iter += 1\n\n        # create raft layer\n        raft_layer = Layer([Path(raft_points, is_closed=False)])\n        raft_layer.is_raft = True\n        # insert raft layer in the correct position into the slicer\n        slicer.layers.insert(i, raft_layer)\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.infill","title":"infill","text":"<p>Infill generation for sliced paths.</p>"},{"location":"api/post_processing/#compas_slicer.post_processing.infill.generate_medial_axis_infill","title":"generate_medial_axis_infill","text":"<pre><code>generate_medial_axis_infill(slicer, min_length=5.0, include_bisectors=True)\n</code></pre> <p>Generate medial axis infill paths for all layers.</p> <p>Uses CGAL's straight skeleton to compute the medial axis of each closed contour, then converts skeleton edges to infill paths.</p> <p>Parameters:</p> Name Type Description Default <code>slicer</code> <code>BaseSlicer</code> <p>Slicer with layers containing boundary paths.</p> required <code>min_length</code> <code>float</code> <p>Minimum skeleton edge length to include. Shorter edges are skipped.</p> <code>5.0</code> <code>include_bisectors</code> <code>bool</code> <p>If True, include bisector edges (skeleton to boundary connections). If False, only include inner_bisector edges (skeleton internal edges).</p> <code>True</code> Source code in <code>src/compas_slicer/post_processing/infill/medial_axis_infill.py</code> <pre><code>def generate_medial_axis_infill(\n    slicer: BaseSlicer,\n    min_length: float = 5.0,\n    include_bisectors: bool = True,\n) -&gt; None:\n    \"\"\"Generate medial axis infill paths for all layers.\n\n    Uses CGAL's straight skeleton to compute the medial axis of each\n    closed contour, then converts skeleton edges to infill paths.\n\n    Parameters\n    ----------\n    slicer : BaseSlicer\n        Slicer with layers containing boundary paths.\n    min_length : float\n        Minimum skeleton edge length to include. Shorter edges are skipped.\n    include_bisectors : bool\n        If True, include bisector edges (skeleton to boundary connections).\n        If False, only include inner_bisector edges (skeleton internal edges).\n\n    \"\"\"\n    from compas_cgal.straight_skeleton_2 import interior_straight_skeleton\n\n    logger.info(\"Generating medial axis infill\")\n\n    for layer in slicer.layers:\n        infill_paths: list[Path] = []\n\n        for path in layer.paths:\n            if not path.is_closed:\n                continue\n\n            # Convert path to 2D polygon\n            polygon_2d = _path_to_polygon_2d(path)\n            if len(polygon_2d) &lt; 3:\n                continue\n\n            z_height = path.points[0][2]\n\n            # Compute straight skeleton\n            try:\n                graph = interior_straight_skeleton(polygon_2d)\n            except Exception as e:\n                logger.warning(f\"Skeleton failed for path: {e}\")\n                continue\n\n            # Extract skeleton edges as paths\n            skeleton_paths = _skeleton_to_paths(\n                graph, z_height, min_length, include_bisectors\n            )\n            infill_paths.extend(skeleton_paths)\n\n        # Add infill paths to layer\n        layer.paths.extend(infill_paths)\n        logger.info(f\"Added {len(infill_paths)} infill paths to layer\")\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.infill.medial_axis_infill","title":"medial_axis_infill","text":"<p>Medial axis based infill generation using CGAL straight skeleton.</p>"},{"location":"api/post_processing/#compas_slicer.post_processing.infill.medial_axis_infill.generate_medial_axis_infill","title":"generate_medial_axis_infill","text":"<pre><code>generate_medial_axis_infill(slicer, min_length=5.0, include_bisectors=True)\n</code></pre> <p>Generate medial axis infill paths for all layers.</p> <p>Uses CGAL's straight skeleton to compute the medial axis of each closed contour, then converts skeleton edges to infill paths.</p> <p>Parameters:</p> Name Type Description Default <code>slicer</code> <code>BaseSlicer</code> <p>Slicer with layers containing boundary paths.</p> required <code>min_length</code> <code>float</code> <p>Minimum skeleton edge length to include. Shorter edges are skipped.</p> <code>5.0</code> <code>include_bisectors</code> <code>bool</code> <p>If True, include bisector edges (skeleton to boundary connections). If False, only include inner_bisector edges (skeleton internal edges).</p> <code>True</code> Source code in <code>src/compas_slicer/post_processing/infill/medial_axis_infill.py</code> <pre><code>def generate_medial_axis_infill(\n    slicer: BaseSlicer,\n    min_length: float = 5.0,\n    include_bisectors: bool = True,\n) -&gt; None:\n    \"\"\"Generate medial axis infill paths for all layers.\n\n    Uses CGAL's straight skeleton to compute the medial axis of each\n    closed contour, then converts skeleton edges to infill paths.\n\n    Parameters\n    ----------\n    slicer : BaseSlicer\n        Slicer with layers containing boundary paths.\n    min_length : float\n        Minimum skeleton edge length to include. Shorter edges are skipped.\n    include_bisectors : bool\n        If True, include bisector edges (skeleton to boundary connections).\n        If False, only include inner_bisector edges (skeleton internal edges).\n\n    \"\"\"\n    from compas_cgal.straight_skeleton_2 import interior_straight_skeleton\n\n    logger.info(\"Generating medial axis infill\")\n\n    for layer in slicer.layers:\n        infill_paths: list[Path] = []\n\n        for path in layer.paths:\n            if not path.is_closed:\n                continue\n\n            # Convert path to 2D polygon\n            polygon_2d = _path_to_polygon_2d(path)\n            if len(polygon_2d) &lt; 3:\n                continue\n\n            z_height = path.points[0][2]\n\n            # Compute straight skeleton\n            try:\n                graph = interior_straight_skeleton(polygon_2d)\n            except Exception as e:\n                logger.warning(f\"Skeleton failed for path: {e}\")\n                continue\n\n            # Extract skeleton edges as paths\n            skeleton_paths = _skeleton_to_paths(\n                graph, z_height, min_length, include_bisectors\n            )\n            infill_paths.extend(skeleton_paths)\n\n        # Add infill paths to layer\n        layer.paths.extend(infill_paths)\n        logger.info(f\"Added {len(infill_paths)} infill paths to layer\")\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.reorder_vertical_layers","title":"reorder_vertical_layers","text":""},{"location":"api/post_processing/#compas_slicer.post_processing.reorder_vertical_layers.reorder_vertical_layers","title":"reorder_vertical_layers","text":"<pre><code>reorder_vertical_layers(slicer, align_with)\n</code></pre> <p>Re-orders the vertical layers in a specific way</p> <p>Parameters:</p> Name Type Description Default <code>slicer</code> <code>BaseSlicer</code> <p>An instance of one of the compas_slicer.slicers classes.</p> required <code>align_with</code> <code>AlignWith | Point</code> <p>x_axis       = reorders the vertical layers starting from the positive x-axis y_axis       = reorders the vertical layers starting from the positive y-axis Point(x,y,z) = reorders the vertical layers starting from a given Point</p> required Source code in <code>src/compas_slicer/post_processing/reorder_vertical_layers.py</code> <pre><code>def reorder_vertical_layers(slicer: BaseSlicer, align_with: AlignWith | Point) -&gt; None:\n    \"\"\"Re-orders the vertical layers in a specific way\n\n    Parameters\n    ----------\n    slicer: :class:`compas_slicer.slicers.BaseSlicer`\n        An instance of one of the compas_slicer.slicers classes.\n    align_with: str or :class:`compas.geometry.Point`\n        x_axis       = reorders the vertical layers starting from the positive x-axis\n        y_axis       = reorders the vertical layers starting from the positive y-axis\n        Point(x,y,z) = reorders the vertical layers starting from a given Point\n    \"\"\"\n\n    if align_with == \"x_axis\":\n        align_pt = Point(2 ** 32, 0, 0)\n    elif align_with == \"y_axis\":\n        align_pt = Point(0, 2 ** 32, 0)\n    elif isinstance(align_with, Point):\n        align_pt = align_with\n    else:\n        raise NameError(\"Unknown align_with : \" + str(align_with))\n\n    logger.info(f\"Re-ordering vertical layers to start with the vertical layer closest to: {align_with}\")\n\n    for layer in slicer.layers:\n        if layer.min_max_z_height[0] is None or layer.min_max_z_height[1] is None:\n            raise ValueError(\n                \"To use reorder_vertical_layers you need first to calculate the layers' z_bounds. \"\n                \"Use the function Layer.calculate_z_bounds()\"\n            )\n\n    # group vertical layers based on the min_max_z_height\n    grouped_iter = itertools.groupby(slicer.layers, lambda x: x.min_max_z_height)\n    grouped_layer_list = [list(group) for _key, group in grouped_iter]\n\n    reordered_layers = []\n\n    for grouped_layers in grouped_layer_list:\n        distances = []\n        for vert_layer in grouped_layers:\n            # recreate head_centroid_pt as compas.Point\n            head_centroid_pt = Point(vert_layer.head_centroid[0], vert_layer.head_centroid[1], vert_layer.head_centroid[2])\n            # measure distance\n            distances.append(distance_point_point(head_centroid_pt, align_pt))\n\n        # sort lists based on closest distance to align pt\n        grouped_new = [x for _, x in sorted(zip(distances, grouped_layers))]\n        reordered_layers.append(grouped_new)\n\n    # flatten list\n    slicer.layers = [item for sublist in reordered_layers for item in sublist]\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.seams_align","title":"seams_align","text":""},{"location":"api/post_processing/#compas_slicer.post_processing.seams_align.seams_align","title":"seams_align","text":"<pre><code>seams_align(slicer, align_with='next_path')\n</code></pre> <p>Aligns the seams (start- and endpoint) of a print.</p> <p>Parameters:</p> Name Type Description Default <code>slicer</code> <code>BaseSlicer</code> <p>An instance of one of the compas_slicer.slicers classes.</p> required <code>align_with</code> <code>AlignWith | Point</code> <p>Direction to orient the seams in. next_path    = orients the seam to the next path origin       = orients the seam to the origin (0,0,0) x_axis       = orients the seam to the x_axis y_axis       = orients the seam to the y_axis Point(x,y,z) = orients the seam according to the given point</p> <code>'next_path'</code> Source code in <code>src/compas_slicer/post_processing/seams_align.py</code> <pre><code>def seams_align(slicer: BaseSlicer, align_with: AlignWith | Point = \"next_path\") -&gt; None:\n    \"\"\"Aligns the seams (start- and endpoint) of a print.\n\n    Parameters\n    ----------\n    slicer: :class:`compas_slicer.slicers.BaseSlicer`\n        An instance of one of the compas_slicer.slicers classes.\n    align_with: str or :class:`compas.geometry.Point`\n        Direction to orient the seams in.\n        next_path    = orients the seam to the next path\n        origin       = orients the seam to the origin (0,0,0)\n        x_axis       = orients the seam to the x_axis\n        y_axis       = orients the seam to the y_axis\n        Point(x,y,z) = orients the seam according to the given point\n\n    \"\"\"\n    #  TODO: Implement random seams\n    logger.info(f\"Aligning seams to: {align_with}\")\n\n    for i, layer in enumerate(slicer.layers):\n        for j, path in enumerate(layer.paths):\n\n            if align_with == \"next_path\":\n                pt_to_align_with = None  # make sure aligning point is cleared\n\n                #  determines the correct point to align the current path with\n                if len(layer.paths) == 1 and i == 0:\n                    #  if ONE PATH and FIRST LAYER\n                    #  &gt;&gt;&gt; align with second layer\n                    pt_to_align_with = slicer.layers[i + 1].paths[0].points[0]\n                if len(layer.paths) == 1 and i != 0:\n                    last_path_index = len(slicer.layers[i - 1].paths) - 1\n                    #  if ONE PATH and NOT FIRST LAYER\n                    #  &gt;&gt;&gt; align with previous layer\n                    pt_to_align_with = slicer.layers[i - 1].paths[last_path_index].points[-1]\n                if len(layer.paths) != 1 and i == 0 and j == 0:\n                    #  if MULTIPLE PATHS and FIRST LAYER and FIRST PATH\n                    #  &gt;&gt;&gt; align with second path of first layer\n                    pt_to_align_with = slicer.layers[i].paths[i + 1].points[-1]\n                if len(layer.paths) != 1 and j != 0:\n                    #  if MULTIPLE PATHS and NOT FIRST PATH\n                    #  &gt;&gt;&gt; align with previous path\n                    pt_to_align_with = slicer.layers[i].paths[j - 1].points[-1]\n                if len(layer.paths) != 1 and i != 0 and j == 0:\n                    #  if MULTIPLE PATHS and NOT FIRST LAYER and FIRST PATH\n                    #  &gt;&gt;&gt; align with first path of previous layer\n                    last_path_index = len(slicer.layers[i - 1].paths) - 1\n                    pt_to_align_with = slicer.layers[i - 1].paths[last_path_index].points[-1]\n\n            elif align_with == \"origin\":\n                pt_to_align_with = Point(0, 0, 0)\n            elif align_with == \"x_axis\":\n                pt_to_align_with = Point(2 ** 32, 0, 0)\n            elif align_with == \"y_axis\":\n                pt_to_align_with = Point(0, 2 ** 32, 0)\n            elif isinstance(align_with, Point):\n                pt_to_align_with = align_with\n            else:\n                raise NameError(\"Unknown align_with : \" + str(align_with))\n\n            # CLOSED PATHS\n            if path.is_closed:\n                #  get the points of the current layer and path\n                path_to_change = layer.paths[j].points\n\n                # check if start- and end-points are the same point\n                if path_to_change[0] == path_to_change[-1]:\n                    first_last_point_the_same = True\n                    # if they are, remove the last point\n                    path_to_change.pop(-1)\n                else:\n                    first_last_point_the_same = False\n\n                #  computes distance between pt_to_align_with and the current path points (vectorized)\n                ref = np.asarray(pt_to_align_with, dtype=np.float64)\n                pts = np.asarray(path_to_change, dtype=np.float64)\n                distances = np.linalg.norm(pts - ref, axis=1)\n                #  gets the index of the closest point\n                new_start_index = int(np.argmin(distances))\n                #  shifts the list by the distance determined\n                shift_list = path_to_change[new_start_index:] + path_to_change[:new_start_index]\n\n                if first_last_point_the_same:\n                    shift_list = shift_list + [shift_list[0]]\n\n                layer.paths[j].points = shift_list\n\n            else:\n                # OPEN PATHS\n                path_to_change = layer.paths[j].points\n\n                # get the distance between the align point and the start/end point (vectorized)\n                ref = np.asarray(pt_to_align_with, dtype=np.float64)\n                d_start = np.linalg.norm(np.asarray(path_to_change[0]) - ref)\n                d_end = np.linalg.norm(np.asarray(path_to_change[-1]) - ref)\n\n                # if closer to end point &gt; reverse list\n                if d_start &gt; d_end:\n                    layer.paths[j].points.reverse()\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.seams_smooth","title":"seams_smooth","text":""},{"location":"api/post_processing/#compas_slicer.post_processing.seams_smooth.seams_smooth","title":"seams_smooth","text":"<pre><code>seams_smooth(slicer, smooth_distance)\n</code></pre> <p>Smooths the seams (transition between layers) by removing points within a certain distance.</p> <p>Parameters:</p> Name Type Description Default <code>slicer</code> <code>BaseSlicer</code> <p>An instance of one of the compas_slicer.slicers classes.</p> required <code>smooth_distance</code> <code>float</code> <p>Distance (in mm) to perform smoothing</p> required Source code in <code>src/compas_slicer/post_processing/seams_smooth.py</code> <pre><code>def seams_smooth(slicer: BaseSlicer, smooth_distance: float) -&gt; None:\n    \"\"\"Smooths the seams (transition between layers)\n    by removing points within a certain distance.\n\n    Parameters\n    ----------\n    slicer: :class:`compas_slicer.slicers.BaseSlicer`\n        An instance of one of the compas_slicer.slicers classes.\n    smooth_distance: float\n        Distance (in mm) to perform smoothing\n    \"\"\"\n\n    logger.info(f\"Smoothing seams with a distance of {smooth_distance} mm\")\n\n    for i, layer in enumerate(slicer.layers):\n        if len(layer.paths) == 1 or isinstance(layer, compas_slicer.geometry.VerticalLayer):\n            for _j, path in enumerate(layer.paths):\n                if path.is_closed:  # only for closed paths\n                    pt0 = path.points[0]\n                    # only points in the first half of a path should be evaluated\n                    half_of_path = path.points[:int(len(path.points)/2)]\n                    for point in half_of_path:\n                        if distance_point_point(pt0, point) &lt; smooth_distance:\n                            # remove points if within smooth_distance\n                            path.points.pop(0)\n                        else:\n                            # create new point at a distance of the\n                            # 'smooth_distance' from the first point,\n                            # so that all seams are of equal length\n                            vect = Vector.from_start_end(pt0, point)\n                            vect.unitize()\n                            new_pt = pt0 + (vect * smooth_distance)\n                            path.points.insert(0, new_pt)\n                            path.points.pop(-1)  # remove last point\n                            break\n        else:\n            logger.warning(\n                \"Smooth seams only works for layers consisting out of a single path, or for vertical layers.\"\n                f\"\\nPaths were not changed, seam smoothing skipped for layer {i}\"\n            )\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.simplify_paths_rdp","title":"simplify_paths_rdp","text":""},{"location":"api/post_processing/#compas_slicer.post_processing.simplify_paths_rdp.simplify_paths_rdp","title":"simplify_paths_rdp","text":"<pre><code>simplify_paths_rdp(slicer, threshold)\n</code></pre> <p>Simplify paths using the Ramer-Douglas-Peucker algorithm.</p> <p>Uses CGAL native implementation if available (10-20x faster), otherwise falls back to Python rdp library.</p> <p>Parameters:</p> Name Type Description Default <code>slicer</code> <code>BaseSlicer</code> <p>An instance of one of the compas_slicer.slicers classes.</p> required <code>threshold</code> <code>float</code> <p>Controls the degree of polyline simplification. Low threshold removes few points, high threshold removes many points.</p> required References <p>https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm</p> Source code in <code>src/compas_slicer/post_processing/simplify_paths_rdp.py</code> <pre><code>def simplify_paths_rdp(slicer: BaseSlicer, threshold: float) -&gt; None:\n    \"\"\"Simplify paths using the Ramer-Douglas-Peucker algorithm.\n\n    Uses CGAL native implementation if available (10-20x faster),\n    otherwise falls back to Python rdp library.\n\n    Parameters\n    ----------\n    slicer: :class:`compas_slicer.slicers.BaseSlicer`\n        An instance of one of the compas_slicer.slicers classes.\n    threshold: float\n        Controls the degree of polyline simplification.\n        Low threshold removes few points, high threshold removes many points.\n\n    References\n    ----------\n    https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n    \"\"\"\n    if _USE_CGAL:\n        _simplify_paths_cgal(slicer, threshold)\n    else:\n        _simplify_paths_python(slicer, threshold)\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.sort_into_vertical_layers","title":"sort_into_vertical_layers","text":""},{"location":"api/post_processing/#compas_slicer.post_processing.sort_into_vertical_layers.sort_into_vertical_layers","title":"sort_into_vertical_layers","text":"<pre><code>sort_into_vertical_layers(slicer, dist_threshold=25.0, max_paths_per_layer=None)\n</code></pre> <p>Sorts the paths from horizontal layers into Vertical Layers.</p> <p>Vertical Layers are layers at different heights that are grouped together by proximity of their center points. Can be useful for reducing travel time in a robotic printing process.</p> <p>Parameters:</p> Name Type Description Default <code>slicer</code> <code>BaseSlicer</code> <p>An instance of one of the compas_slicer.slicers classes.</p> required <code>dist_threshold</code> <code>float</code> <p>The maximum get_distance that the centroids of two successive paths can have to belong in the same VerticalLayer Recommended value, slightly bigger than the layer height</p> <code>25.0</code> <code>max_paths_per_layer</code> <code>int | None</code> <p>Maximum number of layers that a vertical layer can consist of. If None, then the vertical layer has an unlimited number of layers.</p> <code>None</code> Source code in <code>src/compas_slicer/post_processing/sort_into_vertical_layers.py</code> <pre><code>def sort_into_vertical_layers(\n    slicer: BaseSlicer, dist_threshold: float = 25.0, max_paths_per_layer: int | None = None\n) -&gt; None:\n    \"\"\"Sorts the paths from horizontal layers into Vertical Layers.\n\n    Vertical Layers are layers at different heights that are grouped together by proximity\n    of their center points. Can be useful for reducing travel time in a robotic printing\n    process.\n\n    Parameters\n    ----------\n    slicer: :class:`compas_slicer.slicers.BaseSlicer`\n        An instance of one of the compas_slicer.slicers classes.\n    dist_threshold: float\n        The maximum get_distance that the centroids of two successive paths can have to belong in the same VerticalLayer\n        Recommended value, slightly bigger than the layer height\n    max_paths_per_layer: int\n        Maximum number of layers that a vertical layer can consist of.\n        If None, then the vertical layer has an unlimited number of layers.\n    \"\"\"\n    logger.info(\"Sorting into Vertical Layers\")\n\n    vertical_layers_manager = VerticalLayersManager(dist_threshold, max_paths_per_layer)\n\n    for layer in slicer.layers:\n        for path in layer.paths:\n            vertical_layers_manager.add(path)\n\n    slicer.layers = vertical_layers_manager.layers\n    logger.info(f\"Number of vertical_layers: {len(slicer.layers)}\")\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.sort_paths_minimum_travel_time","title":"sort_paths_minimum_travel_time","text":""},{"location":"api/post_processing/#compas_slicer.post_processing.sort_paths_minimum_travel_time.sort_paths_minimum_travel_time","title":"sort_paths_minimum_travel_time","text":"<pre><code>sort_paths_minimum_travel_time(slicer)\n</code></pre> <p>Sorts the paths within a horizontal layer to reduce total travel time.</p> <p>Parameters:</p> Name Type Description Default <code>slicer</code> <code>BaseSlicer</code> <p>An instance of one of the compas_slicer.slicers classes.</p> required Source code in <code>src/compas_slicer/post_processing/sort_paths_minimum_travel_time.py</code> <pre><code>def sort_paths_minimum_travel_time(slicer: BaseSlicer) -&gt; None:\n    \"\"\"Sorts the paths within a horizontal layer to reduce total travel time.\n\n    Parameters\n    ----------\n    slicer: :class:`compas_slicer.slicers.BaseSlicer`\n        An instance of one of the compas_slicer.slicers classes.\n    \"\"\"\n    logger.info(\"Sorting contours to minimize travel time\")\n\n    ref_point = Point(2 ** 32, 0, 0)  # set the reference point to the X-axis\n\n    for i, layer in enumerate(slicer.layers):\n        sorted_paths = []\n        while len(layer.paths) &gt; 0:\n            index = closest_path(ref_point, layer.paths)  # find the closest path to the reference point\n            sorted_paths.append(layer.paths[index])  # add the closest path to the sorted list\n            ref_point = layer.paths[index].points[-1]\n            layer.paths.pop(index)\n\n        slicer.layers[i].paths = sorted_paths\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.sort_paths_minimum_travel_time.adjust_seam_to_closest_pos","title":"adjust_seam_to_closest_pos","text":"<pre><code>adjust_seam_to_closest_pos(ref_point, path)\n</code></pre> <p>Aligns the seam (start- and endpoint) of a contour so that it is closest to a given point. for open paths, check if the end point closest to the reference point is the start point</p> <p>Parameters:</p> Name Type Description Default <code>ref_point</code> <code>Point</code> <p>The reference point</p> required <code>path</code> <code>Path</code> <p>The contour to be adjusted.</p> required Source code in <code>src/compas_slicer/post_processing/sort_paths_minimum_travel_time.py</code> <pre><code>def adjust_seam_to_closest_pos(ref_point: Point, path: SlicerPath) -&gt; None:\n    \"\"\"Aligns the seam (start- and endpoint) of a contour so that it is closest to a given point.\n    for open paths, check if the end point closest to the reference point is the start point\n\n    Parameters\n    ----------\n    ref_point: :class:`compas.geometry.Point`\n        The reference point\n    path: :class:`compas_slicer.geometry.Path`\n        The contour to be adjusted.\n    \"\"\"\n\n    # TODO: flip orientation to reduce angular velocity\n\n    if path.is_closed:  # if path is closed\n        # remove first point\n        path.points.pop(-1)\n        #  calculate distances from ref_point to vertices of path (vectorized)\n        ref = np.asarray(ref_point, dtype=np.float64)\n        pts = np.asarray(path.points, dtype=np.float64)\n        distances = np.linalg.norm(pts - ref, axis=1)\n        closest_point = int(np.argmin(distances))\n        #  adjust seam\n        adjusted_seam = path.points[closest_point:] + path.points[:closest_point] + [path.points[closest_point]]\n        path.points = adjusted_seam\n    else:  # if path is open\n        #  if end point is closer than start point &gt;&gt; flip (vectorized)\n        ref = np.asarray(ref_point, dtype=np.float64)\n        d_start = np.linalg.norm(np.asarray(path.points[0]) - ref)\n        d_end = np.linalg.norm(np.asarray(path.points[-1]) - ref)\n        if d_start &gt; d_end:\n            path.points.reverse()\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.sort_paths_minimum_travel_time.closest_path","title":"closest_path","text":"<pre><code>closest_path(ref_point, somepaths)\n</code></pre> <p>Finds the closest path to a reference point in a list of paths.</p> <p>Parameters:</p> Name Type Description Default <code>ref_point</code> <code>Point</code> required <code>somepaths</code> <code>list[Path]</code> required Source code in <code>src/compas_slicer/post_processing/sort_paths_minimum_travel_time.py</code> <pre><code>def closest_path(ref_point: Point, somepaths: list[SlicerPath]) -&gt; int:\n    \"\"\"Finds the closest path to a reference point in a list of paths.\n\n    Parameters\n    ----------\n    ref_point: the reference point\n    somepaths: list of paths to look into for finding the closest\n    \"\"\"\n    ref = np.asarray(ref_point, dtype=np.float64)\n\n    # First adjust all seams\n    for path in somepaths:\n        adjust_seam_to_closest_pos(ref_point, path)\n\n    # Then find closest path (vectorized)\n    start_pts = np.array([path.points[0] for path in somepaths], dtype=np.float64)\n    distances = np.linalg.norm(start_pts - ref, axis=1)\n    return int(np.argmin(distances))\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.spiralize_contours","title":"spiralize_contours","text":""},{"location":"api/post_processing/#compas_slicer.post_processing.spiralize_contours.spiralize_contours","title":"spiralize_contours","text":"<pre><code>spiralize_contours(slicer)\n</code></pre> <p>Spiralizes contours. Only works for Planar Slicer. Can only be used for geometries consisting out of a single closed contour (i.e. vases).</p> <p>Parameters:</p> Name Type Description Default <code>slicer</code> <code>PlanarSlicer</code> <p>An instance of the compas_slicer.slicers.PlanarSlicer class.</p> required Source code in <code>src/compas_slicer/post_processing/spiralize_contours.py</code> <pre><code>def spiralize_contours(slicer: PlanarSlicer) -&gt; None:\n    \"\"\"Spiralizes contours. Only works for Planar Slicer.\n    Can only be used for geometries consisting out of a single closed contour (i.e. vases).\n\n    Parameters\n    ----------\n    slicer: :class: 'compas_slicer.slicers.PlanarSlicer'\n        An instance of the compas_slicer.slicers.PlanarSlicer class.\n    \"\"\"\n    logger.info('Spiralizing contours')\n\n    if not isinstance(slicer, compas_slicer.slicers.PlanarSlicer):\n        logger.warning(\"spiralize_contours() contours only works for PlanarSlicer. Skipping function.\")\n        return\n\n    if slicer.layer_height is None:\n        raise ValueError(\"layer_height must be set before spiralizing contours\")\n\n    for j, layer in enumerate(slicer.layers):\n        if len(layer.paths) == 1:\n            for path in layer.paths:\n                d = slicer.layer_height / (len(path.points) - 1)\n                for i, _point in enumerate(path.points):\n                    # add the distance to move to the z value and create new points\n                    path.points[i][2] += d * i\n\n                # project all points of path back on the mesh surface\n                _, projected_pts = pull_pts_to_mesh_faces(slicer.mesh, path.points)\n                path.points = [Point(*p) for p in projected_pts]\n\n                # remove the last item to create a smooth transition to the next layer\n                path.points.pop(len(path.points) - 1)\n\n        else:\n            logger.warning(\n                \"Spiralize contours only works for layers consisting out of a single path, contours were \"\n                f\"not changed, spiralize contour skipped for layer {j}\"\n            )\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.unify_paths_orientation","title":"unify_paths_orientation","text":""},{"location":"api/post_processing/#compas_slicer.post_processing.unify_paths_orientation.unify_paths_orientation","title":"unify_paths_orientation","text":"<pre><code>unify_paths_orientation(slicer)\n</code></pre> <p>Unifies the orientation of paths that are closed.</p> <p>Parameters:</p> Name Type Description Default <code>slicer</code> <code>BaseSlicer</code> <p>An instance of one of the compas_slicer.slicers classes.</p> required Source code in <code>src/compas_slicer/post_processing/unify_paths_orientation.py</code> <pre><code>def unify_paths_orientation(slicer: BaseSlicer) -&gt; None:\n    \"\"\"\n    Unifies the orientation of paths that are closed.\n\n    Parameters\n    ----------\n    slicer: :class:`compas_slicer.slicers.BaseSlicer`\n        An instance of one of the compas_slicer.slicers classes.\n    \"\"\"\n\n    for i, layer in enumerate(slicer.layers):\n        for j, path in enumerate(layer.paths):\n            reference_points = None  # find reference points for each path, if possible\n            if j &gt; 0:\n                reference_points = layer.paths[j-1].points\n            elif i &gt; 0 and j == 0:\n                reference_points = slicer.layers[i - 1].paths[0].points\n\n            if reference_points:  # then reorient current pts based on reference\n                path.points = match_paths_orientations(path.points, reference_points, path.is_closed)\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.unify_paths_orientation.match_paths_orientations","title":"match_paths_orientations","text":"<pre><code>match_paths_orientations(pts, reference_points, is_closed)\n</code></pre> <p>Check if new curve has same direction as prev curve, otherwise reverse.</p> <p>Parameters:</p> Name Type Description Default <code>pts</code> <code>list[Point]</code> required <code>reference_points</code> <code>list[Point]</code> required <code>is_closed</code> <code>bool, Determines if the path is closed or open</code> required Source code in <code>src/compas_slicer/post_processing/unify_paths_orientation.py</code> <pre><code>def match_paths_orientations(\n    pts: list[Point], reference_points: list[Point], is_closed: bool\n) -&gt; list[Point]:\n    \"\"\"Check if new curve has same direction as prev curve, otherwise reverse.\n\n    Parameters\n    ----------\n    pts: list, :class: 'compas.geometry.Point'. The list of points whose direction we are fixing.\n    reference_points: list, :class: 'compas.geometry.Point'. [p1, p2] Two reference points.\n    is_closed : bool, Determines if the path is closed or open\n    \"\"\"\n\n    if len(pts) &gt; 2 and len(reference_points) &gt; 2:\n        v1 = normalize_vector(subtract_vectors(pts[0], pts[2]))\n        v2 = normalize_vector(subtract_vectors(reference_points[0], reference_points[2]))\n    else:\n        v1 = normalize_vector(subtract_vectors(pts[0], pts[1]))\n        v2 = normalize_vector(subtract_vectors(reference_points[0], reference_points[1]))\n\n    if dot_vectors(v1, v2) &lt; 0:\n        if is_closed:\n            items = deque(reversed(pts))\n            items.rotate(1)  # bring last point again in the front\n            pts = list(items)\n        else:\n            pts.reverse()\n    return pts\n</code></pre>"},{"location":"api/post_processing/#compas_slicer.post_processing.zig_zag_open_paths","title":"zig_zag_open_paths","text":""},{"location":"api/post_processing/#compas_slicer.post_processing.zig_zag_open_paths.zig_zag_open_paths","title":"zig_zag_open_paths","text":"<pre><code>zig_zag_open_paths(slicer)\n</code></pre> <p>Reverses half of the open paths of the slicer, so that they can be printed in a zig zag motion.</p> Source code in <code>src/compas_slicer/post_processing/zig_zag_open_paths.py</code> <pre><code>def zig_zag_open_paths(slicer: BaseSlicer) -&gt; None:\n    \"\"\" Reverses half of the open paths of the slicer, so that they can be printed in a zig zag motion. \"\"\"\n    reverse = False\n    for layer in slicer.layers:\n        for _i, path in enumerate(layer.paths):\n            if not path.is_closed:\n                if not reverse:\n                    reverse = True\n                else:\n                    path.points.reverse()\n                    reverse = False\n\n                path.is_closed = True  # label as closed so that it is printed without interruption\n</code></pre>"},{"location":"api/pre_processing/","title":"Pre-processing","text":"<p>Mesh preparation utilities before slicing.</p>"},{"location":"api/pre_processing/#compas_slicer.pre_processing","title":"pre_processing","text":"<p>Pre-processing utilities for mesh preparation before slicing.</p>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.GradientEvaluation","title":"GradientEvaluation","text":"<pre><code>GradientEvaluation(mesh, DATA_PATH)\n</code></pre> <p>Evaluation of the gradient of the scalar function of the mesh. The scalar function should be stored as a vertex attribute on every vertex, with key='scalar_field'</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>:class: 'compas.datastructures.Mesh'</code> <code>DATA_PATH</code> <code>str, path to the data folder</code> Source code in <code>src/compas_slicer/pre_processing/gradient_evaluation.py</code> <pre><code>def __init__(self, mesh: Mesh, DATA_PATH: str | FilePath) -&gt; None:\n    for v_key, data in mesh.vertices(data=True):\n        if 'scalar_field' not in data:\n            raise ValueError(f\"Vertex {v_key} does not have the attribute 'scalar_field'\")\n\n    logger.info('Gradient evaluation')\n    self.mesh = mesh\n    self.DATA_PATH = DATA_PATH\n    self.OUTPUT_PATH = utils.get_output_directory(DATA_PATH)\n\n    self.minima: list[int] = []\n    self.maxima: list[int] = []\n    self.saddles: list[int] = []\n\n    self.face_gradient: NDArray[np.floating] | list = []  # np.array (#F x 3) one gradient vector per face.\n    self.vertex_gradient: NDArray[np.floating] | list = []  # np.array (#V x 3) one gradient vector per vertex.\n    self.face_gradient_norm: list[float] = []  # list (#F x 1)\n    self.vertex_gradient_norm: list[float] = []  # list (#V x 1)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.GradientEvaluation.compute_gradient","title":"compute_gradient","text":"<pre><code>compute_gradient()\n</code></pre> <p>Computes the gradient on the faces and the vertices.</p> Source code in <code>src/compas_slicer/pre_processing/gradient_evaluation.py</code> <pre><code>def compute_gradient(self) -&gt; None:\n    \"\"\" Computes the gradient on the faces and the vertices. \"\"\"\n    u_v = [self.mesh.vertex[vkey]['scalar_field'] for vkey in self.mesh.vertices()]\n    self.face_gradient = get_face_gradient_from_scalar_field(self.mesh, u_v)\n    self.vertex_gradient = get_vertex_gradient_from_face_gradient(self.mesh, self.face_gradient)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.GradientEvaluation.compute_gradient_norm","title":"compute_gradient_norm","text":"<pre><code>compute_gradient_norm()\n</code></pre> <p>Computes the norm of the gradient.</p> Source code in <code>src/compas_slicer/pre_processing/gradient_evaluation.py</code> <pre><code>def compute_gradient_norm(self) -&gt; None:\n    \"\"\" Computes the norm of the gradient. \"\"\"\n    logger.info('Computing norm of gradient')\n    f_g = np.array([self.face_gradient[i] for i, fkey in enumerate(self.mesh.faces())])\n    v_g = np.array([self.vertex_gradient[i] for i, vkey in enumerate(self.mesh.vertices())])\n    self.face_gradient_norm = list(np.linalg.norm(f_g, axis=1))\n    self.vertex_gradient_norm = list(np.linalg.norm(v_g, axis=1))\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.GradientEvaluation.find_critical_points","title":"find_critical_points","text":"<pre><code>find_critical_points()\n</code></pre> <p>Finds minima, maxima and saddle points of the scalar function on the mesh.</p> Source code in <code>src/compas_slicer/pre_processing/gradient_evaluation.py</code> <pre><code>def find_critical_points(self) -&gt; None:\n    \"\"\" Finds minima, maxima and saddle points of the scalar function on the mesh. \"\"\"\n    for vkey, data in self.mesh.vertices(data=True):\n        current_v = data['scalar_field']\n        neighbors = self.mesh.vertex_neighbors(vkey, ordered=True)\n        values = []\n        if len(neighbors) &gt; 0:\n            neighbors.append(neighbors[0])\n            for n in neighbors:\n                v = self.mesh.vertex_attributes(n)['scalar_field']\n                if abs(v - current_v) &gt; 0.0:\n                    values.append(current_v - v)\n            sgc = count_sign_changes(values)\n\n            if sgc == 0:  # extreme point\n                if current_v &gt; self.mesh.vertex_attributes(neighbors[0])['scalar_field']:\n                    self.maxima.append(vkey)\n                else:\n                    self.minima.append(vkey)\n            if sgc == 2:  # regular point\n                pass\n            if sgc &gt; 2 and sgc % 2 == 0:\n                self.saddles.append(vkey)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.InterpolationSlicingPreprocessor","title":"InterpolationSlicingPreprocessor","text":"<pre><code>InterpolationSlicingPreprocessor(mesh, config=None, DATA_PATH='.')\n</code></pre> <p>Handles pre-processing for interpolation slicing.</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>Mesh</code> <p>Input mesh.</p> <code>config</code> <code>InterpolationConfig</code> <p>Interpolation configuration.</p> <code>DATA_PATH</code> <code>str | Path</code> <p>Path to the data folder.</p> Source code in <code>src/compas_slicer/pre_processing/interpolation_slicing_preprocessor.py</code> <pre><code>def __init__(\n    self, mesh: Mesh, config: InterpolationConfig | None = None, DATA_PATH: str | Path = \".\"\n) -&gt; None:\n    self.mesh = mesh\n    self.config = config if config else InterpolationConfig()\n    self.DATA_PATH = DATA_PATH\n\n    self.OUTPUT_PATH = utils.get_output_directory(DATA_PATH)\n    self.target_LOW: CompoundTarget | None = None\n    self.target_HIGH: CompoundTarget | None = None\n\n    self.split_meshes: list[Mesh] = []\n    # The meshes that result from the region splitting process.\n\n    utils.utils.check_triangular_mesh(mesh)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.InterpolationSlicingPreprocessor.create_compound_targets","title":"create_compound_targets","text":"<pre><code>create_compound_targets()\n</code></pre> <p>Create target_LOW and target_HIGH and compute geodesic distances.</p> Source code in <code>src/compas_slicer/pre_processing/interpolation_slicing_preprocessor.py</code> <pre><code>def create_compound_targets(self) -&gt; None:\n    \"\"\"Create target_LOW and target_HIGH and compute geodesic distances.\"\"\"\n\n    # --- low target\n    geodesics_method = self.config.target_low_geodesics_method.value\n    method = 'min'  # no other union methods currently supported for lower target\n    params: list[float] = []\n    self.target_LOW = CompoundTarget(self.mesh, 'boundary', 1, self.DATA_PATH,\n                                     union_method=method,\n                                     union_params=params,\n                                     geodesics_method=geodesics_method)\n\n    # --- high target\n    geodesics_method = self.config.target_high_geodesics_method.value\n    method = self.config.target_high_union_method.value\n    params = self.config.target_high_union_params\n    logger.info(f\"Creating target with union type: {method} and params: {params}\")\n    self.target_HIGH = CompoundTarget(self.mesh, 'boundary', 2, self.DATA_PATH,\n                                      union_method=method,\n                                      union_params=params,\n                                      geodesics_method=geodesics_method)\n\n    # --- uneven boundaries of high target\n    self.target_HIGH.offset = self.config.uneven_upper_targets_offset\n    self.target_HIGH.compute_uneven_boundaries_weight_max(self.target_LOW)\n\n    #  --- save intermediary get_distance outputs\n    self.target_LOW.save_distances(\"distances_LOW.json\")\n    self.target_HIGH.save_distances(\"distances_HIGH.json\")\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.InterpolationSlicingPreprocessor.targets_laplacian_smoothing","title":"targets_laplacian_smoothing","text":"<pre><code>targets_laplacian_smoothing(iterations, strength)\n</code></pre> <p>Smooth geodesic distances of targets. Saves again the distances to json.</p> <p>Parameters:</p> Name Type Description Default <code>iterations</code> <code>int</code> required <code>strength</code> <code>float</code> required Source code in <code>src/compas_slicer/pre_processing/interpolation_slicing_preprocessor.py</code> <pre><code>def targets_laplacian_smoothing(self, iterations: int, strength: float) -&gt; None:\n    \"\"\"\n    Smooth geodesic distances of targets. Saves again the distances to json.\n\n    Parameters\n    ----------\n    iterations: int\n    strength: float\n    \"\"\"\n    if self.target_LOW is None or self.target_HIGH is None:\n        raise RuntimeError(\"Targets not initialized. Call create_compound_targets() first.\")\n    self.target_LOW.laplacian_smoothing(iterations=iterations, strength=strength)\n    self.target_HIGH.laplacian_smoothing(iterations=iterations, strength=strength)\n    self.target_LOW.save_distances(\"distances_LOW.json\")\n    self.target_HIGH.save_distances(\"distances_HIGH.json\")\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.InterpolationSlicingPreprocessor.create_gradient_evaluation","title":"create_gradient_evaluation","text":"<pre><code>create_gradient_evaluation(target_1, target_2=None, save_output=True, norm_filename='gradient_norm.json', g_filename='gradient.json')\n</code></pre> <p>Creates a compas_slicer.pre_processing.GradientEvaluation that is stored in self.g_evaluation Also, computes the gradient and gradient_norm and saves them to Json .</p> Source code in <code>src/compas_slicer/pre_processing/interpolation_slicing_preprocessor.py</code> <pre><code>def create_gradient_evaluation(\n    self,\n    target_1: CompoundTarget,\n    target_2: CompoundTarget | None = None,\n    save_output: bool = True,\n    norm_filename: str = 'gradient_norm.json',\n    g_filename: str = 'gradient.json',\n) -&gt; GradientEvaluation:\n    \"\"\"\n    Creates a compas_slicer.pre_processing.GradientEvaluation that is stored in self.g_evaluation\n    Also, computes the gradient and gradient_norm and saves them to Json .\n    \"\"\"\n    if self.target_LOW is None or self.target_HIGH is None:\n        raise RuntimeError(\"Targets not initialized. Call create_compound_targets() first.\")\n    if self.target_LOW.VN != target_1.VN:\n        raise ValueError(\"Preprocessor does not match targets: vertex count mismatch.\")\n    assign_interpolation_distance_to_mesh_vertices(self.mesh, weight=0.5,\n                                                   target_LOW=self.target_LOW, target_HIGH=self.target_HIGH)\n    g_evaluation = GradientEvaluation(self.mesh, self.DATA_PATH)\n    g_evaluation.compute_gradient()\n    g_evaluation.compute_gradient_norm()\n\n    if save_output:\n        # save results to json\n        utils.save_to_json(g_evaluation.vertex_gradient_norm, self.OUTPUT_PATH, norm_filename)\n        utils.save_to_json(utils.point_list_to_dict(g_evaluation.vertex_gradient), self.OUTPUT_PATH, g_filename)\n\n    return g_evaluation\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.InterpolationSlicingPreprocessor.find_critical_points","title":"find_critical_points","text":"<pre><code>find_critical_points(g_evaluation, output_filenames)\n</code></pre> <p>Computes and saves to json the critical points of the df on the mesh (minima, maxima, saddles)</p> Source code in <code>src/compas_slicer/pre_processing/interpolation_slicing_preprocessor.py</code> <pre><code>def find_critical_points(\n    self, g_evaluation: GradientEvaluation, output_filenames: tuple[str, str, str]\n) -&gt; None:\n    \"\"\" Computes and saves to json the critical points of the df on the mesh (minima, maxima, saddles)\"\"\"\n    g_evaluation.find_critical_points()\n    # save results to json\n    utils.save_to_json(g_evaluation.minima, self.OUTPUT_PATH, output_filenames[0])\n    utils.save_to_json(g_evaluation.maxima, self.OUTPUT_PATH, output_filenames[1])\n    utils.save_to_json(g_evaluation.saddles, self.OUTPUT_PATH, output_filenames[2])\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.InterpolationSlicingPreprocessor.region_split","title":"region_split","text":"<pre><code>region_split(cut_mesh=True, separate_neighborhoods=True, topological_sorting=True, save_split_meshes=True)\n</code></pre> <p>Splits the mesh on the saddle points. This process can take a long time. It consists of four parts: 1) Create cuts on the mesh so that they intersect the saddle points and follow the get_distance function iso-contour 2) Separate mesh neighborhoods  from cuts 3) Topological sorting of split meshes to determine their connectivity and sequence. 4) Finally resulting meshes are saved to json.</p> <p>The intermediary outputs are saved to json, so if you don'weight want to be recomputing the entire thing every time, you can turn the respective processes to false.</p> Source code in <code>src/compas_slicer/pre_processing/interpolation_slicing_preprocessor.py</code> <pre><code>def region_split(\n    self,\n    cut_mesh: bool = True,\n    separate_neighborhoods: bool = True,\n    topological_sorting: bool = True,\n    save_split_meshes: bool = True,\n) -&gt; None:\n    \"\"\"\n    Splits the mesh on the saddle points. This process can take a long time.\n    It consists of four parts:\n    1) Create cuts on the mesh so that they intersect the saddle points and follow the get_distance function\n    iso-contour\n    2) Separate mesh neighborhoods  from cuts\n    3) Topological sorting of split meshes to determine their connectivity and sequence.\n    4) Finally resulting meshes are saved to json.\n\n    The intermediary outputs are saved to json, so if you don'weight want to be recomputing the entire thing every\n    time, you can turn the respective processes to false.\n    \"\"\"\n\n    logger.info(\"--- Mesh region splitting\")\n\n    if cut_mesh:  # (1)\n        self.mesh.update_default_vertex_attributes({'cut': 0})\n        mesh_splitter = rs.MeshSplitter(self.mesh, self.target_LOW, self.target_HIGH, self.DATA_PATH)\n        mesh_splitter.run()\n\n        self.mesh = mesh_splitter.mesh\n        logger.info('Completed Region splitting')\n        logger.info(f\"Region split cut indices: {mesh_splitter.cut_indices}\")\n        # save results to json\n        output_path = Path(self.OUTPUT_PATH)\n        self.mesh.to_obj(str(output_path / 'mesh_with_cuts.obj'))\n        self.mesh.to_json(str(output_path / 'mesh_with_cuts.json'))\n        logger.info(f\"Saving to Obj and Json: {output_path / 'mesh_with_cuts.json'}\")\n\n    if separate_neighborhoods:  # (2)\n        logger.info(\"--- Separating mesh disconnected components\")\n        self.mesh = Mesh.from_json(str(Path(self.OUTPUT_PATH) / 'mesh_with_cuts.json'))\n        region_split_cut_indices = get_existing_cut_indices(self.mesh)\n\n        # save results to json\n        utils.save_to_json(get_vertices_that_belong_to_cuts(self.mesh, region_split_cut_indices),\n                           self.OUTPUT_PATH, \"vertices_on_cuts.json\")\n\n        self.split_meshes = rs.separate_disconnected_components(self.mesh, attr='cut',\n                                                                values=region_split_cut_indices,\n                                                                OUTPUT_PATH=self.OUTPUT_PATH)\n        logger.info(f'Created {len(self.split_meshes)} split meshes.')\n\n    if topological_sorting:  # (3)\n        logger.info(\"--- Topological sort of meshes directed graph to determine print order\")\n        graph = topo_sort.MeshDirectedGraph(self.split_meshes, self.DATA_PATH)\n        all_orders = graph.get_all_topological_orders()\n        selected_order = all_orders[0]\n        logger.info(f'selected_order: {selected_order}')  # TODO: improve the way an order is selected\n        self.cleanup_mesh_attributes_based_on_selected_order(selected_order, graph)\n\n        # reorder split_meshes based on selected order\n        self.split_meshes = [self.split_meshes[i] for i in selected_order]\n\n    # --- save split meshes\n    if save_split_meshes:  # (4)\n        logger.info(\"--- Saving resulting split meshes\")\n        output_path = Path(self.OUTPUT_PATH)\n        for i, m in enumerate(self.split_meshes):\n            m.to_obj(str(output_path / f'split_mesh_{i}.obj'))\n            m.to_json(str(output_path / f'split_mesh_{i}.json'))\n        logger.info(f'Saving to Obj and Json: {output_path / \"split_mesh_%.obj\"}')\n        logger.info(f\"Saved {len(self.split_meshes)} split_meshes\")\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.InterpolationSlicingPreprocessor.cleanup_mesh_attributes_based_on_selected_order","title":"cleanup_mesh_attributes_based_on_selected_order","text":"<pre><code>cleanup_mesh_attributes_based_on_selected_order(selected_order, graph)\n</code></pre> <p>Based on the selected order of split meshes, it rearranges their attributes, so that they can then be used with an interpolation slicer that requires data['boundary'] to be filled for every vertex. The vertices that originated from cuts have data['cut']=cut_index. This is replaced by data['boundary'] = 1 or 2 depending on connectivity of mesh.</p> <p>Parameters:</p> Name Type Description Default <code>selected_order</code> <code>list[int]</code> <p>The indices of ordered split meshes.</p> required <code>graph</code> <code>MeshDirectedGraph</code> required Source code in <code>src/compas_slicer/pre_processing/interpolation_slicing_preprocessor.py</code> <pre><code>def cleanup_mesh_attributes_based_on_selected_order(\n    self, selected_order: list[int], graph: MeshDirectedGraph\n) -&gt; None:\n    \"\"\"\n    Based on the selected order of split meshes, it rearranges their attributes, so that they can then be used\n    with an interpolation slicer that requires data['boundary'] to be filled for every vertex.\n    The vertices that originated from cuts have data['cut']=cut_index. This is replaced\n    by data['boundary'] = 1 or 2 depending on connectivity of mesh.\n\n    Parameters\n    ----------\n    selected_order: list, int\n        The indices of ordered split meshes.\n    graph: :class: 'networkx.Graph'\n    \"\"\"\n    for index in selected_order:\n        mesh = self.split_meshes[index]\n        for child_node in graph.adj_list[index]:\n            child_mesh = self.split_meshes[child_node]\n            edge = graph.G.edges[index, child_node]\n            common_cuts = edge['cut']\n            for cut_id in common_cuts:\n                replace_mesh_vertex_attribute(mesh, 'cut', cut_id, 'boundary', 2)\n                replace_mesh_vertex_attribute(child_mesh, 'cut', cut_id, 'boundary', 1)\n\n        # save results to json\n        pts_boundary_LOW = utils.get_mesh_vertex_coords_with_attribute(mesh, 'boundary', 1)\n        pts_boundary_HIGH = utils.get_mesh_vertex_coords_with_attribute(mesh, 'boundary', 2)\n        utils.save_to_json(utils.point_list_to_dict(pts_boundary_LOW), self.OUTPUT_PATH,\n                           f'pts_boundary_LOW_{index}.json')\n        utils.save_to_json(utils.point_list_to_dict(pts_boundary_HIGH), self.OUTPUT_PATH,\n                           f'pts_boundary_HIGH_{index}.json')\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.move_mesh_to_point","title":"move_mesh_to_point","text":"<pre><code>move_mesh_to_point(mesh, target_point)\n</code></pre> <p>Moves (translates) a mesh to a target point.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>A compas mesh.</p> required <code>target_point</code> <code>Point</code> <p>The point to move the mesh to.</p> required Source code in <code>src/compas_slicer/pre_processing/positioning.py</code> <pre><code>def move_mesh_to_point(mesh: Mesh, target_point: Point) -&gt; Mesh:\n    \"\"\"Moves (translates) a mesh to a target point.\n\n    Parameters\n    ----------\n    mesh: :class:`compas.datastructures.Mesh`\n        A compas mesh.\n    target_point: :class:`compas.geometry.Point`\n        The point to move the mesh to.\n    \"\"\"\n    mesh_center_pt = get_mid_pt_base(mesh)\n\n    # transform mesh\n    mesh_frame = Frame(mesh_center_pt, (1, 0, 0), (0, 1, 0))\n    target_frame = Frame(target_point, (1, 0, 0), (0, 1, 0))\n\n    T = Transformation.from_frame_to_frame(mesh_frame, target_frame)\n    mesh.transform(T)\n\n    logger.info(f\"Mesh moved to: {target_point}\")\n\n    return mesh\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.get_mid_pt_base","title":"get_mid_pt_base","text":"<pre><code>get_mid_pt_base(mesh)\n</code></pre> <p>Gets the middle point of the base (bottom) of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>A compas mesh.</p> required <p>Returns:</p> Name Type Description <code>mesh_mid_pt</code> <code>:class:`compas.geometry.Point`</code> <p>Middle point of the base of the mesh.</p> Source code in <code>src/compas_slicer/pre_processing/positioning.py</code> <pre><code>def get_mid_pt_base(mesh: Mesh) -&gt; Point:\n    \"\"\"Gets the middle point of the base (bottom) of the mesh.\n\n    Parameters\n    ----------\n    mesh: :class:`compas.datastructures.Mesh`\n        A compas mesh.\n\n    Returns\n    -------\n    mesh_mid_pt: :class:`compas.geometry.Point`\n        Middle point of the base of the mesh.\n\n    \"\"\"\n    # get center bottom point of mesh model\n    vertices = list(mesh.vertices_attributes('xyz'))\n    bbox = bounding_box(vertices)\n    corner_pts = [bbox[0], bbox[2]]\n\n    x = [p[0] for p in corner_pts]\n    y = [p[1] for p in corner_pts]\n    z = [p[2] for p in corner_pts]\n\n    mesh_mid_pt = Point((sum(x) / 2), (sum(y) / 2), (sum(z) / 2))\n\n    return mesh_mid_pt\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.remesh_mesh","title":"remesh_mesh","text":"<pre><code>remesh_mesh(mesh, target_edge_length, number_of_iterations=10, do_project=True)\n</code></pre> <p>Remesh a triangle mesh to achieve uniform edge lengths.</p> <p>Uses CGAL's isotropic remeshing to improve mesh quality for slicing. This can help with curved slicing and geodesic computations.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>A compas mesh (must be triangulated).</p> required <code>target_edge_length</code> <code>float</code> <p>Target edge length for the remeshed output.</p> required <code>number_of_iterations</code> <code>int</code> <p>Number of remeshing iterations (default: 10).</p> <code>10</code> <code>do_project</code> <code>bool</code> <p>Reproject vertices onto original surface (default: True).</p> <code>True</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>Remeshed compas mesh.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If compas_cgal is not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.datastructures import Mesh\n&gt;&gt;&gt; from compas_slicer.pre_processing import remesh_mesh\n&gt;&gt;&gt; mesh = Mesh.from_stl('model.stl')\n&gt;&gt;&gt; remeshed = remesh_mesh(mesh, target_edge_length=2.0)\n</code></pre> Source code in <code>src/compas_slicer/pre_processing/positioning.py</code> <pre><code>def remesh_mesh(\n    mesh: Mesh,\n    target_edge_length: float,\n    number_of_iterations: int = 10,\n    do_project: bool = True\n) -&gt; Mesh:\n    \"\"\"Remesh a triangle mesh to achieve uniform edge lengths.\n\n    Uses CGAL's isotropic remeshing to improve mesh quality for slicing.\n    This can help with curved slicing and geodesic computations.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        A compas mesh (must be triangulated).\n    target_edge_length : float\n        Target edge length for the remeshed output.\n    number_of_iterations : int\n        Number of remeshing iterations (default: 10).\n    do_project : bool\n        Reproject vertices onto original surface (default: True).\n\n    Returns\n    -------\n    Mesh\n        Remeshed compas mesh.\n\n    Raises\n    ------\n    ImportError\n        If compas_cgal is not available.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from compas.datastructures import Mesh\n    &gt;&gt;&gt; from compas_slicer.pre_processing import remesh_mesh\n    &gt;&gt;&gt; mesh = Mesh.from_stl('model.stl')\n    &gt;&gt;&gt; remeshed = remesh_mesh(mesh, target_edge_length=2.0)\n    \"\"\"\n    try:\n        from compas_cgal.meshing import trimesh_remesh\n    except ImportError as e:\n        raise ImportError(\n            \"remesh_mesh requires compas_cgal. Install with: pip install compas_cgal\"\n        ) from e\n\n    from compas.datastructures import Mesh as CompasMesh\n\n    M = mesh.to_vertices_and_faces()\n    V, F = trimesh_remesh(M, target_edge_length, number_of_iterations, do_project)\n\n    result = CompasMesh.from_vertices_and_faces(V.tolist(), F.tolist())\n\n    logger.info(\n        f\"Remeshed: {mesh.number_of_vertices()} -&gt; {result.number_of_vertices()} vertices, \"\n        f\"target edge length: {target_edge_length}\"\n    )\n\n    return result\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.gradient_evaluation","title":"gradient_evaluation","text":""},{"location":"api/pre_processing/#compas_slicer.pre_processing.gradient_evaluation.GradientEvaluation","title":"GradientEvaluation","text":"<pre><code>GradientEvaluation(mesh, DATA_PATH)\n</code></pre> <p>Evaluation of the gradient of the scalar function of the mesh. The scalar function should be stored as a vertex attribute on every vertex, with key='scalar_field'</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>:class: 'compas.datastructures.Mesh'</code> <code>DATA_PATH</code> <code>str, path to the data folder</code> Source code in <code>src/compas_slicer/pre_processing/gradient_evaluation.py</code> <pre><code>def __init__(self, mesh: Mesh, DATA_PATH: str | FilePath) -&gt; None:\n    for v_key, data in mesh.vertices(data=True):\n        if 'scalar_field' not in data:\n            raise ValueError(f\"Vertex {v_key} does not have the attribute 'scalar_field'\")\n\n    logger.info('Gradient evaluation')\n    self.mesh = mesh\n    self.DATA_PATH = DATA_PATH\n    self.OUTPUT_PATH = utils.get_output_directory(DATA_PATH)\n\n    self.minima: list[int] = []\n    self.maxima: list[int] = []\n    self.saddles: list[int] = []\n\n    self.face_gradient: NDArray[np.floating] | list = []  # np.array (#F x 3) one gradient vector per face.\n    self.vertex_gradient: NDArray[np.floating] | list = []  # np.array (#V x 3) one gradient vector per vertex.\n    self.face_gradient_norm: list[float] = []  # list (#F x 1)\n    self.vertex_gradient_norm: list[float] = []  # list (#V x 1)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.gradient_evaluation.GradientEvaluation.compute_gradient","title":"compute_gradient","text":"<pre><code>compute_gradient()\n</code></pre> <p>Computes the gradient on the faces and the vertices.</p> Source code in <code>src/compas_slicer/pre_processing/gradient_evaluation.py</code> <pre><code>def compute_gradient(self) -&gt; None:\n    \"\"\" Computes the gradient on the faces and the vertices. \"\"\"\n    u_v = [self.mesh.vertex[vkey]['scalar_field'] for vkey in self.mesh.vertices()]\n    self.face_gradient = get_face_gradient_from_scalar_field(self.mesh, u_v)\n    self.vertex_gradient = get_vertex_gradient_from_face_gradient(self.mesh, self.face_gradient)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.gradient_evaluation.GradientEvaluation.compute_gradient_norm","title":"compute_gradient_norm","text":"<pre><code>compute_gradient_norm()\n</code></pre> <p>Computes the norm of the gradient.</p> Source code in <code>src/compas_slicer/pre_processing/gradient_evaluation.py</code> <pre><code>def compute_gradient_norm(self) -&gt; None:\n    \"\"\" Computes the norm of the gradient. \"\"\"\n    logger.info('Computing norm of gradient')\n    f_g = np.array([self.face_gradient[i] for i, fkey in enumerate(self.mesh.faces())])\n    v_g = np.array([self.vertex_gradient[i] for i, vkey in enumerate(self.mesh.vertices())])\n    self.face_gradient_norm = list(np.linalg.norm(f_g, axis=1))\n    self.vertex_gradient_norm = list(np.linalg.norm(v_g, axis=1))\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.gradient_evaluation.GradientEvaluation.find_critical_points","title":"find_critical_points","text":"<pre><code>find_critical_points()\n</code></pre> <p>Finds minima, maxima and saddle points of the scalar function on the mesh.</p> Source code in <code>src/compas_slicer/pre_processing/gradient_evaluation.py</code> <pre><code>def find_critical_points(self) -&gt; None:\n    \"\"\" Finds minima, maxima and saddle points of the scalar function on the mesh. \"\"\"\n    for vkey, data in self.mesh.vertices(data=True):\n        current_v = data['scalar_field']\n        neighbors = self.mesh.vertex_neighbors(vkey, ordered=True)\n        values = []\n        if len(neighbors) &gt; 0:\n            neighbors.append(neighbors[0])\n            for n in neighbors:\n                v = self.mesh.vertex_attributes(n)['scalar_field']\n                if abs(v - current_v) &gt; 0.0:\n                    values.append(current_v - v)\n            sgc = count_sign_changes(values)\n\n            if sgc == 0:  # extreme point\n                if current_v &gt; self.mesh.vertex_attributes(neighbors[0])['scalar_field']:\n                    self.maxima.append(vkey)\n                else:\n                    self.minima.append(vkey)\n            if sgc == 2:  # regular point\n                pass\n            if sgc &gt; 2 and sgc % 2 == 0:\n                self.saddles.append(vkey)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.gradient_evaluation.count_sign_changes","title":"count_sign_changes","text":"<pre><code>count_sign_changes(values)\n</code></pre> <p>Returns the number of sign changes in a list of values.</p> Source code in <code>src/compas_slicer/pre_processing/gradient_evaluation.py</code> <pre><code>def count_sign_changes(values: list[float]) -&gt; int:\n    \"\"\" Returns the number of sign changes in a list of values. \"\"\"\n    count = 0\n    prev_v: float = 0.0\n    for i, v in enumerate(values):\n        if i == 0:\n            prev_v = v\n        else:\n            if prev_v * v &lt; 0:\n                count += 1\n            prev_v = v\n    return count\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.interpolation_slicing_preprocessor","title":"interpolation_slicing_preprocessor","text":""},{"location":"api/pre_processing/#compas_slicer.pre_processing.interpolation_slicing_preprocessor.InterpolationSlicingPreprocessor","title":"InterpolationSlicingPreprocessor","text":"<pre><code>InterpolationSlicingPreprocessor(mesh, config=None, DATA_PATH='.')\n</code></pre> <p>Handles pre-processing for interpolation slicing.</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>Mesh</code> <p>Input mesh.</p> <code>config</code> <code>InterpolationConfig</code> <p>Interpolation configuration.</p> <code>DATA_PATH</code> <code>str | Path</code> <p>Path to the data folder.</p> Source code in <code>src/compas_slicer/pre_processing/interpolation_slicing_preprocessor.py</code> <pre><code>def __init__(\n    self, mesh: Mesh, config: InterpolationConfig | None = None, DATA_PATH: str | Path = \".\"\n) -&gt; None:\n    self.mesh = mesh\n    self.config = config if config else InterpolationConfig()\n    self.DATA_PATH = DATA_PATH\n\n    self.OUTPUT_PATH = utils.get_output_directory(DATA_PATH)\n    self.target_LOW: CompoundTarget | None = None\n    self.target_HIGH: CompoundTarget | None = None\n\n    self.split_meshes: list[Mesh] = []\n    # The meshes that result from the region splitting process.\n\n    utils.utils.check_triangular_mesh(mesh)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.interpolation_slicing_preprocessor.InterpolationSlicingPreprocessor.create_compound_targets","title":"create_compound_targets","text":"<pre><code>create_compound_targets()\n</code></pre> <p>Create target_LOW and target_HIGH and compute geodesic distances.</p> Source code in <code>src/compas_slicer/pre_processing/interpolation_slicing_preprocessor.py</code> <pre><code>def create_compound_targets(self) -&gt; None:\n    \"\"\"Create target_LOW and target_HIGH and compute geodesic distances.\"\"\"\n\n    # --- low target\n    geodesics_method = self.config.target_low_geodesics_method.value\n    method = 'min'  # no other union methods currently supported for lower target\n    params: list[float] = []\n    self.target_LOW = CompoundTarget(self.mesh, 'boundary', 1, self.DATA_PATH,\n                                     union_method=method,\n                                     union_params=params,\n                                     geodesics_method=geodesics_method)\n\n    # --- high target\n    geodesics_method = self.config.target_high_geodesics_method.value\n    method = self.config.target_high_union_method.value\n    params = self.config.target_high_union_params\n    logger.info(f\"Creating target with union type: {method} and params: {params}\")\n    self.target_HIGH = CompoundTarget(self.mesh, 'boundary', 2, self.DATA_PATH,\n                                      union_method=method,\n                                      union_params=params,\n                                      geodesics_method=geodesics_method)\n\n    # --- uneven boundaries of high target\n    self.target_HIGH.offset = self.config.uneven_upper_targets_offset\n    self.target_HIGH.compute_uneven_boundaries_weight_max(self.target_LOW)\n\n    #  --- save intermediary get_distance outputs\n    self.target_LOW.save_distances(\"distances_LOW.json\")\n    self.target_HIGH.save_distances(\"distances_HIGH.json\")\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.interpolation_slicing_preprocessor.InterpolationSlicingPreprocessor.targets_laplacian_smoothing","title":"targets_laplacian_smoothing","text":"<pre><code>targets_laplacian_smoothing(iterations, strength)\n</code></pre> <p>Smooth geodesic distances of targets. Saves again the distances to json.</p> <p>Parameters:</p> Name Type Description Default <code>iterations</code> <code>int</code> required <code>strength</code> <code>float</code> required Source code in <code>src/compas_slicer/pre_processing/interpolation_slicing_preprocessor.py</code> <pre><code>def targets_laplacian_smoothing(self, iterations: int, strength: float) -&gt; None:\n    \"\"\"\n    Smooth geodesic distances of targets. Saves again the distances to json.\n\n    Parameters\n    ----------\n    iterations: int\n    strength: float\n    \"\"\"\n    if self.target_LOW is None or self.target_HIGH is None:\n        raise RuntimeError(\"Targets not initialized. Call create_compound_targets() first.\")\n    self.target_LOW.laplacian_smoothing(iterations=iterations, strength=strength)\n    self.target_HIGH.laplacian_smoothing(iterations=iterations, strength=strength)\n    self.target_LOW.save_distances(\"distances_LOW.json\")\n    self.target_HIGH.save_distances(\"distances_HIGH.json\")\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.interpolation_slicing_preprocessor.InterpolationSlicingPreprocessor.create_gradient_evaluation","title":"create_gradient_evaluation","text":"<pre><code>create_gradient_evaluation(target_1, target_2=None, save_output=True, norm_filename='gradient_norm.json', g_filename='gradient.json')\n</code></pre> <p>Creates a compas_slicer.pre_processing.GradientEvaluation that is stored in self.g_evaluation Also, computes the gradient and gradient_norm and saves them to Json .</p> Source code in <code>src/compas_slicer/pre_processing/interpolation_slicing_preprocessor.py</code> <pre><code>def create_gradient_evaluation(\n    self,\n    target_1: CompoundTarget,\n    target_2: CompoundTarget | None = None,\n    save_output: bool = True,\n    norm_filename: str = 'gradient_norm.json',\n    g_filename: str = 'gradient.json',\n) -&gt; GradientEvaluation:\n    \"\"\"\n    Creates a compas_slicer.pre_processing.GradientEvaluation that is stored in self.g_evaluation\n    Also, computes the gradient and gradient_norm and saves them to Json .\n    \"\"\"\n    if self.target_LOW is None or self.target_HIGH is None:\n        raise RuntimeError(\"Targets not initialized. Call create_compound_targets() first.\")\n    if self.target_LOW.VN != target_1.VN:\n        raise ValueError(\"Preprocessor does not match targets: vertex count mismatch.\")\n    assign_interpolation_distance_to_mesh_vertices(self.mesh, weight=0.5,\n                                                   target_LOW=self.target_LOW, target_HIGH=self.target_HIGH)\n    g_evaluation = GradientEvaluation(self.mesh, self.DATA_PATH)\n    g_evaluation.compute_gradient()\n    g_evaluation.compute_gradient_norm()\n\n    if save_output:\n        # save results to json\n        utils.save_to_json(g_evaluation.vertex_gradient_norm, self.OUTPUT_PATH, norm_filename)\n        utils.save_to_json(utils.point_list_to_dict(g_evaluation.vertex_gradient), self.OUTPUT_PATH, g_filename)\n\n    return g_evaluation\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.interpolation_slicing_preprocessor.InterpolationSlicingPreprocessor.find_critical_points","title":"find_critical_points","text":"<pre><code>find_critical_points(g_evaluation, output_filenames)\n</code></pre> <p>Computes and saves to json the critical points of the df on the mesh (minima, maxima, saddles)</p> Source code in <code>src/compas_slicer/pre_processing/interpolation_slicing_preprocessor.py</code> <pre><code>def find_critical_points(\n    self, g_evaluation: GradientEvaluation, output_filenames: tuple[str, str, str]\n) -&gt; None:\n    \"\"\" Computes and saves to json the critical points of the df on the mesh (minima, maxima, saddles)\"\"\"\n    g_evaluation.find_critical_points()\n    # save results to json\n    utils.save_to_json(g_evaluation.minima, self.OUTPUT_PATH, output_filenames[0])\n    utils.save_to_json(g_evaluation.maxima, self.OUTPUT_PATH, output_filenames[1])\n    utils.save_to_json(g_evaluation.saddles, self.OUTPUT_PATH, output_filenames[2])\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.interpolation_slicing_preprocessor.InterpolationSlicingPreprocessor.region_split","title":"region_split","text":"<pre><code>region_split(cut_mesh=True, separate_neighborhoods=True, topological_sorting=True, save_split_meshes=True)\n</code></pre> <p>Splits the mesh on the saddle points. This process can take a long time. It consists of four parts: 1) Create cuts on the mesh so that they intersect the saddle points and follow the get_distance function iso-contour 2) Separate mesh neighborhoods  from cuts 3) Topological sorting of split meshes to determine their connectivity and sequence. 4) Finally resulting meshes are saved to json.</p> <p>The intermediary outputs are saved to json, so if you don'weight want to be recomputing the entire thing every time, you can turn the respective processes to false.</p> Source code in <code>src/compas_slicer/pre_processing/interpolation_slicing_preprocessor.py</code> <pre><code>def region_split(\n    self,\n    cut_mesh: bool = True,\n    separate_neighborhoods: bool = True,\n    topological_sorting: bool = True,\n    save_split_meshes: bool = True,\n) -&gt; None:\n    \"\"\"\n    Splits the mesh on the saddle points. This process can take a long time.\n    It consists of four parts:\n    1) Create cuts on the mesh so that they intersect the saddle points and follow the get_distance function\n    iso-contour\n    2) Separate mesh neighborhoods  from cuts\n    3) Topological sorting of split meshes to determine their connectivity and sequence.\n    4) Finally resulting meshes are saved to json.\n\n    The intermediary outputs are saved to json, so if you don'weight want to be recomputing the entire thing every\n    time, you can turn the respective processes to false.\n    \"\"\"\n\n    logger.info(\"--- Mesh region splitting\")\n\n    if cut_mesh:  # (1)\n        self.mesh.update_default_vertex_attributes({'cut': 0})\n        mesh_splitter = rs.MeshSplitter(self.mesh, self.target_LOW, self.target_HIGH, self.DATA_PATH)\n        mesh_splitter.run()\n\n        self.mesh = mesh_splitter.mesh\n        logger.info('Completed Region splitting')\n        logger.info(f\"Region split cut indices: {mesh_splitter.cut_indices}\")\n        # save results to json\n        output_path = Path(self.OUTPUT_PATH)\n        self.mesh.to_obj(str(output_path / 'mesh_with_cuts.obj'))\n        self.mesh.to_json(str(output_path / 'mesh_with_cuts.json'))\n        logger.info(f\"Saving to Obj and Json: {output_path / 'mesh_with_cuts.json'}\")\n\n    if separate_neighborhoods:  # (2)\n        logger.info(\"--- Separating mesh disconnected components\")\n        self.mesh = Mesh.from_json(str(Path(self.OUTPUT_PATH) / 'mesh_with_cuts.json'))\n        region_split_cut_indices = get_existing_cut_indices(self.mesh)\n\n        # save results to json\n        utils.save_to_json(get_vertices_that_belong_to_cuts(self.mesh, region_split_cut_indices),\n                           self.OUTPUT_PATH, \"vertices_on_cuts.json\")\n\n        self.split_meshes = rs.separate_disconnected_components(self.mesh, attr='cut',\n                                                                values=region_split_cut_indices,\n                                                                OUTPUT_PATH=self.OUTPUT_PATH)\n        logger.info(f'Created {len(self.split_meshes)} split meshes.')\n\n    if topological_sorting:  # (3)\n        logger.info(\"--- Topological sort of meshes directed graph to determine print order\")\n        graph = topo_sort.MeshDirectedGraph(self.split_meshes, self.DATA_PATH)\n        all_orders = graph.get_all_topological_orders()\n        selected_order = all_orders[0]\n        logger.info(f'selected_order: {selected_order}')  # TODO: improve the way an order is selected\n        self.cleanup_mesh_attributes_based_on_selected_order(selected_order, graph)\n\n        # reorder split_meshes based on selected order\n        self.split_meshes = [self.split_meshes[i] for i in selected_order]\n\n    # --- save split meshes\n    if save_split_meshes:  # (4)\n        logger.info(\"--- Saving resulting split meshes\")\n        output_path = Path(self.OUTPUT_PATH)\n        for i, m in enumerate(self.split_meshes):\n            m.to_obj(str(output_path / f'split_mesh_{i}.obj'))\n            m.to_json(str(output_path / f'split_mesh_{i}.json'))\n        logger.info(f'Saving to Obj and Json: {output_path / \"split_mesh_%.obj\"}')\n        logger.info(f\"Saved {len(self.split_meshes)} split_meshes\")\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.interpolation_slicing_preprocessor.InterpolationSlicingPreprocessor.cleanup_mesh_attributes_based_on_selected_order","title":"cleanup_mesh_attributes_based_on_selected_order","text":"<pre><code>cleanup_mesh_attributes_based_on_selected_order(selected_order, graph)\n</code></pre> <p>Based on the selected order of split meshes, it rearranges their attributes, so that they can then be used with an interpolation slicer that requires data['boundary'] to be filled for every vertex. The vertices that originated from cuts have data['cut']=cut_index. This is replaced by data['boundary'] = 1 or 2 depending on connectivity of mesh.</p> <p>Parameters:</p> Name Type Description Default <code>selected_order</code> <code>list[int]</code> <p>The indices of ordered split meshes.</p> required <code>graph</code> <code>MeshDirectedGraph</code> required Source code in <code>src/compas_slicer/pre_processing/interpolation_slicing_preprocessor.py</code> <pre><code>def cleanup_mesh_attributes_based_on_selected_order(\n    self, selected_order: list[int], graph: MeshDirectedGraph\n) -&gt; None:\n    \"\"\"\n    Based on the selected order of split meshes, it rearranges their attributes, so that they can then be used\n    with an interpolation slicer that requires data['boundary'] to be filled for every vertex.\n    The vertices that originated from cuts have data['cut']=cut_index. This is replaced\n    by data['boundary'] = 1 or 2 depending on connectivity of mesh.\n\n    Parameters\n    ----------\n    selected_order: list, int\n        The indices of ordered split meshes.\n    graph: :class: 'networkx.Graph'\n    \"\"\"\n    for index in selected_order:\n        mesh = self.split_meshes[index]\n        for child_node in graph.adj_list[index]:\n            child_mesh = self.split_meshes[child_node]\n            edge = graph.G.edges[index, child_node]\n            common_cuts = edge['cut']\n            for cut_id in common_cuts:\n                replace_mesh_vertex_attribute(mesh, 'cut', cut_id, 'boundary', 2)\n                replace_mesh_vertex_attribute(child_mesh, 'cut', cut_id, 'boundary', 1)\n\n        # save results to json\n        pts_boundary_LOW = utils.get_mesh_vertex_coords_with_attribute(mesh, 'boundary', 1)\n        pts_boundary_HIGH = utils.get_mesh_vertex_coords_with_attribute(mesh, 'boundary', 2)\n        utils.save_to_json(utils.point_list_to_dict(pts_boundary_LOW), self.OUTPUT_PATH,\n                           f'pts_boundary_LOW_{index}.json')\n        utils.save_to_json(utils.point_list_to_dict(pts_boundary_HIGH), self.OUTPUT_PATH,\n                           f'pts_boundary_HIGH_{index}.json')\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.positioning","title":"positioning","text":""},{"location":"api/pre_processing/#compas_slicer.pre_processing.positioning.move_mesh_to_point","title":"move_mesh_to_point","text":"<pre><code>move_mesh_to_point(mesh, target_point)\n</code></pre> <p>Moves (translates) a mesh to a target point.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>A compas mesh.</p> required <code>target_point</code> <code>Point</code> <p>The point to move the mesh to.</p> required Source code in <code>src/compas_slicer/pre_processing/positioning.py</code> <pre><code>def move_mesh_to_point(mesh: Mesh, target_point: Point) -&gt; Mesh:\n    \"\"\"Moves (translates) a mesh to a target point.\n\n    Parameters\n    ----------\n    mesh: :class:`compas.datastructures.Mesh`\n        A compas mesh.\n    target_point: :class:`compas.geometry.Point`\n        The point to move the mesh to.\n    \"\"\"\n    mesh_center_pt = get_mid_pt_base(mesh)\n\n    # transform mesh\n    mesh_frame = Frame(mesh_center_pt, (1, 0, 0), (0, 1, 0))\n    target_frame = Frame(target_point, (1, 0, 0), (0, 1, 0))\n\n    T = Transformation.from_frame_to_frame(mesh_frame, target_frame)\n    mesh.transform(T)\n\n    logger.info(f\"Mesh moved to: {target_point}\")\n\n    return mesh\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.positioning.get_mid_pt_base","title":"get_mid_pt_base","text":"<pre><code>get_mid_pt_base(mesh)\n</code></pre> <p>Gets the middle point of the base (bottom) of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>A compas mesh.</p> required <p>Returns:</p> Name Type Description <code>mesh_mid_pt</code> <code>:class:`compas.geometry.Point`</code> <p>Middle point of the base of the mesh.</p> Source code in <code>src/compas_slicer/pre_processing/positioning.py</code> <pre><code>def get_mid_pt_base(mesh: Mesh) -&gt; Point:\n    \"\"\"Gets the middle point of the base (bottom) of the mesh.\n\n    Parameters\n    ----------\n    mesh: :class:`compas.datastructures.Mesh`\n        A compas mesh.\n\n    Returns\n    -------\n    mesh_mid_pt: :class:`compas.geometry.Point`\n        Middle point of the base of the mesh.\n\n    \"\"\"\n    # get center bottom point of mesh model\n    vertices = list(mesh.vertices_attributes('xyz'))\n    bbox = bounding_box(vertices)\n    corner_pts = [bbox[0], bbox[2]]\n\n    x = [p[0] for p in corner_pts]\n    y = [p[1] for p in corner_pts]\n    z = [p[2] for p in corner_pts]\n\n    mesh_mid_pt = Point((sum(x) / 2), (sum(y) / 2), (sum(z) / 2))\n\n    return mesh_mid_pt\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.positioning.remesh_mesh","title":"remesh_mesh","text":"<pre><code>remesh_mesh(mesh, target_edge_length, number_of_iterations=10, do_project=True)\n</code></pre> <p>Remesh a triangle mesh to achieve uniform edge lengths.</p> <p>Uses CGAL's isotropic remeshing to improve mesh quality for slicing. This can help with curved slicing and geodesic computations.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>A compas mesh (must be triangulated).</p> required <code>target_edge_length</code> <code>float</code> <p>Target edge length for the remeshed output.</p> required <code>number_of_iterations</code> <code>int</code> <p>Number of remeshing iterations (default: 10).</p> <code>10</code> <code>do_project</code> <code>bool</code> <p>Reproject vertices onto original surface (default: True).</p> <code>True</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>Remeshed compas mesh.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If compas_cgal is not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.datastructures import Mesh\n&gt;&gt;&gt; from compas_slicer.pre_processing import remesh_mesh\n&gt;&gt;&gt; mesh = Mesh.from_stl('model.stl')\n&gt;&gt;&gt; remeshed = remesh_mesh(mesh, target_edge_length=2.0)\n</code></pre> Source code in <code>src/compas_slicer/pre_processing/positioning.py</code> <pre><code>def remesh_mesh(\n    mesh: Mesh,\n    target_edge_length: float,\n    number_of_iterations: int = 10,\n    do_project: bool = True\n) -&gt; Mesh:\n    \"\"\"Remesh a triangle mesh to achieve uniform edge lengths.\n\n    Uses CGAL's isotropic remeshing to improve mesh quality for slicing.\n    This can help with curved slicing and geodesic computations.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        A compas mesh (must be triangulated).\n    target_edge_length : float\n        Target edge length for the remeshed output.\n    number_of_iterations : int\n        Number of remeshing iterations (default: 10).\n    do_project : bool\n        Reproject vertices onto original surface (default: True).\n\n    Returns\n    -------\n    Mesh\n        Remeshed compas mesh.\n\n    Raises\n    ------\n    ImportError\n        If compas_cgal is not available.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from compas.datastructures import Mesh\n    &gt;&gt;&gt; from compas_slicer.pre_processing import remesh_mesh\n    &gt;&gt;&gt; mesh = Mesh.from_stl('model.stl')\n    &gt;&gt;&gt; remeshed = remesh_mesh(mesh, target_edge_length=2.0)\n    \"\"\"\n    try:\n        from compas_cgal.meshing import trimesh_remesh\n    except ImportError as e:\n        raise ImportError(\n            \"remesh_mesh requires compas_cgal. Install with: pip install compas_cgal\"\n        ) from e\n\n    from compas.datastructures import Mesh as CompasMesh\n\n    M = mesh.to_vertices_and_faces()\n    V, F = trimesh_remesh(M, target_edge_length, number_of_iterations, do_project)\n\n    result = CompasMesh.from_vertices_and_faces(V.tolist(), F.tolist())\n\n    logger.info(\n        f\"Remeshed: {mesh.number_of_vertices()} -&gt; {result.number_of_vertices()} vertices, \"\n        f\"target edge length: {target_edge_length}\"\n    )\n\n    return result\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils","title":"preprocessing_utils","text":""},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.CompoundTarget","title":"CompoundTarget","text":"<pre><code>CompoundTarget(mesh, v_attr, value, DATA_PATH, union_method='min', union_params=None, geodesics_method='heat_cgal', anisotropic_scaling=False)\n</code></pre> <p>Represents a desired user-provided target. It acts as a key-frame that controls the print paths orientations. After the curved slicing , the print paths will be aligned to the compound target close to its area. The vertices that belong to the target are marked with their vertex attributes; they have data['v_attr'] = value.</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>:class:`compas.datastructures.Mesh`</code> <code>v_attr</code> <code>str</code> <p>The key of the attribute dict to be checked.</p> <code>value</code> <code>int</code> <p>The value of the attribute dict with key=v_attr. If in a vertex data[v_attr]==value then the vertex is part of this target.</p> <code>DATA_PATH</code> <code>str</code> <code>has_blend_union</code> <code>bool</code> <code>blend_radius</code> <code>float</code> <code>geodesics_method</code> <code>str</code> <p>'heat_cgal'  CGAL heat geodesic distances (recommended) 'heat'       custom heat geodesic distances</p> <code>anisotropic_scaling</code> <code>bool</code> <p>This is not yet implemented</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def __init__(\n    self,\n    mesh: Mesh,\n    v_attr: str,\n    value: int,\n    DATA_PATH: str,\n    union_method: UnionMethod = 'min',\n    union_params: list[Any] | None = None,\n    geodesics_method: GeodesicsMethod = 'heat_cgal',\n    anisotropic_scaling: bool = False,\n) -&gt; None:\n\n    if union_params is None:\n        union_params = []\n    logger.info(f'Creating target with attribute : {v_attr}={value}')\n    logger.info(f'union_method: {union_method}, union_params: {union_params}')\n    self.mesh = mesh\n    self.v_attr = v_attr\n    self.value = value\n    self.DATA_PATH = DATA_PATH\n    self.OUTPUT_PATH = utils.get_output_directory(DATA_PATH)\n\n    self.union_method = union_method\n    self.union_params = union_params\n\n    self.geodesics_method = geodesics_method\n    self.anisotropic_scaling = anisotropic_scaling  # Anisotropic scaling not yet implemented\n\n    self.offset = 0\n    self.VN = len(list(self.mesh.vertices()))\n\n    # filled in by function 'self.find_targets_connected_components()'\n    self.all_target_vkeys: list[int] = []  # flattened list with all vi_starts\n    self.clustered_vkeys: list[list[int]] = []  # nested list with all vi_starts\n    self.number_of_boundaries: int = 0\n\n    self.weight_max_per_cluster: list[float] = []\n\n    # geodesic distances\n    # filled in by function 'self.update_distances_lists()'\n    self._distances_lists: list[list[float]] = []  # Shape: number_of_boundaries x number_of_vertices\n    self._distances_lists_flipped: list[list[float]] = []  # Shape: number_of_vertices x number_of_boundaries\n    self._np_distances_lists_flipped: NDArray[np.floating] = np.array([])\n    self._max_dist: float | None = None  # maximum distance from target on any mesh vertex\n\n    # compute\n    self.find_targets_connected_components()\n    self.compute_geodesic_distances()\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.CompoundTarget.has_uneven_weights","title":"has_uneven_weights  <code>property</code>","text":"<pre><code>has_uneven_weights\n</code></pre> <p>Returns True if the target has uneven_weights calculated, False otherwise.</p>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.CompoundTarget.find_targets_connected_components","title":"find_targets_connected_components","text":"<pre><code>find_targets_connected_components()\n</code></pre> <p>Clusters all the vertices that belong to the target into neighborhoods using a graph. Each target can have an arbitrary number of neighborhoods/clusters. Fills in the attributes: self.all_target_vkeys, self.clustered_vkeys, self.number_of_boundaries</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def find_targets_connected_components(self) -&gt; None:\n    \"\"\"\n    Clusters all the vertices that belong to the target into neighborhoods using a graph.\n    Each target can have an arbitrary number of neighborhoods/clusters.\n    Fills in the attributes: self.all_target_vkeys, self.clustered_vkeys, self.number_of_boundaries\n    \"\"\"\n    self.all_target_vkeys = [vkey for vkey, data in self.mesh.vertices(data=True) if\n                             data[self.v_attr] == self.value]\n    if len(self.all_target_vkeys) == 0:\n        raise ValueError(\n            f\"No vertices in mesh with attribute '{self.v_attr}'={self.value}. \"\n            \"Check your target creation.\"\n        )\n    G = _create_graph_from_mesh_vkeys(self.mesh, self.all_target_vkeys)\n    if len(list(G.nodes())) != len(self.all_target_vkeys):\n        raise RuntimeError(\"Graph node count doesn't match target vertex count.\")\n    self.number_of_boundaries = len(list(nx.connected_components(G)))\n\n    for _i, cp in enumerate(nx.connected_components(G)):\n        self.clustered_vkeys.append(list(cp))\n    logger.info(\n        f\"Compound target with 'boundary'={self.value}. Number of connected_components : \"\n        f\"{len(list(nx.connected_components(G)))}\"\n    )\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.CompoundTarget.compute_geodesic_distances","title":"compute_geodesic_distances","text":"<pre><code>compute_geodesic_distances()\n</code></pre> <p>Computes the geodesic distances from each of the target's neighborhoods  to all the mesh vertices. Fills in the distances attributes.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def compute_geodesic_distances(self) -&gt; None:\n    \"\"\"\n    Computes the geodesic distances from each of the target's neighborhoods  to all the mesh vertices.\n    Fills in the distances attributes.\n    \"\"\"\n    if self.geodesics_method == 'exact_igl':\n        distances_lists = [get_igl_EXACT_geodesic_distances(self.mesh, vstarts) for vstarts in\n                           self.clustered_vkeys]\n    elif self.geodesics_method == 'heat_igl':\n        distances_lists = [get_igl_HEAT_geodesic_distances(self.mesh, vstarts) for vstarts in\n                           self.clustered_vkeys]\n    elif self.geodesics_method == 'heat_cgal':\n        distances_lists = [get_cgal_HEAT_geodesic_distances(self.mesh, vstarts) for vstarts in\n                           self.clustered_vkeys]\n    elif self.geodesics_method == 'heat':\n        distances_lists = [get_custom_HEAT_geodesic_distances(self.mesh, vstarts, str(self.OUTPUT_PATH)) for vstarts in\n                           self.clustered_vkeys]\n    else:\n        raise ValueError('Unknown geodesics method : ' + self.geodesics_method)\n\n    distances_lists = [list(dl) for dl in distances_lists]  # number_of_boundaries x #V\n    self.update_distances_lists(distances_lists)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.CompoundTarget.update_distances_lists","title":"update_distances_lists","text":"<pre><code>update_distances_lists(distances_lists)\n</code></pre> <p>Fills in the distances attributes.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def update_distances_lists(self, distances_lists: list[list[float]]) -&gt; None:\n    \"\"\"\n    Fills in the distances attributes.\n    \"\"\"\n    self._distances_lists = distances_lists\n    self._distances_lists_flipped = []  # empty\n    for i in range(self.VN):\n        current_values = [self._distances_lists[list_index][i] for list_index in range(self.number_of_boundaries)]\n        self._distances_lists_flipped.append(current_values)\n    self._np_distances_lists_flipped = np.array(self._distances_lists_flipped)\n    self._max_dist = np.max(self._np_distances_lists_flipped)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.CompoundTarget.compute_uneven_boundaries_weight_max","title":"compute_uneven_boundaries_weight_max","text":"<pre><code>compute_uneven_boundaries_weight_max(other_target)\n</code></pre> <p>If the target has multiple neighborhoods/clusters of vertices, then it computes their maximum distance from the other_target. Based on that it calculates their weight_max for the interpolation process</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def compute_uneven_boundaries_weight_max(self, other_target: CompoundTarget) -&gt; None:\n    \"\"\"\n    If the target has multiple neighborhoods/clusters of vertices, then it computes their maximum distance from\n    the other_target. Based on that it calculates their weight_max for the interpolation process\n    \"\"\"\n    if self.number_of_boundaries &gt; 1:\n        ds_avg_HIGH = self.get_boundaries_rel_dist_from_other_target(other_target)\n        max_param = max(ds_avg_HIGH)\n        for i, d in enumerate(ds_avg_HIGH):  # offset all distances except the maximum one\n            if abs(d - max_param) &gt; 0.01:  # if it isn't the max value\n                ds_avg_HIGH[i] = d + self.offset\n\n        self.weight_max_per_cluster = [d / max_param for d in ds_avg_HIGH]\n        logger.info(f'weight_max_per_cluster: {self.weight_max_per_cluster}')\n    else:\n        logger.info(\"Did not compute_norm_of_gradient uneven boundaries, target consists of single component\")\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.CompoundTarget.get_boundaries_rel_dist_from_other_target","title":"get_boundaries_rel_dist_from_other_target","text":"<pre><code>get_boundaries_rel_dist_from_other_target(other_target, avg_type='median')\n</code></pre> <p>Returns a list, one relative distance value per connected boundary neighborhood. That is the average of the distances of the vertices of that boundary neighborhood from the other_target.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def get_boundaries_rel_dist_from_other_target(\n    self, other_target: CompoundTarget, avg_type: Literal['mean', 'median'] = 'median'\n) -&gt; list[float]:\n    \"\"\"\n    Returns a list, one relative distance value per connected boundary neighborhood.\n    That is the average of the distances of the vertices of that boundary neighborhood from the other_target.\n    \"\"\"\n    distances = []\n    for vi_starts in self.clustered_vkeys:\n        ds = [other_target.get_distance(vi) for vi in vi_starts]\n        if avg_type == 'mean':\n            distances.append(statistics.mean(ds))\n        else:  # 'median'\n            distances.append(statistics.median(ds))\n    return distances\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.CompoundTarget.get_avg_distances_from_other_target","title":"get_avg_distances_from_other_target","text":"<pre><code>get_avg_distances_from_other_target(other_target)\n</code></pre> <p>Returns the minimum and maximum distance of the vertices of this target from the other_target</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def get_avg_distances_from_other_target(self, other_target: CompoundTarget) -&gt; float:\n    \"\"\"\n    Returns the minimum and maximum distance of the vertices of this target from the other_target\n    \"\"\"\n    extreme_distances = []\n    for v_index in other_target.all_target_vkeys:\n        extreme_distances.append(self.get_all_distances()[v_index])\n    return float(np.average(np.array(extreme_distances)))\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.CompoundTarget.get_all_clusters_distances_dict","title":"get_all_clusters_distances_dict","text":"<pre><code>get_all_clusters_distances_dict()\n</code></pre> <p>Returns dict. keys: index of connected target neighborhood, value: list, distances (one per vertex).</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def get_all_clusters_distances_dict(self) -&gt; dict[int, list[float]]:\n    \"\"\" Returns dict. keys: index of connected target neighborhood, value: list, distances (one per vertex). \"\"\"\n    return {i: self._distances_lists[i] for i in range(self.number_of_boundaries)}\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.CompoundTarget.get_max_dist","title":"get_max_dist","text":"<pre><code>get_max_dist()\n</code></pre> <p>Returns the maximum distance that the target has on a mesh vertex.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def get_max_dist(self) -&gt; float | None:\n    \"\"\" Returns the maximum distance that the target has on a mesh vertex. \"\"\"\n    return self._max_dist\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.CompoundTarget.get_all_distances","title":"get_all_distances","text":"<pre><code>get_all_distances()\n</code></pre> <p>Return distances for all vertices as 1D array, applying union method.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def get_all_distances(self) -&gt; np.ndarray:\n    \"\"\"Return distances for all vertices as 1D array, applying union method.\"\"\"\n    if self.union_method == 'min':\n        return np.min(self._np_distances_lists_flipped, axis=1)\n    elif self.union_method == 'smooth':\n        return np.array([\n            blend_union_list(row.tolist(), self.union_params[0])\n            for row in self._np_distances_lists_flipped\n        ])\n    elif self.union_method == 'chamfer':\n        return np.array([\n            chamfer_union_list(row.tolist(), self.union_params[0])\n            for row in self._np_distances_lists_flipped\n        ])\n    elif self.union_method == 'stairs':\n        return np.array([\n            stairs_union_list(row.tolist(), self.union_params[0], self.union_params[1])\n            for row in self._np_distances_lists_flipped\n        ])\n    else:\n        raise ValueError(f\"Unknown union method: {self.union_method}\")\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.CompoundTarget.get_all_distances_array","title":"get_all_distances_array","text":"<pre><code>get_all_distances_array()\n</code></pre> <p>Return raw distances as (n_boundaries, n_vertices) array.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def get_all_distances_array(self) -&gt; np.ndarray:\n    \"\"\"Return raw distances as (n_boundaries, n_vertices) array.\"\"\"\n    return np.array(self._distances_lists)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.CompoundTarget.get_all_distances_for_vkey","title":"get_all_distances_for_vkey","text":"<pre><code>get_all_distances_for_vkey(i)\n</code></pre> <p>Returns distances from each cluster separately for vertex i. Smooth union doesn't play here any role.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def get_all_distances_for_vkey(self, i: int) -&gt; list[float]:\n    \"\"\" Returns distances from each cluster separately for vertex i. Smooth union doesn't play here any role. \"\"\"\n    return [self._distances_lists[list_index][i] for list_index in range(self.number_of_boundaries)]\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.CompoundTarget.get_distance","title":"get_distance","text":"<pre><code>get_distance(i)\n</code></pre> <p>Return get_distance for vertex with vkey i.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def get_distance(self, i: int) -&gt; float:\n    \"\"\" Return get_distance for vertex with vkey i. \"\"\"\n    if self.union_method == 'min':\n        # --- simple union\n        return float(np.min(self._np_distances_lists_flipped[i]))\n    elif self.union_method == 'smooth':\n        # --- blend (smooth) union\n        return blend_union_list(values=self._np_distances_lists_flipped[i], r=self.union_params[0])\n    elif self.union_method == 'chamfer':\n        # --- blend (smooth) union\n        return chamfer_union_list(values=self._np_distances_lists_flipped[i], r=self.union_params[0])\n    elif self.union_method == 'stairs':\n        # --- stairs union\n        return stairs_union_list(values=self._np_distances_lists_flipped[i], r=self.union_params[0],\n                                 n=self.union_params[1])\n    else:\n        raise ValueError(\"Unknown Union method : \", self.union_method)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.CompoundTarget.laplacian_smoothing","title":"laplacian_smoothing","text":"<pre><code>laplacian_smoothing(iterations, strength)\n</code></pre> <p>Smooth the distances on the mesh, using iterative laplacian smoothing.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def laplacian_smoothing(self, iterations: int, strength: float) -&gt; None:\n    \"\"\" Smooth the distances on the mesh, using iterative laplacian smoothing. \"\"\"\n    L = utils.get_mesh_cotmatrix_igl(self.mesh, fix_boundaries=True)\n    new_distances_lists = []\n\n    logger.info('Laplacian smoothing of all distances')\n    for _i, a in enumerate(self._distances_lists):\n        a = np.array(a)  # a: numpy array containing the attribute to be smoothed\n        for _ in range(iterations):  # iterative smoothing\n            a_prime = a + strength * L * a\n            a = a_prime\n        new_distances_lists.append(list(a))\n    self.update_distances_lists(new_distances_lists)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.CompoundTarget.save_distances","title":"save_distances","text":"<pre><code>save_distances(name)\n</code></pre> <p>Save distances to json. Saves one list with distance values (one per vertex).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def save_distances(self, name: str) -&gt; None:\n    \"\"\"\n    Save distances to json.\n    Saves one list with distance values (one per vertex).\n\n    Parameters\n    ----------\n    name: str, name of json to be saved\n    \"\"\"\n    utils.save_to_json(self.get_all_distances().tolist(), self.OUTPUT_PATH, name)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.CompoundTarget.assign_new_mesh","title":"assign_new_mesh","text":"<pre><code>assign_new_mesh(mesh)\n</code></pre> <p>When the base mesh changes, a new mesh needs to be assigned.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def assign_new_mesh(self, mesh: Mesh) -&gt; None:\n    \"\"\" When the base mesh changes, a new mesh needs to be assigned. \"\"\"\n    mesh.to_json(self.OUTPUT_PATH + \"/temp.obj\")\n    mesh = Mesh.from_json(self.OUTPUT_PATH + \"/temp.obj\")\n    self.mesh = mesh\n    self.VN = len(list(self.mesh.vertices()))\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.GeodesicsCache","title":"GeodesicsCache","text":"<pre><code>GeodesicsCache()\n</code></pre> <p>Cache for geodesic distances to avoid redundant computations.</p> <p>Note: This class is kept for backwards compatibility but now uses CGAL. The CGAL solver has its own internal caching via _cgal_solver_cache.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/geodesics.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._cache: dict[tuple[int, str], NDArray[np.floating]] = {}\n    self._mesh_hash: int | None = None\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.GeodesicsCache.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Clear the cache.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/geodesics.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear the cache.\"\"\"\n    self._cache.clear()\n    self._mesh_hash = None\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.GeodesicsCache.get_distances","title":"get_distances","text":"<pre><code>get_distances(mesh, sources, method='heat')\n</code></pre> <p>Get geodesic distances from sources, using cache when possible.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh to compute distances on.</p> required <code>sources</code> <code>list[int]</code> <p>Source vertex indices.</p> required <code>method</code> <code>str</code> <p>Geodesic method (ignored, always uses CGAL heat method).</p> <code>'heat'</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Minimum distance from any source to each vertex.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/geodesics.py</code> <pre><code>def get_distances(\n    self, mesh: Mesh, sources: list[int], method: str = 'heat'\n) -&gt; NDArray[np.floating]:\n    \"\"\"Get geodesic distances from sources, using cache when possible.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh to compute distances on.\n    sources : list[int]\n        Source vertex indices.\n    method : str\n        Geodesic method (ignored, always uses CGAL heat method).\n\n    Returns\n    -------\n    NDArray\n        Minimum distance from any source to each vertex.\n    \"\"\"\n    return get_heat_geodesic_distances(mesh, sources)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.MeshSplitter","title":"MeshSplitter","text":"<pre><code>MeshSplitter(mesh, target_LOW, target_HIGH, DATA_PATH)\n</code></pre> <p>Curved slicing pre-processing step.</p> <p>Takes one continuous mesh with various saddle points and splits it up at every saddle point following the direction of the iso-contour that intersects that saddle point, so that the resulting mesh has no remaining saddle points.</p> <p>The result is a series of split meshes whose vertex attributes have been updated with boundary attributes at the newly created cuts, (i.e. they all have vertex 'boundary' attributes 1,2 on their lower and upper boundaries)</p> <p>For each newly created mesh, a separate slicer needs to be created. Like that, we will always have one slicer per mesh with the correct attributes already assigned. However, it can still happen that a slicer that takes a split mesh outputs more than one vertical_layers_print_data (vertical layers).</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>:class: 'compas.datastructures.Mesh'</code> <code>target_LOW</code> <code>:class: 'compas_slicer.pre_processing.CompoundTarget'</code> <code>target_HIGH</code> <code>:class: 'compas_slicer.pre_processing.CompoundTarget'</code> <code>DATA_PATH</code> <code>str, the path to the data folder</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/region_split.py</code> <pre><code>def __init__(self, mesh, target_LOW, target_HIGH, DATA_PATH):\n    self.mesh = mesh  # compas mesh\n    self.DATA_PATH = DATA_PATH\n    self.OUTPUT_PATH = utils.get_output_directory(DATA_PATH)\n    self.target_LOW, self.target_HIGH = target_LOW, target_HIGH\n\n    assign_interpolation_distance_to_mesh_vertices(self.mesh, weight=0.5, target_LOW=self.target_LOW,\n                                                   target_HIGH=self.target_HIGH)\n    # Late import to avoid circular dependency\n    from compas_slicer.pre_processing.gradient_evaluation import GradientEvaluation\n\n    g_evaluation = GradientEvaluation(self.mesh, self.DATA_PATH)\n    g_evaluation.find_critical_points()  # First estimation of saddle points with weight = 0.5\n    self.saddles = g_evaluation.saddles\n    self.cut_indices = []\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.MeshSplitter.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Runs the mesh splitting process. This consists of the following parts.</p> <p>(1) Find the iso-contours that intersect the saddle points. Iteratively find the weights (from 0 to 1) that output a distance field whose iso-contour is intersecting each saddle point. Here two iterations are carried out (one rough and one exact search).</p> <p>For each saddle point and its respective weight and iso-contour: (2) Find the zero-crossing points of the iso-contour and merge points that are close to the saddle to ensure connection. (3) Cleanup iso-contour. Only keep neighborhoods that are intersecting the saddle point. Discard all other. (4) Create the cut on the mesh. (5) Weld the resulting mesh, and restore all the vertex attributes. Note that the mesh remains in one piece, although the cuts have been created. (6) Update compound tardets with the new mesh.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/region_split.py</code> <pre><code>def run(self):\n    \"\"\"\n    Runs the mesh splitting process. This consists of the following parts.\n\n    (1) Find the iso-contours that intersect the saddle points.\n    Iteratively find the weights (from 0 to 1) that output a distance field whose iso-contour is intersecting\n    each saddle point. Here two iterations are carried out (one rough and one exact search).\n\n    For each saddle point and its respective weight and iso-contour:\n    (2) Find the zero-crossing points of the iso-contour and merge points that are close to the saddle to ensure\n    connection.\n    (3) Cleanup iso-contour. Only keep neighborhoods that are intersecting the saddle point. Discard all other.\n    (4) Create the cut on the mesh.\n    (5) Weld the resulting mesh, and restore all the vertex attributes. Note that the mesh remains in one piece,\n    although the cuts have been created.\n    (6) Update compound tardets with the new mesh.\n    \"\"\"\n\n    # (1) first rough estimation of split params\n    split_params = self.identify_positions_to_split(self.saddles)\n    # TODO: merge params that are too close together to avoid creation of very thin neighborhoods.\n    logger.info(f\"{len(split_params)} Split params. First rough estimation :  {split_params}\")\n\n    # split mesh at params\n    logger.info('Splitting mesh at split params')\n    current_cut_index = 1\n\n    for i, param_first_estimation in enumerate(split_params):\n        logger.info(f'cut_index : {current_cut_index}, param_first_estimation : {param_first_estimation:.6f}')\n\n        # --- (1) More exact estimation of intersecting weight. Recompute gradient evaluation.\n        # Find exact saddle point and the weight that intersects it.\n\n        assign_interpolation_distance_to_mesh_vertices(self.mesh, weight=param_first_estimation,\n                                                       target_LOW=self.target_LOW, target_HIGH=self.target_HIGH)\n        # Late import to avoid circular dependency\n        from compas_slicer.pre_processing.gradient_evaluation import GradientEvaluation\n\n        g_evaluation = GradientEvaluation(self.mesh, self.DATA_PATH)\n        g_evaluation.find_critical_points()\n        saddles_ds_tupples = [(vkey, abs(g_evaluation.mesh.vertex_attribute(vkey, 'scalar_field'))) for vkey in\n                              g_evaluation.saddles]\n        saddles_ds_tupples = sorted(saddles_ds_tupples, key=lambda saddle_tupple: saddle_tupple[1])\n        vkey = saddles_ds_tupples[0][0]\n        t = self.identify_positions_to_split([vkey])[0]\n        logger.info(f'vkey_exact : {vkey} , t_exact : {t:.6f}')\n\n        # --- (2) find zero-crossing points\n        assign_interpolation_distance_to_mesh_vertices(self.mesh, t, self.target_LOW, self.target_HIGH)\n        # Late import to avoid circular dependency\n        from compas_slicer.slicers.slice_utilities import ScalarFieldContours\n\n        zero_contours = ScalarFieldContours(self.mesh)\n        zero_contours.compute()\n        keys_of_clusters_to_keep = merge_clusters_saddle_point(zero_contours, saddle_vkeys=[vkey])\n\n        # --- (3) Cleaning up zero-crossing neighborhoods\n        cleanup_unrelated_isocontour_neighborhoods(zero_contours, keys_of_clusters_to_keep)\n\n        if zero_contours:  # if there are remaining zero-crossing neighborhoods\n            zero_contours = smoothen_cut(zero_contours, self.mesh, saddle_vkeys=[vkey], iterations=15,\n                                         strength=0.2)  # smoothen the cut close to the saddle point.\n\n            # save to json intermediary results\n            zero_contours.save_point_clusters_as_polylines_to_json(self.OUTPUT_PATH,\n                                                                   f'point_clusters_polylines_{int(i)}.json')\n\n            #  --- (4) Create cut\n            logger.info(\"Creating cut on mesh\")\n            self.cut_indices.append(current_cut_index)\n            self.split_intersected_faces(zero_contours, current_cut_index)\n            current_cut_index += 1\n\n            #  --- (5) Weld mesh and restore attributes\n            logger.info('Cleaning up the mesh. Welding and restoring attributes')\n            v_attributes_dict = save_vertex_attributes(self.mesh)\n            self.mesh = weld_mesh(self.mesh, self.OUTPUT_PATH)\n            restore_mesh_attributes(self.mesh, v_attributes_dict)\n\n            #  --- (6) Update targets\n            if i &lt; len(split_params) - 1:  # does not need to happen at the end\n                logger.info('Updating targets, recomputing geodesic distances')\n                self.update_targets()\n\n        self.mesh.to_obj(str(Path(self.OUTPUT_PATH) / 'most_recent_cut_mesh.obj'))\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.MeshSplitter.update_targets","title":"update_targets","text":"<pre><code>update_targets()\n</code></pre> <p>Update targets with the new mesh that was created during the split process. Note: This only works if the target vertices have not been touched. If all has gone well, targets can only have minima and maxima, so they should remain intact after the split</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/region_split.py</code> <pre><code>def update_targets(self):\n    \"\"\"\n    Update targets with the new mesh that was created during the split process.\n    Note: This only works if the target vertices have not been touched. If all has gone well, targets can only have\n    minima and maxima, so they should remain intact after the split\n    \"\"\"\n    self.target_LOW.assign_new_mesh(self.mesh)\n    self.target_LOW.find_targets_connected_components()\n    self.target_LOW.compute_geodesic_distances()\n    if self.target_HIGH:\n        self.target_HIGH.assign_new_mesh(self.mesh)\n        self.target_HIGH.find_targets_connected_components()\n        self.target_HIGH.compute_geodesic_distances()\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.MeshSplitter.split_intersected_faces","title":"split_intersected_faces","text":"<pre><code>split_intersected_faces(zero_contours, cut_index)\n</code></pre> <p>Create cuts on intersected faces</p> <p>Parameters:</p> Name Type Description Default <code>zero_contours</code> required <code>cut_index</code> required Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/region_split.py</code> <pre><code>def split_intersected_faces(self, zero_contours, cut_index):\n    \"\"\"\n    Create cuts on intersected faces\n\n    Parameters\n    ----------\n    zero_contours: :class: 'compas_slicer.pre_processing.ScalarFieldContours'\n    cut_index: int, the vertex attribute value data['cut'] of the current cut\n    \"\"\"\n    for key in zero_contours.sorted_point_clusters:  # cluster_pair\n        edges = zero_contours.sorted_edge_clusters[key]\n        pts = zero_contours.sorted_point_clusters[key]\n\n        # add first vertex\n        p = pts[0]\n        v0 = self.mesh.add_vertex(x=p[0], y=p[1], z=p[2], attr_dict={'cut': 1})\n\n        for i, edge in enumerate(edges):\n            next_edge = edges[(i + 1) % len(edges)]\n            p = pts[(i + 1) % len(pts)]\n\n            faces_current_edge = self.mesh.edge_faces(u=edge[0], v=edge[1])\n            faces_next_edge = self.mesh.edge_faces(u=next_edge[0], v=next_edge[1])\n\n            fkey_common = list(set(faces_current_edge).intersection(faces_next_edge))[0]\n            vkey_common = list(set(edge).intersection(next_edge))[0]\n            v_other_a = list(set(edge).difference([vkey_common]))[0]\n            v_other_b = list(set(next_edge).difference([vkey_common]))[0]\n\n            v_new = self.mesh.add_vertex(x=p[0], y=p[1], z=p[2], attr_dict={'cut': cut_index})\n\n            # remove and add faces\n            if fkey_common in list(self.mesh.faces()):\n                self.mesh.delete_face(fkey_common)\n                self.mesh.add_face([vkey_common, v_new, v0])\n                self.mesh.add_face([v_new, v_other_a, v0])\n                self.mesh.add_face([v_other_b, v_other_a, v_new])\n            else:\n                logger.warning('Did not need to modify faces.')\n            v0 = v_new\n\n    self.mesh.cull_vertices()  # remove all unused vertices\n    try:\n        self.mesh.unify_cycles()\n    except AssertionError:\n        logger.warning('Could NOT unify cycles')\n    if not self.mesh.is_valid():\n        logger.warning('Attention! Mesh is NOT valid!')\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.MeshSplitter.identify_positions_to_split","title":"identify_positions_to_split","text":"<pre><code>identify_positions_to_split(saddles)\n</code></pre> <p>Find the weights that create iso-contours that intersect the saddle points.</p> <p>Parameters:</p> Name Type Description Default <code>saddles</code> required <p>Returns:</p> Type Description <code>list, float, the weights from 0 to 1. One for each saddle point.</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/region_split.py</code> <pre><code>def identify_positions_to_split(self, saddles):\n    \"\"\"\n    Find the weights that create iso-contours that intersect the saddle points.\n\n    Parameters\n    ----------\n    saddles: list, int, the vertex keys of the saddle points\n\n    Returns\n    ----------\n    list, float, the weights from 0 to 1. One for each saddle point.\n    \"\"\"\n    split_params = []\n    for vkey in saddles:\n        param = self.find_weight_intersecting_vkey(vkey, threshold=HIT_THRESHOLD, resolution=T_SEARCH_RESOLUTION)\n        split_params.append(param)\n    return split_params\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.MeshSplitter.find_weight_intersecting_vkey","title":"find_weight_intersecting_vkey","text":"<pre><code>find_weight_intersecting_vkey(vkey, threshold, resolution)\n</code></pre> <p>Find the weights that intersect the vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vkey</code> required <code>threshold</code> required <code>resolution</code> required <p>Returns:</p> Type Description <code>float, the weights from 0 to 1.</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/region_split.py</code> <pre><code>def find_weight_intersecting_vkey(self, vkey, threshold, resolution):\n    \"\"\"\n    Find the weights that intersect the vertex.\n\n    Parameters\n    ----------\n    vkey: list, int, the vertex key to intersect\n    threshold: float, the d value below which we consider we have a hit. Should be a very small value\n    resolution: int, the resolution of search, should be a value more than 10**4\n\n    Returns\n    ----------\n    float, the weights from 0 to 1.\n    \"\"\"\n    weight_list = get_weights_list(n=resolution, start=0.001, end=0.999)\n    # TODO: save next d to avoid re-evaluating\n    for i, weight in enumerate(weight_list[:-1]):\n        current_d = assign_interpolation_distance_to_mesh_vertex(vkey, weight, self.target_LOW, self.target_HIGH)\n        next_d = assign_interpolation_distance_to_mesh_vertex(vkey, weight_list[i + 1], self.target_LOW, self.target_HIGH)\n        if abs(current_d) &lt; abs(next_d) and current_d &lt; threshold:\n            return weight\n    raise ValueError(f'Could NOT find param for saddle vkey {vkey}!')\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.assign_interpolation_distance_to_mesh_vertices","title":"assign_interpolation_distance_to_mesh_vertices","text":"<pre><code>assign_interpolation_distance_to_mesh_vertices(mesh, weight, target_LOW, target_HIGH)\n</code></pre> <p>Fills in the 'get_distance' attribute of every vertex of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> required <code>weight</code> <code>float</code> <p>The weighting of the distances from the lower and the upper target, from 0 to 1.</p> required <code>target_LOW</code> <code>CompoundTarget</code> <p>The lower compound target.</p> required <code>target_HIGH</code> <code>CompoundTarget | None</code> <p>The upper compound target.</p> required Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/assign_vertex_distance.py</code> <pre><code>def assign_interpolation_distance_to_mesh_vertices(\n    mesh: Mesh, weight: float, target_LOW: CompoundTarget, target_HIGH: CompoundTarget | None\n) -&gt; None:\n    \"\"\"\n    Fills in the 'get_distance' attribute of every vertex of the mesh.\n\n    Parameters\n    ----------\n    mesh: :class: 'compas.datastructures.Mesh'\n    weight: float,\n        The weighting of the distances from the lower and the upper target, from 0 to 1.\n    target_LOW: :class: 'compas_slicer.pre_processing.CompoundTarget'\n        The lower compound target.\n    target_HIGH:  :class: 'compas_slicer.pre_processing.CompoundTarget'\n        The upper compound target.\n    \"\"\"\n    # Vectorized computation for all vertices at once\n    distances = _compute_all_distances_vectorized(weight, target_LOW, target_HIGH)\n    for vkey, d in zip(mesh.vertices(), distances):\n        mesh.vertex[vkey]['scalar_field'] = float(d)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.assign_interpolation_distance_to_mesh_vertex","title":"assign_interpolation_distance_to_mesh_vertex","text":"<pre><code>assign_interpolation_distance_to_mesh_vertex(vkey, weight, target_LOW, target_HIGH)\n</code></pre> <p>Fills in the 'get_distance' attribute for a single vertex with vkey.</p> <p>Parameters:</p> Name Type Description Default <code>vkey</code> <code>int</code> <p>The vertex key.</p> required <code>weight</code> <code>float</code> <p>The weighting of the distances from the lower and the upper target, from 0 to 1.</p> required <code>target_LOW</code> <code>CompoundTarget</code> <p>The lower compound target.</p> required <code>target_HIGH</code> <code>CompoundTarget | None</code> <p>The upper compound target.</p> required Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/assign_vertex_distance.py</code> <pre><code>def assign_interpolation_distance_to_mesh_vertex(\n    vkey: int, weight: float, target_LOW: CompoundTarget, target_HIGH: CompoundTarget | None\n) -&gt; float:\n    \"\"\"\n    Fills in the 'get_distance' attribute for a single vertex with vkey.\n\n    Parameters\n    ----------\n    vkey: int\n        The vertex key.\n    weight: float,\n        The weighting of the distances from the lower and the upper target, from 0 to 1.\n    target_LOW: :class: 'compas_slicer.pre_processing.CompoundTarget'\n        The lower compound target.\n    target_HIGH:  :class: 'compas_slicer.pre_processing.CompoundTarget'\n        The upper compound target.\n    \"\"\"\n    if target_LOW and target_HIGH:  # then interpolate targets\n        d = get_weighted_distance(vkey, weight, target_LOW, target_HIGH)\n    elif target_LOW:  # then offset target\n        offset = weight * target_LOW.get_max_dist()\n        d = target_LOW.get_distance(vkey) - offset\n    else:\n        raise ValueError('You need to provide at least one target')\n    return d\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.blend_union_list","title":"blend_union_list","text":"<pre><code>blend_union_list(values, r)\n</code></pre> <p>Returns a smooth union of all the elements in the list, with blend radius blend_radius.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def blend_union_list(values: NDArray[np.floating] | list[float], r: float) -&gt; float:\n    \"\"\" Returns a smooth union of all the elements in the list, with blend radius blend_radius. \"\"\"\n    d_result: float = 9999999.0  # very big number\n    for d in values:\n        d_result = blend_union(d_result, float(d), r)\n    return d_result\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.stairs_union_list","title":"stairs_union_list","text":"<pre><code>stairs_union_list(values, r, n)\n</code></pre> <p>Returns a stairs union of all the elements in the list, with blend radius r and number of peaks n-1.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def stairs_union_list(values: NDArray[np.floating] | list[float], r: float, n: int) -&gt; float:\n    \"\"\" Returns a stairs union of all the elements in the list, with blend radius r and number of peaks n-1.\"\"\"\n    d_result: float = 9999999.0  # very big number\n    for _i, d in enumerate(values):\n        d_result = stairs_union(d_result, float(d), r, n)\n    return d_result\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.get_heat_geodesic_distances","title":"get_heat_geodesic_distances","text":"<pre><code>get_heat_geodesic_distances(mesh, vertices_start)\n</code></pre> <p>Calculate geodesic distances using CGAL heat method.</p> <p>Uses compas_cgal's HeatGeodesicSolver which provides CGAL's Heat_method_3 implementation with intrinsic Delaunay triangulation.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>A compas mesh (must be triangulated).</p> required <code>vertices_start</code> <code>list[int]</code> <p>Source vertex indices.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Minimum distance from any source to each vertex.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/geodesics.py</code> <pre><code>def get_heat_geodesic_distances(\n    mesh: Mesh, vertices_start: list[int]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Calculate geodesic distances using CGAL heat method.\n\n    Uses compas_cgal's HeatGeodesicSolver which provides CGAL's Heat_method_3\n    implementation with intrinsic Delaunay triangulation.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        A compas mesh (must be triangulated).\n    vertices_start : list[int]\n        Source vertex indices.\n\n    Returns\n    -------\n    NDArray\n        Minimum distance from any source to each vertex.\n    \"\"\"\n    from compas_cgal.geodesics import HeatGeodesicSolver\n\n    # Check if we have a cached solver for this mesh\n    mesh_hash = hash((len(list(mesh.vertices())), len(list(mesh.faces()))))\n    if mesh_hash not in _cgal_solver_cache:\n        _cgal_solver_cache.clear()  # Clear old solvers\n        _cgal_solver_cache[mesh_hash] = HeatGeodesicSolver(mesh)\n\n    solver = _cgal_solver_cache[mesh_hash]\n\n    # Compute distances for each source and take minimum\n    all_distances = []\n    for source in vertices_start:\n        distances = solver.solve([source])\n        all_distances.append(distances)\n\n    return np.min(np.array(all_distances), axis=0)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.get_custom_HEAT_geodesic_distances","title":"get_custom_HEAT_geodesic_distances","text":"<pre><code>get_custom_HEAT_geodesic_distances(mesh, vi_sources, OUTPUT_PATH, v_equalize=None)\n</code></pre> <p>Calculate geodesic distances using the custom heat method.</p> <p>This is a pure Python implementation of the heat method (Crane et al., 2013). For production use, prefer CGAL's implementation via get_heat_geodesic_distances() which uses intrinsic Delaunay triangulation for better accuracy.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>A compas mesh (must be triangulated).</p> required <code>vi_sources</code> <code>list[int]</code> <p>Source vertex indices.</p> required <code>OUTPUT_PATH</code> <code>str</code> <p>Path to save intermediate results.</p> required <code>v_equalize</code> <code>list[int] | None</code> <p>Vertices to equalize (for saddle point handling).</p> <code>None</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Geodesic distance from sources to each vertex.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/geodesics.py</code> <pre><code>def get_custom_HEAT_geodesic_distances(\n    mesh: Mesh,\n    vi_sources: list[int],\n    OUTPUT_PATH: str,\n    v_equalize: list[int] | None = None,\n) -&gt; NDArray[np.floating]:\n    \"\"\"Calculate geodesic distances using the custom heat method.\n\n    This is a pure Python implementation of the heat method (Crane et al., 2013).\n    For production use, prefer CGAL's implementation via get_heat_geodesic_distances()\n    which uses intrinsic Delaunay triangulation for better accuracy.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        A compas mesh (must be triangulated).\n    vi_sources : list[int]\n        Source vertex indices.\n    OUTPUT_PATH : str\n        Path to save intermediate results.\n    v_equalize : list[int] | None\n        Vertices to equalize (for saddle point handling).\n\n    Returns\n    -------\n    NDArray\n        Geodesic distance from sources to each vertex.\n    \"\"\"\n    geodesics_solver = GeodesicsSolver(mesh, OUTPUT_PATH)\n    u = geodesics_solver.diffuse_heat(vi_sources, v_equalize)\n    geodesic_dist = geodesics_solver.get_geodesic_distances(u, vi_sources, v_equalize)\n    return geodesic_dist\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.get_vertex_gradient_from_face_gradient","title":"get_vertex_gradient_from_face_gradient","text":"<pre><code>get_vertex_gradient_from_face_gradient(mesh, face_gradient)\n</code></pre> <p>Finds vertex gradient given an already calculated per face gradient.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> required <code>face_gradient</code> <code>NDArray[floating]</code> required <p>Returns:</p> Type Description <code>np.array (dimensions : #V x 3) one gradient vector per vertex.</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/gradient.py</code> <pre><code>def get_vertex_gradient_from_face_gradient(\n    mesh: Mesh, face_gradient: NDArray[np.floating]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Finds vertex gradient given an already calculated per face gradient.\n\n    Parameters\n    ----------\n    mesh: :class: 'compas.datastructures.Mesh'\n    face_gradient: np.array with one vec3 per face of the mesh. (dimensions : #F x 3)\n\n    Returns\n    ----------\n    np.array (dimensions : #V x 3) one gradient vector per vertex.\n    \"\"\"\n    logger.info('Computing per vertex gradient')\n    V, F = _mesh_to_arrays(mesh)\n    face_areas = np.array([mesh.face_area(f) for f in mesh.faces()], dtype=np.float64)\n    return _vertex_gradient_vectorized(V, F, face_gradient, face_areas)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.get_edge_gradient_from_vertex_gradient","title":"get_edge_gradient_from_vertex_gradient","text":"<pre><code>get_edge_gradient_from_vertex_gradient(mesh, vertex_gradient)\n</code></pre> <p>Finds edge gradient given an already calculated per vertex gradient.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> required <code>vertex_gradient</code> <code>NDArray[floating]</code> required <p>Returns:</p> Type Description <code>np.array (dimensions : #E x 3) one gradient vector per edge.</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/gradient.py</code> <pre><code>def get_edge_gradient_from_vertex_gradient(\n    mesh: Mesh, vertex_gradient: NDArray[np.floating]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Finds edge gradient given an already calculated per vertex gradient.\n\n    Parameters\n    ----------\n    mesh: :class: 'compas.datastructures.Mesh'\n    vertex_gradient: np.array with one vec3 per vertex of the mesh. (dimensions : #V x 3)\n\n    Returns\n    ----------\n    np.array (dimensions : #E x 3) one gradient vector per edge.\n    \"\"\"\n    edges = np.array(list(mesh.edges()), dtype=np.intp)\n    return _edge_gradient_vectorized(edges, vertex_gradient)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.get_face_gradient_from_scalar_field","title":"get_face_gradient_from_scalar_field","text":"<pre><code>get_face_gradient_from_scalar_field(mesh, u)\n</code></pre> <p>Finds face gradient from scalar field u. Scalar field u is given per vertex.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> required <code>u</code> <code>NDArray[floating]</code> required <p>Returns:</p> Type Description <code>np.array (dimensions : #F x 3) one gradient vector per face.</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/gradient.py</code> <pre><code>def get_face_gradient_from_scalar_field(\n    mesh: Mesh, u: NDArray[np.floating]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Finds face gradient from scalar field u.\n    Scalar field u is given per vertex.\n\n    Parameters\n    ----------\n    mesh: :class: 'compas.datastructures.Mesh'\n    u: list, float. (dimensions : #VN x 1)\n\n    Returns\n    ----------\n    np.array (dimensions : #F x 3) one gradient vector per face.\n    \"\"\"\n    logger.info('Computing per face gradient')\n    V, F = _mesh_to_arrays(mesh)\n    scalar_field = np.asarray(u, dtype=np.float64)\n    face_normals = np.array([mesh.face_normal(f) for f in mesh.faces()], dtype=np.float64)\n    face_areas = np.array([mesh.face_area(f) for f in mesh.faces()], dtype=np.float64)\n    return _face_gradient_vectorized(V, F, scalar_field, face_normals, face_areas)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.get_per_vertex_divergence","title":"get_per_vertex_divergence","text":"<pre><code>get_per_vertex_divergence(mesh, X, cotans)\n</code></pre> <p>Computes the divergence of the gradient X for the mesh, using cotangent weights.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> required <code>X</code> <code>NDArray[floating]</code> required <code>cotans</code> <code>NDArray[floating]</code> required <p>Returns:</p> Type Description <code>np.array (dimensions : #V x 1) one float (divergence value) per vertex.</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/gradient.py</code> <pre><code>def get_per_vertex_divergence(\n    mesh: Mesh, X: NDArray[np.floating], cotans: NDArray[np.floating]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Computes the divergence of the gradient X for the mesh, using cotangent weights.\n\n    Parameters\n    ----------\n    mesh: :class: 'compas.datastructures.Mesh'\n    X: np.array, (dimensions: #F x 3), per face gradient\n    cotans:  np.array, (dimensions: #F x 3), 1/2*cotangents corresponding angles\n\n    Returns\n    ----------\n    np.array (dimensions : #V x 1) one float (divergence value) per vertex.\n    \"\"\"\n    V, F = _mesh_to_arrays(mesh)\n    cotans = cotans.reshape(-1, 3)\n    return _divergence_vectorized(V, F, X, cotans)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.normalize_gradient","title":"normalize_gradient","text":"<pre><code>normalize_gradient(X)\n</code></pre> <p>Returns normalized gradient X.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/gradient.py</code> <pre><code>def normalize_gradient(X: NDArray[np.floating]) -&gt; NDArray[np.floating]:\n    \"\"\" Returns normalized gradient X. \"\"\"\n    norm = np.linalg.norm(X, axis=1)[..., np.newaxis]\n    return X / norm  # normalize\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.get_scalar_field_from_gradient","title":"get_scalar_field_from_gradient","text":"<pre><code>get_scalar_field_from_gradient(mesh, X, C, cotans)\n</code></pre> <p>Find scalar field u that best explains gradient X. Laplacian(u) = Divergence(X). This defines a scalar field up to translation, then we subtract the min to make sure it starts from 0.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> required <code>X</code> <code>NDArray[floating]</code> required <code>C</code> <code>csr_matrix</code> <p>sparse matrix (dimensions: #V x #V), cotmatrix, each row i corresponding to v(i, :)</p> required <code>cotans</code> <code>NDArray[floating]</code> required <p>Returns:</p> Type Description <code>np.array (dimensions : #V x 1) one scalar value per vertex.</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/gradient.py</code> <pre><code>def get_scalar_field_from_gradient(\n    mesh: Mesh,\n    X: NDArray[np.floating],\n    C: scipy.sparse.csr_matrix,\n    cotans: NDArray[np.floating],\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Find scalar field u that best explains gradient X.\n    Laplacian(u) = Divergence(X).\n    This defines a scalar field up to translation, then we subtract the min to make sure it starts from 0.\n\n    Parameters\n    ----------\n    mesh: :class: 'compas.datastructures.Mesh'\n    X: np.array, (dimensions: #F x 3), per face gradient\n    C: 'scipy.sparse.csr_matrix',\n        sparse matrix (dimensions: #V x #V), cotmatrix, each row i corresponding to v(i, :)\n    cotans: np.array, (dimensions: #F x 3), 1/2*cotangents corresponding angles\n\n    Returns\n    ----------\n    np.array (dimensions : #V x 1) one scalar value per vertex.\n    \"\"\"\n    div_X = get_per_vertex_divergence(mesh, X, cotans)\n    u = scipy.sparse.linalg.spsolve(C, div_X)\n    logger.info(f'Solved \u0394(u) = div(X). Linear system error |\u0394(u) - div(X)| = {np.linalg.norm(C * u - div_X):.6e}')\n    u = u - np.amin(u)  # make start value equal 0\n    u = 2*u\n    return u\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.create_mesh_boundary_attributes","title":"create_mesh_boundary_attributes","text":"<pre><code>create_mesh_boundary_attributes(mesh, low_boundary_vs, high_boundary_vs)\n</code></pre> <p>Creates a default vertex attribute data['boundary']=0. Then it gives the value 1 to the vertices that belong to the lower boundary, and the value 2 to the vertices that belong to the higher boundary.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/mesh_attributes_handling.py</code> <pre><code>def create_mesh_boundary_attributes(\n    mesh: Mesh, low_boundary_vs: list[int], high_boundary_vs: list[int]\n) -&gt; None:\n    \"\"\"\n    Creates a default vertex attribute data['boundary']=0. Then it gives the value 1 to the vertices that belong\n    to the lower boundary, and the value 2 to the vertices that belong to the higher boundary.\n    \"\"\"\n    mesh.update_default_vertex_attributes({'boundary': 0})\n    for vkey, data in mesh.vertices(data=True):\n        if vkey in low_boundary_vs:\n            data['boundary'] = 1\n        elif vkey in high_boundary_vs:\n            data['boundary'] = 2\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.get_existing_cut_indices","title":"get_existing_cut_indices","text":"<pre><code>get_existing_cut_indices(mesh)\n</code></pre> <p>Returns:</p> Type Description <code>    list, int.</code> <p>The cut indices (data['cut']&gt;0) that exist on the mesh vertices.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/mesh_attributes_handling.py</code> <pre><code>def get_existing_cut_indices(mesh: Mesh) -&gt; list[int]:\n    \"\"\"\n    Returns\n    ----------\n        list, int.\n        The cut indices (data['cut']&gt;0) that exist on the mesh vertices.\n    \"\"\"\n    cut_indices = []\n    for _vkey, data in mesh.vertices(data=True):\n        if data['cut'] &gt; 0 and data['cut'] not in cut_indices:\n            cut_indices.append(data['cut'])\n    cut_indices = sorted(cut_indices)\n    return cut_indices\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.get_existing_boundary_indices","title":"get_existing_boundary_indices","text":"<pre><code>get_existing_boundary_indices(mesh)\n</code></pre> <p>Returns:</p> Type Description <code>    list, int.</code> <p>The boundary indices (data['boundary']&gt;0) that exist on the mesh vertices.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/mesh_attributes_handling.py</code> <pre><code>def get_existing_boundary_indices(mesh: Mesh) -&gt; list[int]:\n    \"\"\"\n    Returns\n    ----------\n        list, int.\n        The boundary indices (data['boundary']&gt;0) that exist on the mesh vertices.\n    \"\"\"\n    indices = []\n    for _vkey, data in mesh.vertices(data=True):\n        if data['boundary'] &gt; 0 and data['boundary'] not in indices:\n            indices.append(data['boundary'])\n    boundary_indices = sorted(indices)\n    return boundary_indices\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.get_vertices_that_belong_to_cuts","title":"get_vertices_that_belong_to_cuts","text":"<pre><code>get_vertices_that_belong_to_cuts(mesh, cut_indices)\n</code></pre> <p>Returns:</p> Type Description <code>    dict, key: int, the index of each cut</code> <p>value: dict, the points that belong to this cut (point_list_to_dict format)</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/mesh_attributes_handling.py</code> <pre><code>def get_vertices_that_belong_to_cuts(\n    mesh: Mesh, cut_indices: list[int]\n) -&gt; dict[int, dict[int, list[float]]]:\n    \"\"\"\n    Returns\n    ----------\n        dict, key: int, the index of each cut\n              value: dict, the points that belong to this cut (point_list_to_dict format)\n    \"\"\"\n    cuts_dict: dict[int, list[list[float]]] = {i: [] for i in cut_indices}\n\n    for vkey, data in mesh.vertices(data=True):\n        if data['cut'] &gt; 0:\n            cut_index = data['cut']\n            cuts_dict[cut_index].append(mesh.vertex_coordinates(vkey))\n\n    result: dict[int, dict[int, list[float]]] = {}\n    for cut_index in cuts_dict:\n        result[cut_index] = utils.point_list_to_dict(cuts_dict[cut_index])\n\n    return result\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.save_vertex_attributes","title":"save_vertex_attributes","text":"<pre><code>save_vertex_attributes(mesh)\n</code></pre> <p>Saves the boundary and cut attributes that are on the mesh on a dictionary.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/mesh_attributes_handling.py</code> <pre><code>def save_vertex_attributes(mesh: Mesh) -&gt; dict[str, Any]:\n    \"\"\"\n    Saves the boundary and cut attributes that are on the mesh on a dictionary.\n    \"\"\"\n    v_attributes_dict: dict[str, Any] = {'boundary_1': [], 'boundary_2': [], 'cut': {}}\n\n    cut_indices = []\n    for _vkey, data in mesh.vertices(data=True):\n        cut_index = data['cut']\n        if cut_index not in cut_indices:\n            cut_indices.append(cut_index)\n    cut_indices = sorted(cut_indices)\n\n    for cut_index in cut_indices:\n        v_attributes_dict['cut'][cut_index] = []\n\n    for vkey, data in mesh.vertices(data=True):\n        if data['boundary'] == 1:\n            v_coords = mesh.vertex_coordinates(vkey)\n            pt = Point(x=v_coords[0], y=v_coords[1], z=v_coords[2])\n            v_attributes_dict['boundary_1'].append(pt)\n        elif data['boundary'] == 2:\n            v_coords = mesh.vertex_coordinates(vkey)\n            pt = Point(x=v_coords[0], y=v_coords[1], z=v_coords[2])\n            v_attributes_dict['boundary_2'].append(pt)\n        if data['cut'] &gt; 0:\n            cut_index = data['cut']\n            v_coords = mesh.vertex_coordinates(vkey)\n            pt = Point(x=v_coords[0], y=v_coords[1], z=v_coords[2])\n            v_attributes_dict['cut'][cut_index].append(pt)\n    return v_attributes_dict\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.restore_mesh_attributes","title":"restore_mesh_attributes","text":"<pre><code>restore_mesh_attributes(mesh, v_attributes_dict)\n</code></pre> <p>Restores the cut and boundary attributes on the mesh vertices from the dictionary of the previously saved attributes</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/mesh_attributes_handling.py</code> <pre><code>def restore_mesh_attributes(mesh: Mesh, v_attributes_dict: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Restores the cut and boundary attributes on the mesh vertices from the dictionary of the previously saved attributes\n    \"\"\"\n    mesh.update_default_vertex_attributes({'boundary': 0})\n    mesh.update_default_vertex_attributes({'cut': 0})\n\n    D_THRESHOLD = 0.01\n\n    # Build KDTree once for all queries\n    vkeys = list(mesh.vertices())\n    welded_mesh_vertices = np.array([mesh.vertex_coordinates(vkey) for vkey in vkeys], dtype=np.float64)\n    indices_to_vkeys = dict(enumerate(vkeys))\n    tree = cKDTree(welded_mesh_vertices)\n\n    def _restore_attribute_batch(pts_list, attr_name, attr_value):\n        \"\"\"Restore attribute for a batch of points using KDTree.\"\"\"\n        if not pts_list:\n            return\n        query_pts = np.array([[p.x, p.y, p.z] if hasattr(p, 'x') else p for p in pts_list], dtype=np.float64)\n        distances, indices = tree.query(query_pts)\n        for dist, idx in zip(distances, indices):\n            if dist ** 2 &lt; D_THRESHOLD:\n                c_vkey = indices_to_vkeys[idx]\n                mesh.vertex_attribute(c_vkey, attr_name, value=attr_value)\n\n    _restore_attribute_batch(v_attributes_dict['boundary_1'], 'boundary', 1)\n    _restore_attribute_batch(v_attributes_dict['boundary_2'], 'boundary', 2)\n\n    for cut_index in v_attributes_dict['cut']:\n        _restore_attribute_batch(v_attributes_dict['cut'][cut_index], 'cut', int(cut_index))\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.replace_mesh_vertex_attribute","title":"replace_mesh_vertex_attribute","text":"<pre><code>replace_mesh_vertex_attribute(mesh, old_attr, old_val, new_attr, new_val)\n</code></pre> <p>Replaces one vertex attribute with a new one. For all the vertices where data[old_attr]=old_val, then the old_val is replaced with 0, and data[new_attr]=new_val.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/mesh_attributes_handling.py</code> <pre><code>def replace_mesh_vertex_attribute(\n    mesh: Mesh, old_attr: str, old_val: int, new_attr: str, new_val: int\n) -&gt; None:\n    \"\"\"\n    Replaces one vertex attribute with a new one. For all the vertices where data[old_attr]=old_val, then the\n    old_val is replaced with 0, and data[new_attr]=new_val.\n    \"\"\"\n    for vkey, data in mesh.vertices(data=True):\n        if data[old_attr] == old_val:\n            mesh.vertex_attribute(vkey, old_attr, 0)\n            mesh.vertex_attribute(vkey, new_attr, new_val)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.assign_vertex_distance","title":"assign_vertex_distance","text":""},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.assign_vertex_distance.assign_interpolation_distance_to_mesh_vertices","title":"assign_interpolation_distance_to_mesh_vertices","text":"<pre><code>assign_interpolation_distance_to_mesh_vertices(mesh, weight, target_LOW, target_HIGH)\n</code></pre> <p>Fills in the 'get_distance' attribute of every vertex of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> required <code>weight</code> <code>float</code> <p>The weighting of the distances from the lower and the upper target, from 0 to 1.</p> required <code>target_LOW</code> <code>CompoundTarget</code> <p>The lower compound target.</p> required <code>target_HIGH</code> <code>CompoundTarget | None</code> <p>The upper compound target.</p> required Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/assign_vertex_distance.py</code> <pre><code>def assign_interpolation_distance_to_mesh_vertices(\n    mesh: Mesh, weight: float, target_LOW: CompoundTarget, target_HIGH: CompoundTarget | None\n) -&gt; None:\n    \"\"\"\n    Fills in the 'get_distance' attribute of every vertex of the mesh.\n\n    Parameters\n    ----------\n    mesh: :class: 'compas.datastructures.Mesh'\n    weight: float,\n        The weighting of the distances from the lower and the upper target, from 0 to 1.\n    target_LOW: :class: 'compas_slicer.pre_processing.CompoundTarget'\n        The lower compound target.\n    target_HIGH:  :class: 'compas_slicer.pre_processing.CompoundTarget'\n        The upper compound target.\n    \"\"\"\n    # Vectorized computation for all vertices at once\n    distances = _compute_all_distances_vectorized(weight, target_LOW, target_HIGH)\n    for vkey, d in zip(mesh.vertices(), distances):\n        mesh.vertex[vkey]['scalar_field'] = float(d)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.assign_vertex_distance.assign_interpolation_distance_to_mesh_vertex","title":"assign_interpolation_distance_to_mesh_vertex","text":"<pre><code>assign_interpolation_distance_to_mesh_vertex(vkey, weight, target_LOW, target_HIGH)\n</code></pre> <p>Fills in the 'get_distance' attribute for a single vertex with vkey.</p> <p>Parameters:</p> Name Type Description Default <code>vkey</code> <code>int</code> <p>The vertex key.</p> required <code>weight</code> <code>float</code> <p>The weighting of the distances from the lower and the upper target, from 0 to 1.</p> required <code>target_LOW</code> <code>CompoundTarget</code> <p>The lower compound target.</p> required <code>target_HIGH</code> <code>CompoundTarget | None</code> <p>The upper compound target.</p> required Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/assign_vertex_distance.py</code> <pre><code>def assign_interpolation_distance_to_mesh_vertex(\n    vkey: int, weight: float, target_LOW: CompoundTarget, target_HIGH: CompoundTarget | None\n) -&gt; float:\n    \"\"\"\n    Fills in the 'get_distance' attribute for a single vertex with vkey.\n\n    Parameters\n    ----------\n    vkey: int\n        The vertex key.\n    weight: float,\n        The weighting of the distances from the lower and the upper target, from 0 to 1.\n    target_LOW: :class: 'compas_slicer.pre_processing.CompoundTarget'\n        The lower compound target.\n    target_HIGH:  :class: 'compas_slicer.pre_processing.CompoundTarget'\n        The upper compound target.\n    \"\"\"\n    if target_LOW and target_HIGH:  # then interpolate targets\n        d = get_weighted_distance(vkey, weight, target_LOW, target_HIGH)\n    elif target_LOW:  # then offset target\n        offset = weight * target_LOW.get_max_dist()\n        d = target_LOW.get_distance(vkey) - offset\n    else:\n        raise ValueError('You need to provide at least one target')\n    return d\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.assign_vertex_distance.get_weighted_distance","title":"get_weighted_distance","text":"<pre><code>get_weighted_distance(vkey, weight, target_LOW, target_HIGH)\n</code></pre> <p>Computes the weighted get_distance for a single vertex with vkey.</p> <p>Parameters:</p> Name Type Description Default <code>vkey</code> <code>int</code> <p>The vertex key.</p> required <code>weight</code> <code>float</code> <p>The weighting of the distances from the lower and the upper target, from 0 to 1.</p> required <code>target_LOW</code> <code>CompoundTarget</code> <p>The lower compound target.</p> required <code>target_HIGH</code> <code>CompoundTarget</code> <p>The upper compound target.</p> required Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/assign_vertex_distance.py</code> <pre><code>def get_weighted_distance(\n    vkey: int, weight: float, target_LOW: CompoundTarget, target_HIGH: CompoundTarget\n) -&gt; float:\n    \"\"\"\n    Computes the weighted get_distance for a single vertex with vkey.\n\n    Parameters\n    ----------\n    vkey: int\n        The vertex key.\n    weight: float,\n        The weighting of the distances from the lower and the upper target, from 0 to 1.\n    target_LOW: :class: 'compas_slicer.pre_processing.CompoundTarget'\n        The lower compound target.\n    target_HIGH:  :class: 'compas_slicer.pre_processing.CompoundTarget'\n        The upper compound target.\n    \"\"\"\n    # --- calculation with uneven weights\n    if target_HIGH.has_uneven_weights:\n        d_low = target_LOW.get_distance(vkey)  # float\n        ds_high = target_HIGH.get_all_distances_for_vkey(vkey)  # list of floats (# number_of_boundaries)\n\n        if target_HIGH.number_of_boundaries &gt; 1:\n            weights_remapped = [remap_unbound(weight, 0, weight_max, 0, 1)\n                                for weight_max in target_HIGH.weight_max_per_cluster]\n            weights = weights_remapped\n        else:\n            weights = [weight]\n\n        distances = [(weight - 1) * d_low + weight * d_high for d_high, weight in zip(ds_high, weights)]\n\n        # return the distance based on the union method of the high target\n        if target_HIGH.union_method == 'min':\n            # --- simple union\n            return np.min(distances)\n        elif target_HIGH.union_method == 'smooth':\n            # --- blend (smooth) union\n            return blend_union_list(values=distances, r=target_HIGH.union_params[0])\n        elif target_HIGH.union_method == 'chamfer':\n            # --- blend (smooth) union\n            return chamfer_union_list(values=distances, r=target_HIGH.union_params[0])\n        elif target_HIGH.union_method == 'stairs':\n            # --- stairs union\n            return stairs_union_list(values=distances, r=target_HIGH.union_params[0], n=target_HIGH.union_params[1])\n\n    # --- simple calculation (without uneven weights)\n    else:\n        d_low = target_LOW.get_distance(vkey)\n        d_high = target_HIGH.get_distance(vkey)\n        return (d_low * (1 - weight)) - (d_high * weight)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target","title":"compound_target","text":""},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.CompoundTarget","title":"CompoundTarget","text":"<pre><code>CompoundTarget(mesh, v_attr, value, DATA_PATH, union_method='min', union_params=None, geodesics_method='heat_cgal', anisotropic_scaling=False)\n</code></pre> <p>Represents a desired user-provided target. It acts as a key-frame that controls the print paths orientations. After the curved slicing , the print paths will be aligned to the compound target close to its area. The vertices that belong to the target are marked with their vertex attributes; they have data['v_attr'] = value.</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>:class:`compas.datastructures.Mesh`</code> <code>v_attr</code> <code>str</code> <p>The key of the attribute dict to be checked.</p> <code>value</code> <code>int</code> <p>The value of the attribute dict with key=v_attr. If in a vertex data[v_attr]==value then the vertex is part of this target.</p> <code>DATA_PATH</code> <code>str</code> <code>has_blend_union</code> <code>bool</code> <code>blend_radius</code> <code>float</code> <code>geodesics_method</code> <code>str</code> <p>'heat_cgal'  CGAL heat geodesic distances (recommended) 'heat'       custom heat geodesic distances</p> <code>anisotropic_scaling</code> <code>bool</code> <p>This is not yet implemented</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def __init__(\n    self,\n    mesh: Mesh,\n    v_attr: str,\n    value: int,\n    DATA_PATH: str,\n    union_method: UnionMethod = 'min',\n    union_params: list[Any] | None = None,\n    geodesics_method: GeodesicsMethod = 'heat_cgal',\n    anisotropic_scaling: bool = False,\n) -&gt; None:\n\n    if union_params is None:\n        union_params = []\n    logger.info(f'Creating target with attribute : {v_attr}={value}')\n    logger.info(f'union_method: {union_method}, union_params: {union_params}')\n    self.mesh = mesh\n    self.v_attr = v_attr\n    self.value = value\n    self.DATA_PATH = DATA_PATH\n    self.OUTPUT_PATH = utils.get_output_directory(DATA_PATH)\n\n    self.union_method = union_method\n    self.union_params = union_params\n\n    self.geodesics_method = geodesics_method\n    self.anisotropic_scaling = anisotropic_scaling  # Anisotropic scaling not yet implemented\n\n    self.offset = 0\n    self.VN = len(list(self.mesh.vertices()))\n\n    # filled in by function 'self.find_targets_connected_components()'\n    self.all_target_vkeys: list[int] = []  # flattened list with all vi_starts\n    self.clustered_vkeys: list[list[int]] = []  # nested list with all vi_starts\n    self.number_of_boundaries: int = 0\n\n    self.weight_max_per_cluster: list[float] = []\n\n    # geodesic distances\n    # filled in by function 'self.update_distances_lists()'\n    self._distances_lists: list[list[float]] = []  # Shape: number_of_boundaries x number_of_vertices\n    self._distances_lists_flipped: list[list[float]] = []  # Shape: number_of_vertices x number_of_boundaries\n    self._np_distances_lists_flipped: NDArray[np.floating] = np.array([])\n    self._max_dist: float | None = None  # maximum distance from target on any mesh vertex\n\n    # compute\n    self.find_targets_connected_components()\n    self.compute_geodesic_distances()\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.CompoundTarget.has_uneven_weights","title":"has_uneven_weights  <code>property</code>","text":"<pre><code>has_uneven_weights\n</code></pre> <p>Returns True if the target has uneven_weights calculated, False otherwise.</p>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.CompoundTarget.find_targets_connected_components","title":"find_targets_connected_components","text":"<pre><code>find_targets_connected_components()\n</code></pre> <p>Clusters all the vertices that belong to the target into neighborhoods using a graph. Each target can have an arbitrary number of neighborhoods/clusters. Fills in the attributes: self.all_target_vkeys, self.clustered_vkeys, self.number_of_boundaries</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def find_targets_connected_components(self) -&gt; None:\n    \"\"\"\n    Clusters all the vertices that belong to the target into neighborhoods using a graph.\n    Each target can have an arbitrary number of neighborhoods/clusters.\n    Fills in the attributes: self.all_target_vkeys, self.clustered_vkeys, self.number_of_boundaries\n    \"\"\"\n    self.all_target_vkeys = [vkey for vkey, data in self.mesh.vertices(data=True) if\n                             data[self.v_attr] == self.value]\n    if len(self.all_target_vkeys) == 0:\n        raise ValueError(\n            f\"No vertices in mesh with attribute '{self.v_attr}'={self.value}. \"\n            \"Check your target creation.\"\n        )\n    G = _create_graph_from_mesh_vkeys(self.mesh, self.all_target_vkeys)\n    if len(list(G.nodes())) != len(self.all_target_vkeys):\n        raise RuntimeError(\"Graph node count doesn't match target vertex count.\")\n    self.number_of_boundaries = len(list(nx.connected_components(G)))\n\n    for _i, cp in enumerate(nx.connected_components(G)):\n        self.clustered_vkeys.append(list(cp))\n    logger.info(\n        f\"Compound target with 'boundary'={self.value}. Number of connected_components : \"\n        f\"{len(list(nx.connected_components(G)))}\"\n    )\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.CompoundTarget.compute_geodesic_distances","title":"compute_geodesic_distances","text":"<pre><code>compute_geodesic_distances()\n</code></pre> <p>Computes the geodesic distances from each of the target's neighborhoods  to all the mesh vertices. Fills in the distances attributes.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def compute_geodesic_distances(self) -&gt; None:\n    \"\"\"\n    Computes the geodesic distances from each of the target's neighborhoods  to all the mesh vertices.\n    Fills in the distances attributes.\n    \"\"\"\n    if self.geodesics_method == 'exact_igl':\n        distances_lists = [get_igl_EXACT_geodesic_distances(self.mesh, vstarts) for vstarts in\n                           self.clustered_vkeys]\n    elif self.geodesics_method == 'heat_igl':\n        distances_lists = [get_igl_HEAT_geodesic_distances(self.mesh, vstarts) for vstarts in\n                           self.clustered_vkeys]\n    elif self.geodesics_method == 'heat_cgal':\n        distances_lists = [get_cgal_HEAT_geodesic_distances(self.mesh, vstarts) for vstarts in\n                           self.clustered_vkeys]\n    elif self.geodesics_method == 'heat':\n        distances_lists = [get_custom_HEAT_geodesic_distances(self.mesh, vstarts, str(self.OUTPUT_PATH)) for vstarts in\n                           self.clustered_vkeys]\n    else:\n        raise ValueError('Unknown geodesics method : ' + self.geodesics_method)\n\n    distances_lists = [list(dl) for dl in distances_lists]  # number_of_boundaries x #V\n    self.update_distances_lists(distances_lists)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.CompoundTarget.update_distances_lists","title":"update_distances_lists","text":"<pre><code>update_distances_lists(distances_lists)\n</code></pre> <p>Fills in the distances attributes.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def update_distances_lists(self, distances_lists: list[list[float]]) -&gt; None:\n    \"\"\"\n    Fills in the distances attributes.\n    \"\"\"\n    self._distances_lists = distances_lists\n    self._distances_lists_flipped = []  # empty\n    for i in range(self.VN):\n        current_values = [self._distances_lists[list_index][i] for list_index in range(self.number_of_boundaries)]\n        self._distances_lists_flipped.append(current_values)\n    self._np_distances_lists_flipped = np.array(self._distances_lists_flipped)\n    self._max_dist = np.max(self._np_distances_lists_flipped)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.CompoundTarget.compute_uneven_boundaries_weight_max","title":"compute_uneven_boundaries_weight_max","text":"<pre><code>compute_uneven_boundaries_weight_max(other_target)\n</code></pre> <p>If the target has multiple neighborhoods/clusters of vertices, then it computes their maximum distance from the other_target. Based on that it calculates their weight_max for the interpolation process</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def compute_uneven_boundaries_weight_max(self, other_target: CompoundTarget) -&gt; None:\n    \"\"\"\n    If the target has multiple neighborhoods/clusters of vertices, then it computes their maximum distance from\n    the other_target. Based on that it calculates their weight_max for the interpolation process\n    \"\"\"\n    if self.number_of_boundaries &gt; 1:\n        ds_avg_HIGH = self.get_boundaries_rel_dist_from_other_target(other_target)\n        max_param = max(ds_avg_HIGH)\n        for i, d in enumerate(ds_avg_HIGH):  # offset all distances except the maximum one\n            if abs(d - max_param) &gt; 0.01:  # if it isn't the max value\n                ds_avg_HIGH[i] = d + self.offset\n\n        self.weight_max_per_cluster = [d / max_param for d in ds_avg_HIGH]\n        logger.info(f'weight_max_per_cluster: {self.weight_max_per_cluster}')\n    else:\n        logger.info(\"Did not compute_norm_of_gradient uneven boundaries, target consists of single component\")\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.CompoundTarget.get_boundaries_rel_dist_from_other_target","title":"get_boundaries_rel_dist_from_other_target","text":"<pre><code>get_boundaries_rel_dist_from_other_target(other_target, avg_type='median')\n</code></pre> <p>Returns a list, one relative distance value per connected boundary neighborhood. That is the average of the distances of the vertices of that boundary neighborhood from the other_target.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def get_boundaries_rel_dist_from_other_target(\n    self, other_target: CompoundTarget, avg_type: Literal['mean', 'median'] = 'median'\n) -&gt; list[float]:\n    \"\"\"\n    Returns a list, one relative distance value per connected boundary neighborhood.\n    That is the average of the distances of the vertices of that boundary neighborhood from the other_target.\n    \"\"\"\n    distances = []\n    for vi_starts in self.clustered_vkeys:\n        ds = [other_target.get_distance(vi) for vi in vi_starts]\n        if avg_type == 'mean':\n            distances.append(statistics.mean(ds))\n        else:  # 'median'\n            distances.append(statistics.median(ds))\n    return distances\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.CompoundTarget.get_avg_distances_from_other_target","title":"get_avg_distances_from_other_target","text":"<pre><code>get_avg_distances_from_other_target(other_target)\n</code></pre> <p>Returns the minimum and maximum distance of the vertices of this target from the other_target</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def get_avg_distances_from_other_target(self, other_target: CompoundTarget) -&gt; float:\n    \"\"\"\n    Returns the minimum and maximum distance of the vertices of this target from the other_target\n    \"\"\"\n    extreme_distances = []\n    for v_index in other_target.all_target_vkeys:\n        extreme_distances.append(self.get_all_distances()[v_index])\n    return float(np.average(np.array(extreme_distances)))\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.CompoundTarget.get_all_clusters_distances_dict","title":"get_all_clusters_distances_dict","text":"<pre><code>get_all_clusters_distances_dict()\n</code></pre> <p>Returns dict. keys: index of connected target neighborhood, value: list, distances (one per vertex).</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def get_all_clusters_distances_dict(self) -&gt; dict[int, list[float]]:\n    \"\"\" Returns dict. keys: index of connected target neighborhood, value: list, distances (one per vertex). \"\"\"\n    return {i: self._distances_lists[i] for i in range(self.number_of_boundaries)}\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.CompoundTarget.get_max_dist","title":"get_max_dist","text":"<pre><code>get_max_dist()\n</code></pre> <p>Returns the maximum distance that the target has on a mesh vertex.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def get_max_dist(self) -&gt; float | None:\n    \"\"\" Returns the maximum distance that the target has on a mesh vertex. \"\"\"\n    return self._max_dist\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.CompoundTarget.get_all_distances","title":"get_all_distances","text":"<pre><code>get_all_distances()\n</code></pre> <p>Return distances for all vertices as 1D array, applying union method.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def get_all_distances(self) -&gt; np.ndarray:\n    \"\"\"Return distances for all vertices as 1D array, applying union method.\"\"\"\n    if self.union_method == 'min':\n        return np.min(self._np_distances_lists_flipped, axis=1)\n    elif self.union_method == 'smooth':\n        return np.array([\n            blend_union_list(row.tolist(), self.union_params[0])\n            for row in self._np_distances_lists_flipped\n        ])\n    elif self.union_method == 'chamfer':\n        return np.array([\n            chamfer_union_list(row.tolist(), self.union_params[0])\n            for row in self._np_distances_lists_flipped\n        ])\n    elif self.union_method == 'stairs':\n        return np.array([\n            stairs_union_list(row.tolist(), self.union_params[0], self.union_params[1])\n            for row in self._np_distances_lists_flipped\n        ])\n    else:\n        raise ValueError(f\"Unknown union method: {self.union_method}\")\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.CompoundTarget.get_all_distances_array","title":"get_all_distances_array","text":"<pre><code>get_all_distances_array()\n</code></pre> <p>Return raw distances as (n_boundaries, n_vertices) array.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def get_all_distances_array(self) -&gt; np.ndarray:\n    \"\"\"Return raw distances as (n_boundaries, n_vertices) array.\"\"\"\n    return np.array(self._distances_lists)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.CompoundTarget.get_all_distances_for_vkey","title":"get_all_distances_for_vkey","text":"<pre><code>get_all_distances_for_vkey(i)\n</code></pre> <p>Returns distances from each cluster separately for vertex i. Smooth union doesn't play here any role.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def get_all_distances_for_vkey(self, i: int) -&gt; list[float]:\n    \"\"\" Returns distances from each cluster separately for vertex i. Smooth union doesn't play here any role. \"\"\"\n    return [self._distances_lists[list_index][i] for list_index in range(self.number_of_boundaries)]\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.CompoundTarget.get_distance","title":"get_distance","text":"<pre><code>get_distance(i)\n</code></pre> <p>Return get_distance for vertex with vkey i.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def get_distance(self, i: int) -&gt; float:\n    \"\"\" Return get_distance for vertex with vkey i. \"\"\"\n    if self.union_method == 'min':\n        # --- simple union\n        return float(np.min(self._np_distances_lists_flipped[i]))\n    elif self.union_method == 'smooth':\n        # --- blend (smooth) union\n        return blend_union_list(values=self._np_distances_lists_flipped[i], r=self.union_params[0])\n    elif self.union_method == 'chamfer':\n        # --- blend (smooth) union\n        return chamfer_union_list(values=self._np_distances_lists_flipped[i], r=self.union_params[0])\n    elif self.union_method == 'stairs':\n        # --- stairs union\n        return stairs_union_list(values=self._np_distances_lists_flipped[i], r=self.union_params[0],\n                                 n=self.union_params[1])\n    else:\n        raise ValueError(\"Unknown Union method : \", self.union_method)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.CompoundTarget.laplacian_smoothing","title":"laplacian_smoothing","text":"<pre><code>laplacian_smoothing(iterations, strength)\n</code></pre> <p>Smooth the distances on the mesh, using iterative laplacian smoothing.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def laplacian_smoothing(self, iterations: int, strength: float) -&gt; None:\n    \"\"\" Smooth the distances on the mesh, using iterative laplacian smoothing. \"\"\"\n    L = utils.get_mesh_cotmatrix_igl(self.mesh, fix_boundaries=True)\n    new_distances_lists = []\n\n    logger.info('Laplacian smoothing of all distances')\n    for _i, a in enumerate(self._distances_lists):\n        a = np.array(a)  # a: numpy array containing the attribute to be smoothed\n        for _ in range(iterations):  # iterative smoothing\n            a_prime = a + strength * L * a\n            a = a_prime\n        new_distances_lists.append(list(a))\n    self.update_distances_lists(new_distances_lists)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.CompoundTarget.save_distances","title":"save_distances","text":"<pre><code>save_distances(name)\n</code></pre> <p>Save distances to json. Saves one list with distance values (one per vertex).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def save_distances(self, name: str) -&gt; None:\n    \"\"\"\n    Save distances to json.\n    Saves one list with distance values (one per vertex).\n\n    Parameters\n    ----------\n    name: str, name of json to be saved\n    \"\"\"\n    utils.save_to_json(self.get_all_distances().tolist(), self.OUTPUT_PATH, name)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.CompoundTarget.assign_new_mesh","title":"assign_new_mesh","text":"<pre><code>assign_new_mesh(mesh)\n</code></pre> <p>When the base mesh changes, a new mesh needs to be assigned.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def assign_new_mesh(self, mesh: Mesh) -&gt; None:\n    \"\"\" When the base mesh changes, a new mesh needs to be assigned. \"\"\"\n    mesh.to_json(self.OUTPUT_PATH + \"/temp.obj\")\n    mesh = Mesh.from_json(self.OUTPUT_PATH + \"/temp.obj\")\n    self.mesh = mesh\n    self.VN = len(list(self.mesh.vertices()))\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.blend_union_list","title":"blend_union_list","text":"<pre><code>blend_union_list(values, r)\n</code></pre> <p>Returns a smooth union of all the elements in the list, with blend radius blend_radius.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def blend_union_list(values: NDArray[np.floating] | list[float], r: float) -&gt; float:\n    \"\"\" Returns a smooth union of all the elements in the list, with blend radius blend_radius. \"\"\"\n    d_result: float = 9999999.0  # very big number\n    for d in values:\n        d_result = blend_union(d_result, float(d), r)\n    return d_result\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.stairs_union_list","title":"stairs_union_list","text":"<pre><code>stairs_union_list(values, r, n)\n</code></pre> <p>Returns a stairs union of all the elements in the list, with blend radius r and number of peaks n-1.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def stairs_union_list(values: NDArray[np.floating] | list[float], r: float, n: int) -&gt; float:\n    \"\"\" Returns a stairs union of all the elements in the list, with blend radius r and number of peaks n-1.\"\"\"\n    d_result: float = 9999999.0  # very big number\n    for _i, d in enumerate(values):\n        d_result = stairs_union(d_result, float(d), r, n)\n    return d_result\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.blend_union","title":"blend_union","text":"<pre><code>blend_union(da, db, r)\n</code></pre> <p>Returns a smooth union of the two elements da, db with blend radius blend_radius.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def blend_union(da: float, db: float, r: float) -&gt; float:\n    \"\"\" Returns a smooth union of the two elements da, db with blend radius blend_radius. \"\"\"\n    e = max(r - abs(da - db), 0)\n    return min(da, db) - e * e * 0.25 / r\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.chamfer_union","title":"chamfer_union","text":"<pre><code>chamfer_union(a, b, r)\n</code></pre> <p>Returns a chamfer union of the two elements da, db with radius r.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def chamfer_union(a: float, b: float, r: float) -&gt; float:\n    \"\"\" Returns a chamfer union of the two elements da, db with radius r. \"\"\"\n    return min(min(a, b), (a - r + b) * math.sqrt(0.5))\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.compound_target.stairs_union","title":"stairs_union","text":"<pre><code>stairs_union(a, b, r, n)\n</code></pre> <p>Returns a stairs union of the two elements da, db with radius r.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/compound_target.py</code> <pre><code>def stairs_union(a: float, b: float, r: float, n: int) -&gt; float:\n    \"\"\" Returns a stairs union of the two elements da, db with radius r. \"\"\"\n    s = r / n\n    u = b - r\n    return min(min(a, b), 0.5 * (u + a + abs((u - a + s) % (2 * s) - s)))\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.geodesics","title":"geodesics","text":""},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.geodesics.GeodesicsCache","title":"GeodesicsCache","text":"<pre><code>GeodesicsCache()\n</code></pre> <p>Cache for geodesic distances to avoid redundant computations.</p> <p>Note: This class is kept for backwards compatibility but now uses CGAL. The CGAL solver has its own internal caching via _cgal_solver_cache.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/geodesics.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._cache: dict[tuple[int, str], NDArray[np.floating]] = {}\n    self._mesh_hash: int | None = None\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.geodesics.GeodesicsCache.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Clear the cache.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/geodesics.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear the cache.\"\"\"\n    self._cache.clear()\n    self._mesh_hash = None\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.geodesics.GeodesicsCache.get_distances","title":"get_distances","text":"<pre><code>get_distances(mesh, sources, method='heat')\n</code></pre> <p>Get geodesic distances from sources, using cache when possible.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh to compute distances on.</p> required <code>sources</code> <code>list[int]</code> <p>Source vertex indices.</p> required <code>method</code> <code>str</code> <p>Geodesic method (ignored, always uses CGAL heat method).</p> <code>'heat'</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Minimum distance from any source to each vertex.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/geodesics.py</code> <pre><code>def get_distances(\n    self, mesh: Mesh, sources: list[int], method: str = 'heat'\n) -&gt; NDArray[np.floating]:\n    \"\"\"Get geodesic distances from sources, using cache when possible.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh to compute distances on.\n    sources : list[int]\n        Source vertex indices.\n    method : str\n        Geodesic method (ignored, always uses CGAL heat method).\n\n    Returns\n    -------\n    NDArray\n        Minimum distance from any source to each vertex.\n    \"\"\"\n    return get_heat_geodesic_distances(mesh, sources)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.geodesics.GeodesicsSolver","title":"GeodesicsSolver","text":"<pre><code>GeodesicsSolver(mesh, OUTPUT_PATH)\n</code></pre> <p>Computes custom geodesic distances. Starts from implementation of the method presented in the paper 'Geodesics in Heat' (Crane, 2013)</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>:class: compas.datastructures.Mesh</code> <code>OUTPUT_PATH</code> <code>str</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/geodesics.py</code> <pre><code>def __init__(self, mesh: Mesh, OUTPUT_PATH: str) -&gt; None:\n    logger.info('GeodesicsSolver')\n    self.mesh = mesh\n    self.OUTPUT_PATH = OUTPUT_PATH\n\n    self.use_forwards_euler = True\n\n    # Compute matrices using NumPy implementations\n    self.cotans = utils.get_mesh_cotans(mesh)\n    self.L = utils.get_mesh_cotmatrix(mesh, fix_boundaries=False)\n    self.M = utils.get_mesh_massmatrix(mesh)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.geodesics.GeodesicsSolver.diffuse_heat","title":"diffuse_heat","text":"<pre><code>diffuse_heat(vi_sources, v_equalize=None)\n</code></pre> <p>Heat diffusion using iterative backward Euler.</p> <p>This is a custom Python implementation of the heat method. For production use, prefer CGAL's heat method (geodesics_method='heat_cgal') which uses intrinsic Delaunay triangulation for better accuracy.</p> <p>Parameters:</p> Name Type Description Default <code>vi_sources</code> <code>list[int]</code> <p>The vertex indices of the heat sources.</p> required <code>v_equalize</code> <code>list[int] | None</code> <p>Vertex indices whose values should be equalized (for handling saddle points).</p> <code>None</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Heat distribution u, with sources at 0 and increasing away from them.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/geodesics.py</code> <pre><code>def diffuse_heat(\n    self,\n    vi_sources: list[int],\n    v_equalize: list[int] | None = None,\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Heat diffusion using iterative backward Euler.\n\n    This is a custom Python implementation of the heat method. For production use,\n    prefer CGAL's heat method (geodesics_method='heat_cgal') which uses intrinsic\n    Delaunay triangulation for better accuracy.\n\n    Parameters\n    ----------\n    vi_sources : list[int]\n        The vertex indices of the heat sources.\n    v_equalize : list[int] | None\n        Vertex indices whose values should be equalized (for handling saddle points).\n\n    Returns\n    -------\n    NDArray\n        Heat distribution u, with sources at 0 and increasing away from them.\n    \"\"\"\n    if not v_equalize:\n        v_equalize = []\n\n    # First assign starting values (0 everywhere, 1 on the sources)\n    u0 = np.zeros(len(list(self.mesh.vertices())))\n    u0[vi_sources] = 1.0\n    u = u0\n\n    # Pre-factor the matrix ONCE outside the loop (major speedup)\n    # Using backward Euler: (M - \u03b4L)u' = M\u00b7u\n    S = self.M - DELTA * self.L\n    solver = scipy.sparse.linalg.factorized(S)\n\n    for _i in range(HEAT_DIFFUSION_ITERATIONS):\n        b = self.M * u\n        u_prime = solver(b)\n\n        if len(v_equalize) &gt; 0:\n            u_prime[v_equalize] = np.min(u_prime[v_equalize])\n\n        u = u_prime\n        u[vi_sources] = 1.0  # enforce Dirichlet boundary: sources remain fixed\n\n    # reverse values (to make sources at 0, increasing outward)\n    u = ([np.max(u)] * len(u)) - u\n\n    utils.save_to_json([float(value) for value in u], self.OUTPUT_PATH, 'diffused_heat.json')\n    return u\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.geodesics.GeodesicsSolver.get_geodesic_distances","title":"get_geodesic_distances","text":"<pre><code>get_geodesic_distances(u, vi_sources, v_equalize=None)\n</code></pre> <p>Finds geodesic distances from heat distribution u. I</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>NDArray[floating]</code> required <code>vi_sources</code> <code>list[int]</code> required <code>v_equalize</code> <code>list[int] | None</code> <code>None</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/geodesics.py</code> <pre><code>def get_geodesic_distances(\n    self, u: NDArray[np.floating], vi_sources: list[int], v_equalize: list[int] | None = None\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Finds geodesic distances from heat distribution u. I\n\n    Parameters\n    ----------\n    u: np.array, dimensions: V x 1 (one scalar value per vertex)\n    vi_sources: list, int, the vertex indices of the sources\n    v_equalize: list, int, the vertex indices whose value should be equalized\n    \"\"\"\n    X = get_face_gradient_from_scalar_field(self.mesh, u)\n    X = normalize_gradient(X)\n    geodesic_dist = get_scalar_field_from_gradient(self.mesh, X, self.L, self.cotans)\n    if math.isnan(geodesic_dist[0]):\n        raise RuntimeError(\"get_scalar_field_from_gradient returned NaN - check mesh quality.\")\n    geodesic_dist[vi_sources] = 0  # coerce boundary vertices to be on 0 (fixes small boundary imprecision)\n    return geodesic_dist\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.geodesics.get_heat_geodesic_distances","title":"get_heat_geodesic_distances","text":"<pre><code>get_heat_geodesic_distances(mesh, vertices_start)\n</code></pre> <p>Calculate geodesic distances using CGAL heat method.</p> <p>Uses compas_cgal's HeatGeodesicSolver which provides CGAL's Heat_method_3 implementation with intrinsic Delaunay triangulation.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>A compas mesh (must be triangulated).</p> required <code>vertices_start</code> <code>list[int]</code> <p>Source vertex indices.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Minimum distance from any source to each vertex.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/geodesics.py</code> <pre><code>def get_heat_geodesic_distances(\n    mesh: Mesh, vertices_start: list[int]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Calculate geodesic distances using CGAL heat method.\n\n    Uses compas_cgal's HeatGeodesicSolver which provides CGAL's Heat_method_3\n    implementation with intrinsic Delaunay triangulation.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        A compas mesh (must be triangulated).\n    vertices_start : list[int]\n        Source vertex indices.\n\n    Returns\n    -------\n    NDArray\n        Minimum distance from any source to each vertex.\n    \"\"\"\n    from compas_cgal.geodesics import HeatGeodesicSolver\n\n    # Check if we have a cached solver for this mesh\n    mesh_hash = hash((len(list(mesh.vertices())), len(list(mesh.faces()))))\n    if mesh_hash not in _cgal_solver_cache:\n        _cgal_solver_cache.clear()  # Clear old solvers\n        _cgal_solver_cache[mesh_hash] = HeatGeodesicSolver(mesh)\n\n    solver = _cgal_solver_cache[mesh_hash]\n\n    # Compute distances for each source and take minimum\n    all_distances = []\n    for source in vertices_start:\n        distances = solver.solve([source])\n        all_distances.append(distances)\n\n    return np.min(np.array(all_distances), axis=0)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.geodesics.get_custom_HEAT_geodesic_distances","title":"get_custom_HEAT_geodesic_distances","text":"<pre><code>get_custom_HEAT_geodesic_distances(mesh, vi_sources, OUTPUT_PATH, v_equalize=None)\n</code></pre> <p>Calculate geodesic distances using the custom heat method.</p> <p>This is a pure Python implementation of the heat method (Crane et al., 2013). For production use, prefer CGAL's implementation via get_heat_geodesic_distances() which uses intrinsic Delaunay triangulation for better accuracy.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>A compas mesh (must be triangulated).</p> required <code>vi_sources</code> <code>list[int]</code> <p>Source vertex indices.</p> required <code>OUTPUT_PATH</code> <code>str</code> <p>Path to save intermediate results.</p> required <code>v_equalize</code> <code>list[int] | None</code> <p>Vertices to equalize (for saddle point handling).</p> <code>None</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Geodesic distance from sources to each vertex.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/geodesics.py</code> <pre><code>def get_custom_HEAT_geodesic_distances(\n    mesh: Mesh,\n    vi_sources: list[int],\n    OUTPUT_PATH: str,\n    v_equalize: list[int] | None = None,\n) -&gt; NDArray[np.floating]:\n    \"\"\"Calculate geodesic distances using the custom heat method.\n\n    This is a pure Python implementation of the heat method (Crane et al., 2013).\n    For production use, prefer CGAL's implementation via get_heat_geodesic_distances()\n    which uses intrinsic Delaunay triangulation for better accuracy.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        A compas mesh (must be triangulated).\n    vi_sources : list[int]\n        Source vertex indices.\n    OUTPUT_PATH : str\n        Path to save intermediate results.\n    v_equalize : list[int] | None\n        Vertices to equalize (for saddle point handling).\n\n    Returns\n    -------\n    NDArray\n        Geodesic distance from sources to each vertex.\n    \"\"\"\n    geodesics_solver = GeodesicsSolver(mesh, OUTPUT_PATH)\n    u = geodesics_solver.diffuse_heat(vi_sources, v_equalize)\n    geodesic_dist = geodesics_solver.get_geodesic_distances(u, vi_sources, v_equalize)\n    return geodesic_dist\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.gradient","title":"gradient","text":""},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.gradient.get_vertex_gradient_from_face_gradient","title":"get_vertex_gradient_from_face_gradient","text":"<pre><code>get_vertex_gradient_from_face_gradient(mesh, face_gradient)\n</code></pre> <p>Finds vertex gradient given an already calculated per face gradient.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> required <code>face_gradient</code> <code>NDArray[floating]</code> required <p>Returns:</p> Type Description <code>np.array (dimensions : #V x 3) one gradient vector per vertex.</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/gradient.py</code> <pre><code>def get_vertex_gradient_from_face_gradient(\n    mesh: Mesh, face_gradient: NDArray[np.floating]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Finds vertex gradient given an already calculated per face gradient.\n\n    Parameters\n    ----------\n    mesh: :class: 'compas.datastructures.Mesh'\n    face_gradient: np.array with one vec3 per face of the mesh. (dimensions : #F x 3)\n\n    Returns\n    ----------\n    np.array (dimensions : #V x 3) one gradient vector per vertex.\n    \"\"\"\n    logger.info('Computing per vertex gradient')\n    V, F = _mesh_to_arrays(mesh)\n    face_areas = np.array([mesh.face_area(f) for f in mesh.faces()], dtype=np.float64)\n    return _vertex_gradient_vectorized(V, F, face_gradient, face_areas)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.gradient.get_edge_gradient_from_vertex_gradient","title":"get_edge_gradient_from_vertex_gradient","text":"<pre><code>get_edge_gradient_from_vertex_gradient(mesh, vertex_gradient)\n</code></pre> <p>Finds edge gradient given an already calculated per vertex gradient.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> required <code>vertex_gradient</code> <code>NDArray[floating]</code> required <p>Returns:</p> Type Description <code>np.array (dimensions : #E x 3) one gradient vector per edge.</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/gradient.py</code> <pre><code>def get_edge_gradient_from_vertex_gradient(\n    mesh: Mesh, vertex_gradient: NDArray[np.floating]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Finds edge gradient given an already calculated per vertex gradient.\n\n    Parameters\n    ----------\n    mesh: :class: 'compas.datastructures.Mesh'\n    vertex_gradient: np.array with one vec3 per vertex of the mesh. (dimensions : #V x 3)\n\n    Returns\n    ----------\n    np.array (dimensions : #E x 3) one gradient vector per edge.\n    \"\"\"\n    edges = np.array(list(mesh.edges()), dtype=np.intp)\n    return _edge_gradient_vectorized(edges, vertex_gradient)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.gradient.get_face_gradient_from_scalar_field","title":"get_face_gradient_from_scalar_field","text":"<pre><code>get_face_gradient_from_scalar_field(mesh, u)\n</code></pre> <p>Finds face gradient from scalar field u. Scalar field u is given per vertex.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> required <code>u</code> <code>NDArray[floating]</code> required <p>Returns:</p> Type Description <code>np.array (dimensions : #F x 3) one gradient vector per face.</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/gradient.py</code> <pre><code>def get_face_gradient_from_scalar_field(\n    mesh: Mesh, u: NDArray[np.floating]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Finds face gradient from scalar field u.\n    Scalar field u is given per vertex.\n\n    Parameters\n    ----------\n    mesh: :class: 'compas.datastructures.Mesh'\n    u: list, float. (dimensions : #VN x 1)\n\n    Returns\n    ----------\n    np.array (dimensions : #F x 3) one gradient vector per face.\n    \"\"\"\n    logger.info('Computing per face gradient')\n    V, F = _mesh_to_arrays(mesh)\n    scalar_field = np.asarray(u, dtype=np.float64)\n    face_normals = np.array([mesh.face_normal(f) for f in mesh.faces()], dtype=np.float64)\n    face_areas = np.array([mesh.face_area(f) for f in mesh.faces()], dtype=np.float64)\n    return _face_gradient_vectorized(V, F, scalar_field, face_normals, face_areas)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.gradient.get_face_edge_vectors","title":"get_face_edge_vectors","text":"<pre><code>get_face_edge_vectors(mesh, fkey)\n</code></pre> <p>Returns the edge vectors of the face with fkey.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/gradient.py</code> <pre><code>def get_face_edge_vectors(\n    mesh: Mesh, fkey: int\n) -&gt; tuple[NDArray[np.floating], NDArray[np.floating], NDArray[np.floating]]:\n    \"\"\" Returns the edge vectors of the face with fkey. \"\"\"\n    e0, e1, e2 = mesh.face_halfedges(fkey)\n    edge_0 = np.array(mesh.vertex_coordinates(e0[0])) - np.array(mesh.vertex_coordinates(e0[1]))\n    edge_1 = np.array(mesh.vertex_coordinates(e1[0])) - np.array(mesh.vertex_coordinates(e1[1]))\n    edge_2 = np.array(mesh.vertex_coordinates(e2[0])) - np.array(mesh.vertex_coordinates(e2[1]))\n    return edge_0, edge_1, edge_2\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.gradient.get_per_vertex_divergence","title":"get_per_vertex_divergence","text":"<pre><code>get_per_vertex_divergence(mesh, X, cotans)\n</code></pre> <p>Computes the divergence of the gradient X for the mesh, using cotangent weights.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> required <code>X</code> <code>NDArray[floating]</code> required <code>cotans</code> <code>NDArray[floating]</code> required <p>Returns:</p> Type Description <code>np.array (dimensions : #V x 1) one float (divergence value) per vertex.</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/gradient.py</code> <pre><code>def get_per_vertex_divergence(\n    mesh: Mesh, X: NDArray[np.floating], cotans: NDArray[np.floating]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Computes the divergence of the gradient X for the mesh, using cotangent weights.\n\n    Parameters\n    ----------\n    mesh: :class: 'compas.datastructures.Mesh'\n    X: np.array, (dimensions: #F x 3), per face gradient\n    cotans:  np.array, (dimensions: #F x 3), 1/2*cotangents corresponding angles\n\n    Returns\n    ----------\n    np.array (dimensions : #V x 1) one float (divergence value) per vertex.\n    \"\"\"\n    V, F = _mesh_to_arrays(mesh)\n    cotans = cotans.reshape(-1, 3)\n    return _divergence_vectorized(V, F, X, cotans)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.gradient.normalize_gradient","title":"normalize_gradient","text":"<pre><code>normalize_gradient(X)\n</code></pre> <p>Returns normalized gradient X.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/gradient.py</code> <pre><code>def normalize_gradient(X: NDArray[np.floating]) -&gt; NDArray[np.floating]:\n    \"\"\" Returns normalized gradient X. \"\"\"\n    norm = np.linalg.norm(X, axis=1)[..., np.newaxis]\n    return X / norm  # normalize\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.gradient.get_scalar_field_from_gradient","title":"get_scalar_field_from_gradient","text":"<pre><code>get_scalar_field_from_gradient(mesh, X, C, cotans)\n</code></pre> <p>Find scalar field u that best explains gradient X. Laplacian(u) = Divergence(X). This defines a scalar field up to translation, then we subtract the min to make sure it starts from 0.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> required <code>X</code> <code>NDArray[floating]</code> required <code>C</code> <code>csr_matrix</code> <p>sparse matrix (dimensions: #V x #V), cotmatrix, each row i corresponding to v(i, :)</p> required <code>cotans</code> <code>NDArray[floating]</code> required <p>Returns:</p> Type Description <code>np.array (dimensions : #V x 1) one scalar value per vertex.</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/gradient.py</code> <pre><code>def get_scalar_field_from_gradient(\n    mesh: Mesh,\n    X: NDArray[np.floating],\n    C: scipy.sparse.csr_matrix,\n    cotans: NDArray[np.floating],\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Find scalar field u that best explains gradient X.\n    Laplacian(u) = Divergence(X).\n    This defines a scalar field up to translation, then we subtract the min to make sure it starts from 0.\n\n    Parameters\n    ----------\n    mesh: :class: 'compas.datastructures.Mesh'\n    X: np.array, (dimensions: #F x 3), per face gradient\n    C: 'scipy.sparse.csr_matrix',\n        sparse matrix (dimensions: #V x #V), cotmatrix, each row i corresponding to v(i, :)\n    cotans: np.array, (dimensions: #F x 3), 1/2*cotangents corresponding angles\n\n    Returns\n    ----------\n    np.array (dimensions : #V x 1) one scalar value per vertex.\n    \"\"\"\n    div_X = get_per_vertex_divergence(mesh, X, cotans)\n    u = scipy.sparse.linalg.spsolve(C, div_X)\n    logger.info(f'Solved \u0394(u) = div(X). Linear system error |\u0394(u) - div(X)| = {np.linalg.norm(C * u - div_X):.6e}')\n    u = u - np.amin(u)  # make start value equal 0\n    u = 2*u\n    return u\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.mesh_attributes_handling","title":"mesh_attributes_handling","text":""},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.mesh_attributes_handling.create_mesh_boundary_attributes","title":"create_mesh_boundary_attributes","text":"<pre><code>create_mesh_boundary_attributes(mesh, low_boundary_vs, high_boundary_vs)\n</code></pre> <p>Creates a default vertex attribute data['boundary']=0. Then it gives the value 1 to the vertices that belong to the lower boundary, and the value 2 to the vertices that belong to the higher boundary.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/mesh_attributes_handling.py</code> <pre><code>def create_mesh_boundary_attributes(\n    mesh: Mesh, low_boundary_vs: list[int], high_boundary_vs: list[int]\n) -&gt; None:\n    \"\"\"\n    Creates a default vertex attribute data['boundary']=0. Then it gives the value 1 to the vertices that belong\n    to the lower boundary, and the value 2 to the vertices that belong to the higher boundary.\n    \"\"\"\n    mesh.update_default_vertex_attributes({'boundary': 0})\n    for vkey, data in mesh.vertices(data=True):\n        if vkey in low_boundary_vs:\n            data['boundary'] = 1\n        elif vkey in high_boundary_vs:\n            data['boundary'] = 2\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.mesh_attributes_handling.get_existing_cut_indices","title":"get_existing_cut_indices","text":"<pre><code>get_existing_cut_indices(mesh)\n</code></pre> <p>Returns:</p> Type Description <code>    list, int.</code> <p>The cut indices (data['cut']&gt;0) that exist on the mesh vertices.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/mesh_attributes_handling.py</code> <pre><code>def get_existing_cut_indices(mesh: Mesh) -&gt; list[int]:\n    \"\"\"\n    Returns\n    ----------\n        list, int.\n        The cut indices (data['cut']&gt;0) that exist on the mesh vertices.\n    \"\"\"\n    cut_indices = []\n    for _vkey, data in mesh.vertices(data=True):\n        if data['cut'] &gt; 0 and data['cut'] not in cut_indices:\n            cut_indices.append(data['cut'])\n    cut_indices = sorted(cut_indices)\n    return cut_indices\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.mesh_attributes_handling.get_existing_boundary_indices","title":"get_existing_boundary_indices","text":"<pre><code>get_existing_boundary_indices(mesh)\n</code></pre> <p>Returns:</p> Type Description <code>    list, int.</code> <p>The boundary indices (data['boundary']&gt;0) that exist on the mesh vertices.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/mesh_attributes_handling.py</code> <pre><code>def get_existing_boundary_indices(mesh: Mesh) -&gt; list[int]:\n    \"\"\"\n    Returns\n    ----------\n        list, int.\n        The boundary indices (data['boundary']&gt;0) that exist on the mesh vertices.\n    \"\"\"\n    indices = []\n    for _vkey, data in mesh.vertices(data=True):\n        if data['boundary'] &gt; 0 and data['boundary'] not in indices:\n            indices.append(data['boundary'])\n    boundary_indices = sorted(indices)\n    return boundary_indices\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.mesh_attributes_handling.get_vertices_that_belong_to_cuts","title":"get_vertices_that_belong_to_cuts","text":"<pre><code>get_vertices_that_belong_to_cuts(mesh, cut_indices)\n</code></pre> <p>Returns:</p> Type Description <code>    dict, key: int, the index of each cut</code> <p>value: dict, the points that belong to this cut (point_list_to_dict format)</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/mesh_attributes_handling.py</code> <pre><code>def get_vertices_that_belong_to_cuts(\n    mesh: Mesh, cut_indices: list[int]\n) -&gt; dict[int, dict[int, list[float]]]:\n    \"\"\"\n    Returns\n    ----------\n        dict, key: int, the index of each cut\n              value: dict, the points that belong to this cut (point_list_to_dict format)\n    \"\"\"\n    cuts_dict: dict[int, list[list[float]]] = {i: [] for i in cut_indices}\n\n    for vkey, data in mesh.vertices(data=True):\n        if data['cut'] &gt; 0:\n            cut_index = data['cut']\n            cuts_dict[cut_index].append(mesh.vertex_coordinates(vkey))\n\n    result: dict[int, dict[int, list[float]]] = {}\n    for cut_index in cuts_dict:\n        result[cut_index] = utils.point_list_to_dict(cuts_dict[cut_index])\n\n    return result\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.mesh_attributes_handling.save_vertex_attributes","title":"save_vertex_attributes","text":"<pre><code>save_vertex_attributes(mesh)\n</code></pre> <p>Saves the boundary and cut attributes that are on the mesh on a dictionary.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/mesh_attributes_handling.py</code> <pre><code>def save_vertex_attributes(mesh: Mesh) -&gt; dict[str, Any]:\n    \"\"\"\n    Saves the boundary and cut attributes that are on the mesh on a dictionary.\n    \"\"\"\n    v_attributes_dict: dict[str, Any] = {'boundary_1': [], 'boundary_2': [], 'cut': {}}\n\n    cut_indices = []\n    for _vkey, data in mesh.vertices(data=True):\n        cut_index = data['cut']\n        if cut_index not in cut_indices:\n            cut_indices.append(cut_index)\n    cut_indices = sorted(cut_indices)\n\n    for cut_index in cut_indices:\n        v_attributes_dict['cut'][cut_index] = []\n\n    for vkey, data in mesh.vertices(data=True):\n        if data['boundary'] == 1:\n            v_coords = mesh.vertex_coordinates(vkey)\n            pt = Point(x=v_coords[0], y=v_coords[1], z=v_coords[2])\n            v_attributes_dict['boundary_1'].append(pt)\n        elif data['boundary'] == 2:\n            v_coords = mesh.vertex_coordinates(vkey)\n            pt = Point(x=v_coords[0], y=v_coords[1], z=v_coords[2])\n            v_attributes_dict['boundary_2'].append(pt)\n        if data['cut'] &gt; 0:\n            cut_index = data['cut']\n            v_coords = mesh.vertex_coordinates(vkey)\n            pt = Point(x=v_coords[0], y=v_coords[1], z=v_coords[2])\n            v_attributes_dict['cut'][cut_index].append(pt)\n    return v_attributes_dict\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.mesh_attributes_handling.restore_mesh_attributes","title":"restore_mesh_attributes","text":"<pre><code>restore_mesh_attributes(mesh, v_attributes_dict)\n</code></pre> <p>Restores the cut and boundary attributes on the mesh vertices from the dictionary of the previously saved attributes</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/mesh_attributes_handling.py</code> <pre><code>def restore_mesh_attributes(mesh: Mesh, v_attributes_dict: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Restores the cut and boundary attributes on the mesh vertices from the dictionary of the previously saved attributes\n    \"\"\"\n    mesh.update_default_vertex_attributes({'boundary': 0})\n    mesh.update_default_vertex_attributes({'cut': 0})\n\n    D_THRESHOLD = 0.01\n\n    # Build KDTree once for all queries\n    vkeys = list(mesh.vertices())\n    welded_mesh_vertices = np.array([mesh.vertex_coordinates(vkey) for vkey in vkeys], dtype=np.float64)\n    indices_to_vkeys = dict(enumerate(vkeys))\n    tree = cKDTree(welded_mesh_vertices)\n\n    def _restore_attribute_batch(pts_list, attr_name, attr_value):\n        \"\"\"Restore attribute for a batch of points using KDTree.\"\"\"\n        if not pts_list:\n            return\n        query_pts = np.array([[p.x, p.y, p.z] if hasattr(p, 'x') else p for p in pts_list], dtype=np.float64)\n        distances, indices = tree.query(query_pts)\n        for dist, idx in zip(distances, indices):\n            if dist ** 2 &lt; D_THRESHOLD:\n                c_vkey = indices_to_vkeys[idx]\n                mesh.vertex_attribute(c_vkey, attr_name, value=attr_value)\n\n    _restore_attribute_batch(v_attributes_dict['boundary_1'], 'boundary', 1)\n    _restore_attribute_batch(v_attributes_dict['boundary_2'], 'boundary', 2)\n\n    for cut_index in v_attributes_dict['cut']:\n        _restore_attribute_batch(v_attributes_dict['cut'][cut_index], 'cut', int(cut_index))\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.mesh_attributes_handling.replace_mesh_vertex_attribute","title":"replace_mesh_vertex_attribute","text":"<pre><code>replace_mesh_vertex_attribute(mesh, old_attr, old_val, new_attr, new_val)\n</code></pre> <p>Replaces one vertex attribute with a new one. For all the vertices where data[old_attr]=old_val, then the old_val is replaced with 0, and data[new_attr]=new_val.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/mesh_attributes_handling.py</code> <pre><code>def replace_mesh_vertex_attribute(\n    mesh: Mesh, old_attr: str, old_val: int, new_attr: str, new_val: int\n) -&gt; None:\n    \"\"\"\n    Replaces one vertex attribute with a new one. For all the vertices where data[old_attr]=old_val, then the\n    old_val is replaced with 0, and data[new_attr]=new_val.\n    \"\"\"\n    for vkey, data in mesh.vertices(data=True):\n        if data[old_attr] == old_val:\n            mesh.vertex_attribute(vkey, old_attr, 0)\n            mesh.vertex_attribute(vkey, new_attr, new_val)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.region_split","title":"region_split","text":""},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.region_split.MeshSplitter","title":"MeshSplitter","text":"<pre><code>MeshSplitter(mesh, target_LOW, target_HIGH, DATA_PATH)\n</code></pre> <p>Curved slicing pre-processing step.</p> <p>Takes one continuous mesh with various saddle points and splits it up at every saddle point following the direction of the iso-contour that intersects that saddle point, so that the resulting mesh has no remaining saddle points.</p> <p>The result is a series of split meshes whose vertex attributes have been updated with boundary attributes at the newly created cuts, (i.e. they all have vertex 'boundary' attributes 1,2 on their lower and upper boundaries)</p> <p>For each newly created mesh, a separate slicer needs to be created. Like that, we will always have one slicer per mesh with the correct attributes already assigned. However, it can still happen that a slicer that takes a split mesh outputs more than one vertical_layers_print_data (vertical layers).</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>:class: 'compas.datastructures.Mesh'</code> <code>target_LOW</code> <code>:class: 'compas_slicer.pre_processing.CompoundTarget'</code> <code>target_HIGH</code> <code>:class: 'compas_slicer.pre_processing.CompoundTarget'</code> <code>DATA_PATH</code> <code>str, the path to the data folder</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/region_split.py</code> <pre><code>def __init__(self, mesh, target_LOW, target_HIGH, DATA_PATH):\n    self.mesh = mesh  # compas mesh\n    self.DATA_PATH = DATA_PATH\n    self.OUTPUT_PATH = utils.get_output_directory(DATA_PATH)\n    self.target_LOW, self.target_HIGH = target_LOW, target_HIGH\n\n    assign_interpolation_distance_to_mesh_vertices(self.mesh, weight=0.5, target_LOW=self.target_LOW,\n                                                   target_HIGH=self.target_HIGH)\n    # Late import to avoid circular dependency\n    from compas_slicer.pre_processing.gradient_evaluation import GradientEvaluation\n\n    g_evaluation = GradientEvaluation(self.mesh, self.DATA_PATH)\n    g_evaluation.find_critical_points()  # First estimation of saddle points with weight = 0.5\n    self.saddles = g_evaluation.saddles\n    self.cut_indices = []\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.region_split.MeshSplitter.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Runs the mesh splitting process. This consists of the following parts.</p> <p>(1) Find the iso-contours that intersect the saddle points. Iteratively find the weights (from 0 to 1) that output a distance field whose iso-contour is intersecting each saddle point. Here two iterations are carried out (one rough and one exact search).</p> <p>For each saddle point and its respective weight and iso-contour: (2) Find the zero-crossing points of the iso-contour and merge points that are close to the saddle to ensure connection. (3) Cleanup iso-contour. Only keep neighborhoods that are intersecting the saddle point. Discard all other. (4) Create the cut on the mesh. (5) Weld the resulting mesh, and restore all the vertex attributes. Note that the mesh remains in one piece, although the cuts have been created. (6) Update compound tardets with the new mesh.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/region_split.py</code> <pre><code>def run(self):\n    \"\"\"\n    Runs the mesh splitting process. This consists of the following parts.\n\n    (1) Find the iso-contours that intersect the saddle points.\n    Iteratively find the weights (from 0 to 1) that output a distance field whose iso-contour is intersecting\n    each saddle point. Here two iterations are carried out (one rough and one exact search).\n\n    For each saddle point and its respective weight and iso-contour:\n    (2) Find the zero-crossing points of the iso-contour and merge points that are close to the saddle to ensure\n    connection.\n    (3) Cleanup iso-contour. Only keep neighborhoods that are intersecting the saddle point. Discard all other.\n    (4) Create the cut on the mesh.\n    (5) Weld the resulting mesh, and restore all the vertex attributes. Note that the mesh remains in one piece,\n    although the cuts have been created.\n    (6) Update compound tardets with the new mesh.\n    \"\"\"\n\n    # (1) first rough estimation of split params\n    split_params = self.identify_positions_to_split(self.saddles)\n    # TODO: merge params that are too close together to avoid creation of very thin neighborhoods.\n    logger.info(f\"{len(split_params)} Split params. First rough estimation :  {split_params}\")\n\n    # split mesh at params\n    logger.info('Splitting mesh at split params')\n    current_cut_index = 1\n\n    for i, param_first_estimation in enumerate(split_params):\n        logger.info(f'cut_index : {current_cut_index}, param_first_estimation : {param_first_estimation:.6f}')\n\n        # --- (1) More exact estimation of intersecting weight. Recompute gradient evaluation.\n        # Find exact saddle point and the weight that intersects it.\n\n        assign_interpolation_distance_to_mesh_vertices(self.mesh, weight=param_first_estimation,\n                                                       target_LOW=self.target_LOW, target_HIGH=self.target_HIGH)\n        # Late import to avoid circular dependency\n        from compas_slicer.pre_processing.gradient_evaluation import GradientEvaluation\n\n        g_evaluation = GradientEvaluation(self.mesh, self.DATA_PATH)\n        g_evaluation.find_critical_points()\n        saddles_ds_tupples = [(vkey, abs(g_evaluation.mesh.vertex_attribute(vkey, 'scalar_field'))) for vkey in\n                              g_evaluation.saddles]\n        saddles_ds_tupples = sorted(saddles_ds_tupples, key=lambda saddle_tupple: saddle_tupple[1])\n        vkey = saddles_ds_tupples[0][0]\n        t = self.identify_positions_to_split([vkey])[0]\n        logger.info(f'vkey_exact : {vkey} , t_exact : {t:.6f}')\n\n        # --- (2) find zero-crossing points\n        assign_interpolation_distance_to_mesh_vertices(self.mesh, t, self.target_LOW, self.target_HIGH)\n        # Late import to avoid circular dependency\n        from compas_slicer.slicers.slice_utilities import ScalarFieldContours\n\n        zero_contours = ScalarFieldContours(self.mesh)\n        zero_contours.compute()\n        keys_of_clusters_to_keep = merge_clusters_saddle_point(zero_contours, saddle_vkeys=[vkey])\n\n        # --- (3) Cleaning up zero-crossing neighborhoods\n        cleanup_unrelated_isocontour_neighborhoods(zero_contours, keys_of_clusters_to_keep)\n\n        if zero_contours:  # if there are remaining zero-crossing neighborhoods\n            zero_contours = smoothen_cut(zero_contours, self.mesh, saddle_vkeys=[vkey], iterations=15,\n                                         strength=0.2)  # smoothen the cut close to the saddle point.\n\n            # save to json intermediary results\n            zero_contours.save_point_clusters_as_polylines_to_json(self.OUTPUT_PATH,\n                                                                   f'point_clusters_polylines_{int(i)}.json')\n\n            #  --- (4) Create cut\n            logger.info(\"Creating cut on mesh\")\n            self.cut_indices.append(current_cut_index)\n            self.split_intersected_faces(zero_contours, current_cut_index)\n            current_cut_index += 1\n\n            #  --- (5) Weld mesh and restore attributes\n            logger.info('Cleaning up the mesh. Welding and restoring attributes')\n            v_attributes_dict = save_vertex_attributes(self.mesh)\n            self.mesh = weld_mesh(self.mesh, self.OUTPUT_PATH)\n            restore_mesh_attributes(self.mesh, v_attributes_dict)\n\n            #  --- (6) Update targets\n            if i &lt; len(split_params) - 1:  # does not need to happen at the end\n                logger.info('Updating targets, recomputing geodesic distances')\n                self.update_targets()\n\n        self.mesh.to_obj(str(Path(self.OUTPUT_PATH) / 'most_recent_cut_mesh.obj'))\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.region_split.MeshSplitter.update_targets","title":"update_targets","text":"<pre><code>update_targets()\n</code></pre> <p>Update targets with the new mesh that was created during the split process. Note: This only works if the target vertices have not been touched. If all has gone well, targets can only have minima and maxima, so they should remain intact after the split</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/region_split.py</code> <pre><code>def update_targets(self):\n    \"\"\"\n    Update targets with the new mesh that was created during the split process.\n    Note: This only works if the target vertices have not been touched. If all has gone well, targets can only have\n    minima and maxima, so they should remain intact after the split\n    \"\"\"\n    self.target_LOW.assign_new_mesh(self.mesh)\n    self.target_LOW.find_targets_connected_components()\n    self.target_LOW.compute_geodesic_distances()\n    if self.target_HIGH:\n        self.target_HIGH.assign_new_mesh(self.mesh)\n        self.target_HIGH.find_targets_connected_components()\n        self.target_HIGH.compute_geodesic_distances()\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.region_split.MeshSplitter.split_intersected_faces","title":"split_intersected_faces","text":"<pre><code>split_intersected_faces(zero_contours, cut_index)\n</code></pre> <p>Create cuts on intersected faces</p> <p>Parameters:</p> Name Type Description Default <code>zero_contours</code> required <code>cut_index</code> required Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/region_split.py</code> <pre><code>def split_intersected_faces(self, zero_contours, cut_index):\n    \"\"\"\n    Create cuts on intersected faces\n\n    Parameters\n    ----------\n    zero_contours: :class: 'compas_slicer.pre_processing.ScalarFieldContours'\n    cut_index: int, the vertex attribute value data['cut'] of the current cut\n    \"\"\"\n    for key in zero_contours.sorted_point_clusters:  # cluster_pair\n        edges = zero_contours.sorted_edge_clusters[key]\n        pts = zero_contours.sorted_point_clusters[key]\n\n        # add first vertex\n        p = pts[0]\n        v0 = self.mesh.add_vertex(x=p[0], y=p[1], z=p[2], attr_dict={'cut': 1})\n\n        for i, edge in enumerate(edges):\n            next_edge = edges[(i + 1) % len(edges)]\n            p = pts[(i + 1) % len(pts)]\n\n            faces_current_edge = self.mesh.edge_faces(u=edge[0], v=edge[1])\n            faces_next_edge = self.mesh.edge_faces(u=next_edge[0], v=next_edge[1])\n\n            fkey_common = list(set(faces_current_edge).intersection(faces_next_edge))[0]\n            vkey_common = list(set(edge).intersection(next_edge))[0]\n            v_other_a = list(set(edge).difference([vkey_common]))[0]\n            v_other_b = list(set(next_edge).difference([vkey_common]))[0]\n\n            v_new = self.mesh.add_vertex(x=p[0], y=p[1], z=p[2], attr_dict={'cut': cut_index})\n\n            # remove and add faces\n            if fkey_common in list(self.mesh.faces()):\n                self.mesh.delete_face(fkey_common)\n                self.mesh.add_face([vkey_common, v_new, v0])\n                self.mesh.add_face([v_new, v_other_a, v0])\n                self.mesh.add_face([v_other_b, v_other_a, v_new])\n            else:\n                logger.warning('Did not need to modify faces.')\n            v0 = v_new\n\n    self.mesh.cull_vertices()  # remove all unused vertices\n    try:\n        self.mesh.unify_cycles()\n    except AssertionError:\n        logger.warning('Could NOT unify cycles')\n    if not self.mesh.is_valid():\n        logger.warning('Attention! Mesh is NOT valid!')\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.region_split.MeshSplitter.identify_positions_to_split","title":"identify_positions_to_split","text":"<pre><code>identify_positions_to_split(saddles)\n</code></pre> <p>Find the weights that create iso-contours that intersect the saddle points.</p> <p>Parameters:</p> Name Type Description Default <code>saddles</code> required <p>Returns:</p> Type Description <code>list, float, the weights from 0 to 1. One for each saddle point.</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/region_split.py</code> <pre><code>def identify_positions_to_split(self, saddles):\n    \"\"\"\n    Find the weights that create iso-contours that intersect the saddle points.\n\n    Parameters\n    ----------\n    saddles: list, int, the vertex keys of the saddle points\n\n    Returns\n    ----------\n    list, float, the weights from 0 to 1. One for each saddle point.\n    \"\"\"\n    split_params = []\n    for vkey in saddles:\n        param = self.find_weight_intersecting_vkey(vkey, threshold=HIT_THRESHOLD, resolution=T_SEARCH_RESOLUTION)\n        split_params.append(param)\n    return split_params\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.region_split.MeshSplitter.find_weight_intersecting_vkey","title":"find_weight_intersecting_vkey","text":"<pre><code>find_weight_intersecting_vkey(vkey, threshold, resolution)\n</code></pre> <p>Find the weights that intersect the vertex.</p> <p>Parameters:</p> Name Type Description Default <code>vkey</code> required <code>threshold</code> required <code>resolution</code> required <p>Returns:</p> Type Description <code>float, the weights from 0 to 1.</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/region_split.py</code> <pre><code>def find_weight_intersecting_vkey(self, vkey, threshold, resolution):\n    \"\"\"\n    Find the weights that intersect the vertex.\n\n    Parameters\n    ----------\n    vkey: list, int, the vertex key to intersect\n    threshold: float, the d value below which we consider we have a hit. Should be a very small value\n    resolution: int, the resolution of search, should be a value more than 10**4\n\n    Returns\n    ----------\n    float, the weights from 0 to 1.\n    \"\"\"\n    weight_list = get_weights_list(n=resolution, start=0.001, end=0.999)\n    # TODO: save next d to avoid re-evaluating\n    for i, weight in enumerate(weight_list[:-1]):\n        current_d = assign_interpolation_distance_to_mesh_vertex(vkey, weight, self.target_LOW, self.target_HIGH)\n        next_d = assign_interpolation_distance_to_mesh_vertex(vkey, weight_list[i + 1], self.target_LOW, self.target_HIGH)\n        if abs(current_d) &lt; abs(next_d) and current_d &lt; threshold:\n            return weight\n    raise ValueError(f'Could NOT find param for saddle vkey {vkey}!')\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.region_split.get_weights_list","title":"get_weights_list","text":"<pre><code>get_weights_list(n, start=0.03, end=1.0)\n</code></pre> <p>Returns a numpy array with n numbers from start to end.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/region_split.py</code> <pre><code>def get_weights_list(n, start=0.03, end=1.0):\n    \"\"\" Returns a numpy array with n numbers from start to end. \"\"\"\n    return list(np.arange(start=start, stop=end, step=(end - start) / n))\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.region_split.separate_disconnected_components","title":"separate_disconnected_components","text":"<pre><code>separate_disconnected_components(mesh, attr, values, OUTPUT_PATH)\n</code></pre> <p>Given a mesh with cuts that have already been created, it separates the disconnected components by cutting along marked edges. Then it welds them and restores their attributes.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> required <code>attr</code> required <code>values</code> required <code>OUTPUT_PATH</code> required <p>Returns:</p> Type Description <code>list, :class: 'compas.datastructures.Mesh' The resulting split meshes.</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/region_split.py</code> <pre><code>def separate_disconnected_components(mesh, attr, values, OUTPUT_PATH):\n    \"\"\"\n    Given a mesh with cuts that have already been created, it separates the disconnected\n    components by cutting along marked edges. Then it welds them and restores their attributes.\n\n    Parameters\n    ----------\n    mesh: :class: 'compas.datastructures.Mesh'\n    attr: str, the key of the vertex attributes that signals the cuts. most likely 'cut'\n    values: list, int, the cut indices\n    OUTPUT_PATH: str, the path to the output folder\n\n    Returns\n    ----------\n    list, :class: 'compas.datastructures.Mesh' The resulting split meshes.\n    \"\"\"\n\n    v_attributes_dict = save_vertex_attributes(mesh)\n\n    v, f = mesh.to_vertices_and_faces()\n    v, f = np.array(v), np.array(f)\n\n    # --- create cut flags for edges\n    cut_flags = []\n    for fkey in mesh.faces():\n        edges = mesh.face_halfedges(fkey)\n        current_face_flags = []\n        for fu, fv in edges:\n            fu_attr, fv_attr = mesh.vertex_attribute(fu, attr), mesh.vertex_attribute(fv, attr)\n            if fu_attr == fv_attr and fu_attr in values:\n                current_face_flags.append(1)\n            else:\n                current_face_flags.append(0)\n        cut_flags.append(current_face_flags)\n    cut_flags = np.array(cut_flags)\n    if cut_flags.shape != f.shape:\n        raise RuntimeError(f\"Cut flags shape {cut_flags.shape} doesn't match face array shape {f.shape}\")\n\n    # --- cut mesh by duplicating vertices along cut edges\n    v_cut, f_cut = _trimesh_cut_mesh(v, f, cut_flags)\n    connected_components = _trimesh_face_components(v_cut, f_cut)\n\n    f_dict: dict[int, list[list[int]]] = {}\n    for i in range(max(connected_components) + 1):\n        f_dict[i] = []\n    for f_index, face in enumerate(f_cut):\n        component = connected_components[f_index]\n        f_dict[component].append(face.tolist() if hasattr(face, 'tolist') else list(face))\n\n    cut_meshes = []\n    for component in f_dict:\n        cut_mesh = Mesh.from_vertices_and_faces(v_cut.tolist(), f_dict[component])\n        cut_mesh.cull_vertices()\n        if len(list(cut_mesh.faces())) &gt; 2:\n            temp_path = Path(OUTPUT_PATH) / 'temp.obj'\n            cut_mesh.to_obj(str(temp_path))\n            cut_mesh = Mesh.from_obj(str(temp_path))  # get rid of too many empty keys\n            cut_meshes.append(cut_mesh)\n\n    for mesh in cut_meshes:\n        restore_mesh_attributes(mesh, v_attributes_dict)\n\n    return cut_meshes\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.region_split.smoothen_cut","title":"smoothen_cut","text":"<pre><code>smoothen_cut(zero_contours, mesh, saddle_vkeys, iterations, strength, distance_threshold=20.0 * 20.0)\n</code></pre> <p>Iterative smoothing of the cut around the saddle point.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/region_split.py</code> <pre><code>def smoothen_cut(zero_contours, mesh, saddle_vkeys, iterations, strength, distance_threshold=20.0*20.0):\n    \"\"\" Iterative smoothing of the cut around the saddle point. \"\"\"\n    for _ in range(iterations):\n        saddles = [mesh.vertex_coordinates(key) for key in saddle_vkeys]\n        count = 0\n\n        for cluster_key in zero_contours.sorted_point_clusters:\n            pts = zero_contours.sorted_point_clusters[cluster_key]\n            edges = zero_contours.sorted_edge_clusters[cluster_key]\n            for i, pt in enumerate(pts):\n                if 0.01 &lt; min([distance_point_point_sqrd(pt, s) for s in saddles]) &lt; distance_threshold:\n                    count += 1\n                    edge = edges[i]\n                    prev = pts[i - 1]\n                    next_p = pts[(i + 1) % len(pts)]\n                    avg = [(prev[0] + next_p[0]) * 0.5, (prev[1] + next_p[1]) * 0.5, (prev[2] + next_p[2]) * 0.5]\n                    point = np.array(avg) * strength + np.array(pt) * (1 - strength)\n                    line = Line(mesh.vertex_coordinates(edge[0]), mesh.vertex_coordinates(edge[1]))\n                    projected_pt = project_point_line(point, line)\n                    pts[i] = projected_pt\n                    zero_contours.sorted_point_clusters[cluster_key][i] = projected_pt\n\n    return zero_contours\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.region_split.merge_clusters_saddle_point","title":"merge_clusters_saddle_point","text":"<pre><code>merge_clusters_saddle_point(zero_contours, saddle_vkeys)\n</code></pre> <p>Merge the points that are on edges that have the saddle point as one of their edges to the saddle point.</p> <p>Parameters:</p> Name Type Description Default <code>zero_contours</code> <code>ScalarFieldContours</code> <p>Contours object.</p> required <code>saddle_vkeys</code> <code>list[int]</code> <p>Vertex keys of the current saddle points (currently only single saddle point supported).</p> required <p>Returns:</p> Type Description <code>list, int. The index neighborhoods that are related to the saddle points.</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/region_split.py</code> <pre><code>def merge_clusters_saddle_point(zero_contours, saddle_vkeys):\n    \"\"\"\n    Merge the points that are on edges that have the saddle point as one of their edges to the saddle point.\n\n    Parameters\n    ----------\n    zero_contours : ScalarFieldContours\n        Contours object.\n    saddle_vkeys : list[int]\n        Vertex keys of the current saddle points (currently only single saddle point supported).\n\n    Returns\n    ----------\n    list, int. The index neighborhoods that are related to the saddle points.\n    \"\"\"\n    keys_of_clusters_to_keep = []\n    for cluster_key in zero_contours.sorted_edge_clusters:\n        edges = zero_contours.sorted_edge_clusters[cluster_key]\n        for i, e in enumerate(edges):\n            for saddle_vkey in saddle_vkeys:\n                if saddle_vkey in e:\n                    zero_contours.sorted_point_clusters[cluster_key][i] = \\\n                        zero_contours.mesh.vertex_coordinates(saddle_vkey)  # merge point with saddle point\n                    logger.debug(f'Found edge to merge: {e}')\n                    if cluster_key not in keys_of_clusters_to_keep:\n                        keys_of_clusters_to_keep.append(cluster_key)\n\n    return keys_of_clusters_to_keep\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.region_split.cleanup_unrelated_isocontour_neighborhoods","title":"cleanup_unrelated_isocontour_neighborhoods","text":"<pre><code>cleanup_unrelated_isocontour_neighborhoods(zero_contours, keys_of_clusters_to_keep)\n</code></pre> <p>Remove the neighborhoods of the zero-crossing contour when they are not related to the saddle points.</p> <p>Parameters:</p> Name Type Description Default <code>zero_contours</code> required <code>keys_of_clusters_to_keep</code> required Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/region_split.py</code> <pre><code>def cleanup_unrelated_isocontour_neighborhoods(zero_contours, keys_of_clusters_to_keep):\n    \"\"\"\n    Remove the neighborhoods of the zero-crossing contour when they are not related to the saddle points.\n\n    Parameters\n    ----------\n    zero_contours: :class: 'compas_slicer.pre_processing.ScalarFieldContours'\n    keys_of_clusters_to_keep: list, int. The index neighborhoods that are related to the saddle points.\n    \"\"\"\n    if len(keys_of_clusters_to_keep) == 0:\n        logger.error(\"No common vertex found! Skipping this split_param\")\n        return None\n    else:\n        logger.info(f'keys_of_clusters_to_keep: {keys_of_clusters_to_keep}')\n        # empty all other clusters that are not in the matching_pair\n        sorted_point_clusters_clean = copy.deepcopy(zero_contours.sorted_point_clusters)\n        sorted_edge_clusters_clean = copy.deepcopy(zero_contours.sorted_edge_clusters)\n        for key in zero_contours.sorted_point_clusters:\n            if key not in keys_of_clusters_to_keep:\n                del sorted_point_clusters_clean[key]\n                del sorted_edge_clusters_clean[key]\n\n        zero_contours.sorted_point_clusters = sorted_point_clusters_clean\n        zero_contours.sorted_edge_clusters = sorted_edge_clusters_clean\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.region_split.weld_mesh","title":"weld_mesh","text":"<pre><code>weld_mesh(mesh, OUTPUT_PATH, precision='2f')\n</code></pre> <p>Welds mesh and check that the result is valid.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/region_split.py</code> <pre><code>def weld_mesh(mesh, OUTPUT_PATH, precision='2f'):\n    \"\"\" Welds mesh and check that the result is valid. \"\"\"\n    for f_key in mesh.faces():\n        if len(mesh.face_vertices(f_key)) &lt; 3:\n            mesh.delete_face(f_key)\n\n    welded_mesh = mesh.weld(precision=precision)\n\n    temp_path = Path(OUTPUT_PATH) / 'temp.obj'\n    welded_mesh.to_obj(str(temp_path))  # make sure there's no empty f_keys\n    welded_mesh = Mesh.from_obj(str(temp_path))  # TODO: find a better way to do this\n\n    try:\n        welded_mesh.unify_cycles()\n        logger.info(\"Unified cycles of welded_mesh\")\n    except AssertionError:\n        logger.error(\"Attention! Could NOT unify cycles of welded_mesh\")\n\n    if not welded_mesh.is_valid():  # and iteration &lt; 3:\n        logger.error(\"Attention! Welded mesh is INVALID\")\n    if not welded_mesh.is_manifold():\n        logger.error(\"Attention! Welded mesh is NON-MANIFOLD\")\n\n    return welded_mesh\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting","title":"topological_sorting","text":""},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.DirectedGraph","title":"DirectedGraph","text":"<pre><code>DirectedGraph()\n</code></pre> <p>Base class for topological sorting of prints that consist of several parts that lie on each other. For example the graph A-&gt;B-&gt;C would represent a print that consists of three parts; A, B, C where A lies on the build platform, B lies on A, and C lies on B. This graph cannot have cycles; cycles would represent an unfeasible print.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def __init__(self) -&gt; None:\n    logger.info('Topological sorting')\n\n    self.G: nx.DiGraph = nx.DiGraph()\n    self.create_graph_nodes()\n    self.root_indices = self.find_roots()\n    logger.info(f'Graph roots: {self.root_indices}')\n    if len(self.root_indices) == 0:\n        raise ValueError(\"No root nodes were found. At least one root node is needed.\")\n    self.end_indices = self.find_ends()\n    logger.info(f'Graph ends: {self.end_indices}')\n    if len(self.end_indices) == 0:\n        raise ValueError(\"No end nodes were found. At least one end node is needed.\")\n\n    self.create_directed_graph_edges(copy.deepcopy(self.root_indices))\n    logger.info(f'Nodes: {list(self.G.nodes(data=True))}')\n    logger.info(f'Edges: {list(self.G.edges(data=True))}')\n\n    self.N: int = len(list(self.G.nodes()))\n    self.adj_list: list[list[int]] = self.get_adjacency_list()  # Nested list where adj_list[i] is a list of all the neighbors\n    # of the i-th component\n    self.check_that_all_nodes_found_their_connectivity()\n    logger.info(f'Adjacency list: {self.adj_list}')\n    self.in_degree: list[int] = self.get_in_degree()  # Nested list where adj_list[i] is a list of all the edges pointing\n    # to the i-th node.\n    self.all_orders: list[list[int]] = []\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.DirectedGraph.find_roots","title":"find_roots  <code>abstractmethod</code>","text":"<pre><code>find_roots()\n</code></pre> <p>Roots are vertical_layers_print_data that lie on the build platform. Like that they can be print first.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>@abstractmethod\ndef find_roots(self) -&gt; list[int]:\n    \"\"\" Roots are vertical_layers_print_data that lie on the build platform. Like that they can be print first. \"\"\"\n    pass\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.DirectedGraph.find_ends","title":"find_ends  <code>abstractmethod</code>","text":"<pre><code>find_ends()\n</code></pre> <p>Ends are vertical_layers_print_data that belong to exclusively one segment. Like that they can be print last.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>@abstractmethod\ndef find_ends(self) -&gt; list[int]:\n    \"\"\" Ends are vertical_layers_print_data that belong to exclusively one segment. Like that they can be print last. \"\"\"\n    pass\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.DirectedGraph.create_graph_nodes","title":"create_graph_nodes  <code>abstractmethod</code>","text":"<pre><code>create_graph_nodes()\n</code></pre> <p>Add the nodes to the graph with their attributes.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>@abstractmethod\ndef create_graph_nodes(self) -&gt; None:\n    \"\"\" Add the nodes to the graph with their attributes. \"\"\"\n    pass\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.DirectedGraph.get_children_of_node","title":"get_children_of_node  <code>abstractmethod</code>","text":"<pre><code>get_children_of_node(root)\n</code></pre> <p>Find all the vertical_layers_print_data that lie on the current root segment.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>@abstractmethod\ndef get_children_of_node(self, root: int) -&gt; tuple[list[int], list[Any]]:\n    \"\"\" Find all the vertical_layers_print_data that lie on the current root segment. \"\"\"\n    pass\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.DirectedGraph.create_directed_graph_edges","title":"create_directed_graph_edges","text":"<pre><code>create_directed_graph_edges(root_indices)\n</code></pre> <p>Create the connectivity of the directed graph using breadth-first search graph traversal.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def create_directed_graph_edges(self, root_indices: list[int]) -&gt; None:\n    \"\"\" Create the connectivity of the directed graph using breadth-first search graph traversal. \"\"\"\n    passed_nodes = []\n    queue = root_indices\n\n    while len(queue) &gt; 0:\n        queue = self.sort_queue_with_end_targets_last(queue)\n        current_node = queue[0]\n        queue.remove(current_node)\n        passed_nodes.append(current_node)\n        children, cut_ids = self.get_children_of_node(current_node)\n        for child_key, common_cuts in zip(children, cut_ids):\n            self.G.add_edge(current_node, child_key, cut=common_cuts)\n        for child_key in children:\n            if child_key in passed_nodes:\n                raise ValueError('Error: cyclic directed graph detected.')\n        for child_key in children:\n            if child_key not in queue:\n                queue.append(child_key)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.DirectedGraph.check_that_all_nodes_found_their_connectivity","title":"check_that_all_nodes_found_their_connectivity","text":"<pre><code>check_that_all_nodes_found_their_connectivity()\n</code></pre> <p>Assert that there is no island, i.e. no node or groups of nodes that are not connected to the base.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def check_that_all_nodes_found_their_connectivity(self) -&gt; None:\n    \"\"\" Assert that there is no island, i.e. no node or groups of nodes that are not connected to the base. \"\"\"\n    good_nodes = list(self.root_indices)\n    for children_list in self.adj_list:\n        for child in children_list:\n            if child not in good_nodes:\n                good_nodes.append(child)\n    if len(good_nodes) != self.N:\n        raise ValueError(\n            f'Floating vertical layers detected: {len(good_nodes)} connected nodes vs {self.N} total. '\n            'Check graph creation process.'\n        )\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.DirectedGraph.sort_queue_with_end_targets_last","title":"sort_queue_with_end_targets_last","text":"<pre><code>sort_queue_with_end_targets_last(queue)\n</code></pre> <p>Sorts the queue so that the vertical_layers_print_data that have an end target are always at the end.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def sort_queue_with_end_targets_last(self, queue: list[int]) -&gt; list[int]:\n    \"\"\" Sorts the queue so that the vertical_layers_print_data that have an end target are always at the end. \"\"\"\n    queue_copy = copy.deepcopy(queue)\n    for index in queue:\n        if index in self.end_indices:\n            queue_copy.remove(index)  # remove it from its current position\n            queue_copy.append(index)  # append it last\n    return queue_copy\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.DirectedGraph.get_adjacency_list","title":"get_adjacency_list","text":"<pre><code>get_adjacency_list()\n</code></pre> <p>Returns adjacency list. Nested list where adj_list[i] is a list of all the neighbors of the ith component</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def get_adjacency_list(self) -&gt; list[list[int]]:\n    \"\"\" Returns adjacency list. Nested list where adj_list[i] is a list of all the neighbors of the ith component\"\"\"\n    adj_list: list[list[int]] = [[] for _ in range(self.N)]  # adjacency list , size = len(Nodes), stores nodes' neighbors\n    for i, adjacent_to_node in self.G.adjacency():\n        for key in adjacent_to_node:\n            adj_list[i].append(key)\n    return adj_list\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.DirectedGraph.get_in_degree","title":"get_in_degree","text":"<pre><code>get_in_degree()\n</code></pre> <p>Returns in_degree list. Nested list where adj_list[i] is a list of all the edges pointing to the node.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def get_in_degree(self) -&gt; list[int]:\n    \"\"\" Returns in_degree list. Nested list where adj_list[i] is a list of all the edges pointing to the node.\"\"\"\n    in_degree = [0] * self.N  # in_degree,  size = len(Nodes) , stores in-degree of a node\n    for key_degree_tuple in self.G.in_degree:\n        key = key_degree_tuple[0]\n        degree = key_degree_tuple[1]\n        in_degree[key] = degree\n    return in_degree\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.DirectedGraph.get_all_topological_orders","title":"get_all_topological_orders","text":"<pre><code>get_all_topological_orders()\n</code></pre> <p>Finds  all topological orders from source to sink.</p> <p>Returns:</p> Type Description <code>list of lists of integers. Each list represents the indices of one topological order.</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def get_all_topological_orders(self) -&gt; list[list[int]]:\n    \"\"\"\n    Finds  all topological orders from source to sink.\n    Returns\n    ----------\n    list of lists of integers. Each list represents the indices of one topological order.\n    \"\"\"\n    self.all_orders = []  # make sure list is empty\n    discovered = [False] * self.N\n    path: list[int] = []  # list to store the topological order\n    self.get_orders(path, discovered)\n    logger.info(f'Found {len(self.all_orders)} possible orders')\n    return self.all_orders\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.DirectedGraph.get_orders","title":"get_orders","text":"<pre><code>get_orders(path, discovered)\n</code></pre> <p>Finds all topological orders from source to sink. Sorting algorithm taken from https://www.techiedelight.com/find-all-possible-topological-orderings-of-dag/</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def get_orders(self, path: list[int], discovered: list[bool]) -&gt; None:\n    \"\"\"\n    Finds all topological orders from source to sink.\n    Sorting algorithm taken from https://www.techiedelight.com/find-all-possible-topological-orderings-of-dag/\n    \"\"\"\n    for v in range(self.N):  # for every node\n        # proceed only if in-degree of current node is 0 and current node is not processed yet\n        if self.in_degree[v] == 0 and not discovered[v]:\n\n            # for every adjacent vertex u of v, reduce in-degree of u by 1\n            for u in self.adj_list[v]:\n                self.in_degree[u] = self.in_degree[u] - 1\n\n            # include current node in the path and mark it as discovered\n            path.append(v)\n            discovered[v] = True\n\n            # recur\n            self.get_orders(path, discovered)\n\n            # backtrack: reset in-degree information for the current node\n            for u in self.adj_list[v]:\n                self.in_degree[u] = self.in_degree[u] + 1\n\n            # backtrack: remove current node from the path and mark it as undiscovered\n            path.pop()\n            discovered[v] = False\n\n    # print the topological order if all vertices are included in the path\n    if len(path) == self.N:\n        self.all_orders.append(copy.deepcopy(path))\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.DirectedGraph.get_parents_of_node","title":"get_parents_of_node","text":"<pre><code>get_parents_of_node(node_index)\n</code></pre> <p>Returns the parents of node with i = node_index.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def get_parents_of_node(self, node_index: int) -&gt; list[int]:\n    \"\"\" Returns the parents of node with i = node_index. \"\"\"\n    return [j for j, adj in enumerate(self.adj_list) if node_index in adj]\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.MeshDirectedGraph","title":"MeshDirectedGraph","text":"<pre><code>MeshDirectedGraph(all_meshes, DATA_PATH)\n</code></pre> <p>               Bases: <code>DirectedGraph</code></p> <p>The MeshDirectedGraph is used for topological sorting of multiple meshes that have been generated as a result of region split over the saddle points of the mesh scalar function</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def __init__(self, all_meshes: list[Mesh], DATA_PATH: str) -&gt; None:\n    self.all_meshes = all_meshes\n    self.DATA_PATH = DATA_PATH\n    self.OUTPUT_PATH = utils.get_output_directory(DATA_PATH)\n    DirectedGraph.__init__(self)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.MeshDirectedGraph.find_roots","title":"find_roots","text":"<pre><code>find_roots()\n</code></pre> <p>Roots are vertical_layers_print_data that lie on the build platform. Like that they can be print first.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def find_roots(self) -&gt; list[int]:\n    \"\"\" Roots are vertical_layers_print_data that lie on the build platform. Like that they can be print first. \"\"\"\n    roots: list[int] = []\n    for i, mesh in enumerate(self.all_meshes):\n        for _vkey, data in mesh.vertices(data=True):\n            if i not in roots and data['boundary'] == 1:\n                roots.append(i)\n    return roots\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.MeshDirectedGraph.find_ends","title":"find_ends","text":"<pre><code>find_ends()\n</code></pre> <p>Ends are vertical_layers_print_data that belong to exclusively one segment. Like that they can be print last.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def find_ends(self) -&gt; list[int]:\n    \"\"\" Ends are vertical_layers_print_data that belong to exclusively one segment. Like that they can be print last. \"\"\"\n    ends: list[int] = []\n    for i, mesh in enumerate(self.all_meshes):\n        for _vkey, data in mesh.vertices(data=True):\n            if i not in ends and data['boundary'] == 2:\n                ends.append(i)\n    return ends\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.MeshDirectedGraph.create_graph_nodes","title":"create_graph_nodes","text":"<pre><code>create_graph_nodes()\n</code></pre> <p>Add each of the split meshes to the graph as nodes. Cuts and boundaries are stored as attributes.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def create_graph_nodes(self) -&gt; None:\n    \"\"\" Add each of the split meshes to the graph as nodes. Cuts and boundaries are stored as attributes. \"\"\"\n    for i, m in enumerate(self.all_meshes):\n        self.G.add_node(i, cuts=get_existing_cut_indices(m),\n                        boundaries=get_existing_boundary_indices(m))\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.MeshDirectedGraph.get_children_of_node","title":"get_children_of_node","text":"<pre><code>get_children_of_node(root)\n</code></pre> <p>Find all the nodes that lie on the current root.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>int</code> required <p>Returns:</p> Type Description <code>2 lists [child1, child2, ...], [[common cuts 1], [common cuts 2] ...]</code> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def get_children_of_node(self, root: int) -&gt; tuple[list[int], list[list[int]]]:\n    \"\"\"\n    Find all the nodes that lie on the current root.\n\n    Parameters\n    ----------\n    root: int, index of root node\n\n    Returns\n    ----------\n    2 lists [child1, child2, ...], [[common cuts 1], [common cuts 2] ...]\n    \"\"\"\n    children: list[int] = []\n    cut_ids: list[list[int]] = []\n    parent_data = self.G.nodes(data=True)[root]\n\n    for key, data in self.G.nodes(data=True):\n        common_cuts = list(set(parent_data['cuts']).intersection(data['cuts']))\n\n        if key != root and len(common_cuts) &gt; 0 \\\n                and (key, root) not in self.G.edges() \\\n                and (root, key) not in self.G.edges() and is_true_mesh_adjacency(self.all_meshes, key, root):\n            if len(common_cuts) != 1:  # if all cuts worked, this should be 1. But life is not perfect.\n                logger.error(\n                    f'More than one common cuts between two pieces in the following split meshes. '\n                    f'Root : {root}, child : {key} . Common cuts : {common_cuts}'\n                    'Probably some cut did not separate components'\n                )\n            children.append(key)\n            cut_ids.append(common_cuts)\n\n    # --- debugging output\n    return children, cut_ids\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.SegmentsDirectedGraph","title":"SegmentsDirectedGraph","text":"<pre><code>SegmentsDirectedGraph(mesh, segments, max_d_threshold, DATA_PATH)\n</code></pre> <p>               Bases: <code>DirectedGraph</code></p> <p>The SegmentsDirectedGraph is used for topological sorting of multiple vertical_layers_print_data in one mesh</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def __init__(\n    self, mesh: Mesh, segments: list[VerticalLayer], max_d_threshold: float, DATA_PATH: str\n) -&gt; None:\n    self.mesh = mesh\n    self.segments = segments\n    self.max_d_threshold = max_d_threshold\n    self.DATA_PATH = DATA_PATH\n    self.OUTPUT_PATH = utils.get_output_directory(DATA_PATH)\n    DirectedGraph.__init__(self)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.SegmentsDirectedGraph.find_roots","title":"find_roots","text":"<pre><code>find_roots()\n</code></pre> <p>Roots are vertical_layers_print_data that lie on the build platform. Like that they can be print first.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def find_roots(self) -&gt; list[int]:\n    \"\"\" Roots are vertical_layers_print_data that lie on the build platform. Like that they can be print first. \"\"\"\n    boundary_pts = utils.get_mesh_vertex_coords_with_attribute(self.mesh, 'boundary', 1)\n    root_segments: list[int] = []\n    for i, segment in enumerate(self.segments):\n        first_curve_pts = segment.paths[0].points\n        if are_neighboring_point_clouds(boundary_pts, first_curve_pts, 2 * self.max_d_threshold):\n            root_segments.append(i)\n    return root_segments\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.SegmentsDirectedGraph.find_ends","title":"find_ends","text":"<pre><code>find_ends()\n</code></pre> <p>Ends are vertical_layers_print_data that belong to exclusively one segment. Like that they can be print last.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def find_ends(self) -&gt; list[int]:\n    \"\"\" Ends are vertical_layers_print_data that belong to exclusively one segment. Like that they can be print last. \"\"\"\n    boundary_pts = utils.get_mesh_vertex_coords_with_attribute(self.mesh, 'boundary', 2)\n    end_segments: list[int] = []\n    for i, segment in enumerate(self.segments):\n        last_curve_pts = segment.paths[-1].points\n        if are_neighboring_point_clouds(boundary_pts, last_curve_pts, self.max_d_threshold):\n            end_segments.append(i)\n    return end_segments\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.SegmentsDirectedGraph.create_graph_nodes","title":"create_graph_nodes","text":"<pre><code>create_graph_nodes()\n</code></pre> <p>Add each segment to to the graph as a node.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def create_graph_nodes(self) -&gt; None:\n    \"\"\" Add each segment to to the graph as a node. \"\"\"\n    for i, _segment in enumerate(self.segments):\n        self.G.add_node(i)\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.SegmentsDirectedGraph.get_children_of_node","title":"get_children_of_node","text":"<pre><code>get_children_of_node(root)\n</code></pre> <p>Find all the nodes that lie on the current root.</p> Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def get_children_of_node(self, root: int) -&gt; tuple[list[int], list[None]]:\n    \"\"\" Find all the nodes that lie on the current root. \"\"\"\n    children: list[int] = []\n    root_segment = self.segments[root]\n    root_last_crv_pts = root_segment.paths[-1].points\n    # utils.save_to_json(utils.point_list_to_dict(root_last_crv_pts), self.OUTPUT_PATH, \"root_last_crv_pts.json\")\n\n    for i, segment in enumerate(self.segments):\n        if i != root:\n            segment_first_curve_pts = segment.paths[0].points\n            # utils.save_to_json(utils.point_list_to_dict(segment_first_curve_pts), self.OUTPUT_PATH,\n            #                    \"segment_first_curve_pts.json\")\n            if are_neighboring_point_clouds(root_last_crv_pts, segment_first_curve_pts, self.max_d_threshold):\n                children.append(i)\n    return children, [None for _ in children]  # None because this graph doesn't have cut ids\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.are_neighboring_point_clouds","title":"are_neighboring_point_clouds","text":"<pre><code>are_neighboring_point_clouds(pts1, pts2, threshold)\n</code></pre> <p>Returns True if 3 or more points of the point clouds are closer than the threshold. False otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>pts1</code> <code>list[Point]</code> required <code>pts2</code> <code>list[Point]</code> required <code>threshold</code> <code>float</code> required Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def are_neighboring_point_clouds(pts1: list[Point], pts2: list[Point], threshold: float) -&gt; bool:\n    \"\"\"\n    Returns True if 3 or more points of the point clouds are closer than the threshold. False otherwise.\n\n    Parameters\n    ----------\n    pts1: list, :class: 'compas.geometry.Point'\n    pts2: list, :class: 'compas.geometry.Point'\n    threshold: float\n    \"\"\"\n    if len(pts1) == 0 or len(pts2) == 0:\n        return False\n    # Vectorized: compute min distance from each pt in pts1 to pts2\n    arr1 = np.asarray(pts1, dtype=np.float64)\n    arr2 = np.asarray(pts2, dtype=np.float64)\n    distances = min_distances_to_set(arr1, arr2)\n    return np.sum(distances &lt; threshold) &gt; 5\n</code></pre>"},{"location":"api/pre_processing/#compas_slicer.pre_processing.preprocessing_utils.topological_sorting.is_true_mesh_adjacency","title":"is_true_mesh_adjacency","text":"<pre><code>is_true_mesh_adjacency(all_meshes, key1, key2)\n</code></pre> <p>Returns True if the two meshes share 3 or more vertices. False otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>all_meshes</code> <code>list[Mesh]</code> required <code>key1</code> <code>int</code> required <code>key2</code> <code>int</code> required Source code in <code>src/compas_slicer/pre_processing/preprocessing_utils/topological_sorting.py</code> <pre><code>def is_true_mesh_adjacency(all_meshes: list[Mesh], key1: int, key2: int) -&gt; bool:\n    \"\"\"\n    Returns True if the two meshes share 3 or more vertices. False otherwise.\n\n    Parameters\n    ----------\n    all_meshes: list, :class: 'compas.datastructures.Mesh'\n    key1: int, index of mesh1\n    key2: int, index of mesh2\n    \"\"\"\n    mesh1 = all_meshes[key1]\n    mesh2 = all_meshes[key2]\n    pts_mesh2 = [mesh2.vertex_coordinates(vkey) for vkey, data in mesh2.vertices(data=True)\n                 if (data['cut'] &gt; 0 or data['boundary'] &gt; 0)]\n    pts_mesh1 = [mesh1.vertex_coordinates(vkey) for vkey, data in mesh1.vertices(data=True)\n                 if (data['cut'] &gt; 0 or data['boundary'] &gt; 0)]\n    if len(pts_mesh1) == 0 or len(pts_mesh2) == 0:\n        return False\n    # Vectorized: compute min distance from each pt in mesh1 to pts_mesh2\n    arr1 = np.asarray(pts_mesh1, dtype=np.float64)\n    arr2 = np.asarray(pts_mesh2, dtype=np.float64)\n    distances = min_distances_to_set(arr1, arr2)\n    # Count points with essentially zero distance (shared vertices)\n    return np.sum(distances ** 2 &lt; 0.00001) &gt;= 3\n</code></pre>"},{"location":"api/print_organization/","title":"Print Organization","text":"<p>Fabrication parameter assignment and G-code generation.</p>"},{"location":"api/print_organization/#compas_slicer.print_organization","title":"print_organization","text":"<p>Print organization for embedding fabrication parameters into toolpaths.</p>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer","title":"BasePrintOrganizer","text":"<pre><code>BasePrintOrganizer(slicer)\n</code></pre> <p>Base class for organizing the printing process.</p> <p>This class is meant to be extended for implementing various print organizers. Do not use this class directly. Use PlanarPrintOrganizer or InterpolationPrintOrganizer.</p> <p>Attributes:</p> Name Type Description <code>slicer</code> <code>BaseSlicer</code> <p>An instance of a slicer class.</p> <code>printpoints</code> <code>PrintPointsCollection</code> <p>Collection of printpoints organized by layer and path.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def __init__(self, slicer: BaseSlicer) -&gt; None:\n    if not isinstance(slicer, BaseSlicer):\n        raise TypeError(f\"slicer must be BaseSlicer, not {type(slicer)}\")\n    logger.info(\"Print Organizer\")\n    self.slicer = slicer\n    self.printpoints = PrintPointsCollection()\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer.number_of_printpoints","title":"number_of_printpoints  <code>property</code>","text":"<pre><code>number_of_printpoints\n</code></pre> <p>Total number of printpoints.</p>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer.number_of_paths","title":"number_of_paths  <code>property</code>","text":"<pre><code>number_of_paths\n</code></pre> <p>Total number of paths.</p>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer.number_of_layers","title":"number_of_layers  <code>property</code>","text":"<pre><code>number_of_layers\n</code></pre> <p>Number of layers.</p>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer.total_length_of_paths","title":"total_length_of_paths  <code>property</code>","text":"<pre><code>total_length_of_paths\n</code></pre> <p>Total length of all paths (ignores extruder toggle).</p>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer.total_print_time","title":"total_print_time  <code>property</code>","text":"<pre><code>total_print_time\n</code></pre> <p>Total print time if velocity is defined, else None.</p>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer.printpoints_dict","title":"printpoints_dict  <code>property</code>","text":"<pre><code>printpoints_dict\n</code></pre> <p>Legacy accessor for the old dict format. Prefer using self.printpoints directly.</p>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer.create_printpoints","title":"create_printpoints  <code>abstractmethod</code>","text":"<pre><code>create_printpoints()\n</code></pre> <p>To be implemented by inheriting classes.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>@abstractmethod\ndef create_printpoints(self) -&gt; None:\n    \"\"\"To be implemented by inheriting classes.\"\"\"\n    pass\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer.printpoints_iterator","title":"printpoints_iterator","text":"<pre><code>printpoints_iterator()\n</code></pre> <p>Iterate over all printpoints.</p> <p>Yields:</p> Type Description <code>PrintPoint</code> <p>Each printpoint in the organizer.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def printpoints_iterator(self) -&gt; Generator[PrintPoint, None, None]:\n    \"\"\"Iterate over all printpoints.\n\n    Yields\n    ------\n    PrintPoint\n        Each printpoint in the organizer.\n\n    \"\"\"\n    if not self.printpoints.layers:\n        raise ValueError(\"No printpoints have been created.\")\n    yield from self.printpoints.iter_printpoints()\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer.printpoints_indices_iterator","title":"printpoints_indices_iterator","text":"<pre><code>printpoints_indices_iterator()\n</code></pre> <p>Iterate over printpoints with their indices.</p> <p>Yields:</p> Type Description <code>tuple[PrintPoint, int, int, int]</code> <p>Printpoint, layer index, path index, printpoint index.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def printpoints_indices_iterator(self) -&gt; Iterator[tuple[PrintPoint, int, int, int]]:\n    \"\"\"Iterate over printpoints with their indices.\n\n    Yields\n    ------\n    tuple[PrintPoint, int, int, int]\n        Printpoint, layer index, path index, printpoint index.\n\n    \"\"\"\n    if not self.printpoints.layers:\n        raise ValueError(\"No printpoints have been created.\")\n    yield from self.printpoints.iter_with_indices()\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer.number_of_paths_on_layer","title":"number_of_paths_on_layer","text":"<pre><code>number_of_paths_on_layer(layer_index)\n</code></pre> <p>Number of paths within a layer.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def number_of_paths_on_layer(self, layer_index: int) -&gt; int:\n    \"\"\"Number of paths within a layer.\"\"\"\n    return len(self.printpoints[layer_index])\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer.remove_duplicate_points_in_path","title":"remove_duplicate_points_in_path","text":"<pre><code>remove_duplicate_points_in_path(layer_idx, path_idx, tolerance=0.0001)\n</code></pre> <p>Remove subsequent points within a threshold distance.</p> <p>Parameters:</p> Name Type Description Default <code>layer_idx</code> <code>int</code> <p>The layer index.</p> required <code>path_idx</code> <code>int</code> <p>The path index.</p> required <code>tolerance</code> <code>float</code> <p>Distance threshold for duplicate detection.</p> <code>0.0001</code> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def remove_duplicate_points_in_path(\n    self, layer_idx: int, path_idx: int, tolerance: float = 0.0001\n) -&gt; None:\n    \"\"\"Remove subsequent points within a threshold distance.\n\n    Parameters\n    ----------\n    layer_idx : int\n        The layer index.\n    path_idx : int\n        The path index.\n    tolerance : float\n        Distance threshold for duplicate detection.\n\n    \"\"\"\n    dup_index = []\n    duplicate_ppts = []\n\n    path = self.printpoints[layer_idx][path_idx]\n    for i, printpoint in enumerate(path.printpoints[:-1]):\n        next_ppt = path.printpoints[i + 1]\n        if np.linalg.norm(np.array(printpoint.pt) - np.array(next_ppt.pt)) &lt; tolerance:\n            dup_index.append(i)\n            duplicate_ppts.append(printpoint)\n\n    if duplicate_ppts:\n        logger.warning(\n            f\"Attention! {len(duplicate_ppts)} Duplicate printpoint(s) on \"\n            f\"layer {layer_idx}, path {path_idx}, indices: {dup_index}. They will be removed.\"\n        )\n        for ppt in duplicate_ppts:\n            path.printpoints.remove(ppt)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer.get_printpoint_neighboring_items","title":"get_printpoint_neighboring_items","text":"<pre><code>get_printpoint_neighboring_items(layer_idx, path_idx, i)\n</code></pre> <p>Get neighboring printpoints.</p> <p>Parameters:</p> Name Type Description Default <code>layer_idx</code> <code>int</code> <p>The layer index.</p> required <code>path_idx</code> <code>int</code> <p>The path index.</p> required <code>i</code> <code>int</code> <p>Index of current printpoint.</p> required <p>Returns:</p> Type Description <code>list[PrintPoint | None]</code> <p>Previous and next printpoints (None if at boundary).</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def get_printpoint_neighboring_items(\n    self, layer_idx: int, path_idx: int, i: int\n) -&gt; list[PrintPoint | None]:\n    \"\"\"Get neighboring printpoints.\n\n    Parameters\n    ----------\n    layer_idx : int\n        The layer index.\n    path_idx : int\n        The path index.\n    i : int\n        Index of current printpoint.\n\n    Returns\n    -------\n    list[PrintPoint | None]\n        Previous and next printpoints (None if at boundary).\n\n    \"\"\"\n    path = self.printpoints[layer_idx][path_idx]\n    prev_pt = path[i - 1] if i &gt; 0 else None\n    next_pt = path[i + 1] if i &lt; len(path) - 1 else None\n    return [prev_pt, next_pt]\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer.printout_info","title":"printout_info","text":"<pre><code>printout_info()\n</code></pre> <p>Print information about the PrintOrganizer.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def printout_info(self) -&gt; None:\n    \"\"\"Print information about the PrintOrganizer.\"\"\"\n    ppts_attributes = {\n        key: str(type(val))\n        for key, val in self.printpoints[0][0][0].attributes.items()\n    }\n\n    logger.info(\"---- PrintOrganizer Info ----\")\n    logger.info(f\"Number of layers: {self.number_of_layers}\")\n    logger.info(f\"Number of paths: {self.number_of_paths}\")\n    logger.info(f\"Number of PrintPoints: {self.number_of_printpoints}\")\n    logger.info(\"PrintPoints attributes: \")\n    for key, val in ppts_attributes.items():\n        logger.info(f\"     {key} : {val}\")\n    logger.info(f\"Toolpath length: {self.total_length_of_paths:.0f} mm\")\n\n    print_time = self.total_print_time\n    if print_time:\n        minutes, sec = divmod(print_time, 60)\n        hour, minutes = divmod(minutes, 60)\n        logger.info(f\"Total print time: {int(hour)} hours, {int(minutes)} minutes, {int(sec)} seconds\")\n    else:\n        logger.info(\"Print Velocity has not been assigned, thus print time is not calculated.\")\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer.get_printpoint_up_vector","title":"get_printpoint_up_vector","text":"<pre><code>get_printpoint_up_vector(path, k, normal)\n</code></pre> <p>Get printpoint up-vector orthogonal to path direction and normal.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path containing the point.</p> required <code>k</code> <code>int</code> <p>Index of the point in path.points.</p> required <code>normal</code> <code>Vector</code> <p>The normal vector.</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>The up vector.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def get_printpoint_up_vector(self, path: Path, k: int, normal: Vector) -&gt; Vector:\n    \"\"\"Get printpoint up-vector orthogonal to path direction and normal.\n\n    Parameters\n    ----------\n    path : Path\n        The path containing the point.\n    k : int\n        Index of the point in path.points.\n    normal : Vector\n        The normal vector.\n\n    Returns\n    -------\n    Vector\n        The up vector.\n\n    \"\"\"\n    p = path.points[k]\n    if k &lt; len(path.points) - 1:\n        negative = False\n        other_pt = path.points[k + 1]\n    else:\n        negative = True\n        other_pt = path.points[k - 1]\n\n    diff = normalize_vector(subtract_vectors(p, other_pt))\n    up_vec = normalize_vector(cross_vectors(normal, diff))\n\n    if negative:\n        up_vec = scale_vector(up_vec, -1.0)\n    if norm_vector(up_vec) == 0:\n        up_vec = Vector(0, 0, 1)\n\n    return Vector(*up_vec)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer.output_printpoints_dict","title":"output_printpoints_dict","text":"<pre><code>output_printpoints_dict()\n</code></pre> <p>Create a flattened printpoints dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Flattened printpoints data for JSON serialization.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def output_printpoints_dict(self) -&gt; dict[int, dict[str, Any]]:\n    \"\"\"Create a flattened printpoints dictionary.\n\n    Returns\n    -------\n    dict\n        Flattened printpoints data for JSON serialization.\n\n    \"\"\"\n    data = {}\n    count = 0\n\n    for i, layer in enumerate(self.printpoints):\n        for j, path in enumerate(layer):\n            self.remove_duplicate_points_in_path(i, j)\n            for printpoint in path:\n                data[count] = printpoint.to_data()\n                count += 1\n\n    logger.info(f\"Generated {count} print points\")\n    return data\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer.output_nested_printpoints_dict","title":"output_nested_printpoints_dict","text":"<pre><code>output_nested_printpoints_dict()\n</code></pre> <p>Create a nested printpoints dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Nested printpoints data for JSON serialization.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def output_nested_printpoints_dict(self) -&gt; dict[str, dict[str, dict[int, dict[str, Any]]]]:\n    \"\"\"Create a nested printpoints dictionary.\n\n    Returns\n    -------\n    dict\n        Nested printpoints data for JSON serialization.\n\n    \"\"\"\n    data: dict[str, dict[str, dict[int, dict[str, Any]]]] = {}\n    count = 0\n\n    for i, layer in enumerate(self.printpoints):\n        layer_key = f\"layer_{i}\"\n        data[layer_key] = {}\n        for j, path in enumerate(layer):\n            path_key = f\"path_{j}\"\n            data[layer_key][path_key] = {}\n            self.remove_duplicate_points_in_path(i, j)\n            for k, printpoint in enumerate(path):\n                data[layer_key][path_key][k] = printpoint.to_data()\n                count += 1\n\n    logger.info(f\"Generated {count} print points\")\n    return data\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer.output_gcode","title":"output_gcode","text":"<pre><code>output_gcode(config=None)\n</code></pre> <p>Generate G-code text.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>GcodeConfig | None</code> <p>G-code configuration. If None, uses defaults.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>G-code text.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def output_gcode(self, config: GcodeConfig | None = None) -&gt; str:\n    \"\"\"Generate G-code text.\n\n    Parameters\n    ----------\n    config : GcodeConfig | None\n        G-code configuration. If None, uses defaults.\n\n    Returns\n    -------\n    str\n        G-code text.\n\n    \"\"\"\n    return create_gcode_text(self, config)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.BasePrintOrganizer.get_printpoints_attribute","title":"get_printpoints_attribute","text":"<pre><code>get_printpoints_attribute(attr_name)\n</code></pre> <p>Get a list of attribute values from all printpoints.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>Name of the attribute.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Attribute values from all printpoints.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def get_printpoints_attribute(self, attr_name: str) -&gt; list[Any]:\n    \"\"\"Get a list of attribute values from all printpoints.\n\n    Parameters\n    ----------\n    attr_name : str\n        Name of the attribute.\n\n    Returns\n    -------\n    list\n        Attribute values from all printpoints.\n\n    \"\"\"\n    attr_values = []\n    for pp in self.printpoints.iter_printpoints():\n        if attr_name not in pp.attributes:\n            raise KeyError(f\"Attribute '{attr_name}' not in printpoint.attributes\")\n        attr_values.append(pp.attributes[attr_name])\n    return attr_values\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.InterpolationPrintOrganizer","title":"InterpolationPrintOrganizer","text":"<pre><code>InterpolationPrintOrganizer(slicer, config=None, DATA_PATH='.')\n</code></pre> <p>               Bases: <code>BasePrintOrganizer</code></p> <p>Organize the printing process for non-planar contours.</p> <p>Attributes:</p> Name Type Description <code>slicer</code> <code>InterpolationSlicer</code> <p>An instance of InterpolationSlicer.</p> <code>config</code> <code>InterpolationConfig</code> <p>Interpolation configuration.</p> <code>DATA_PATH</code> <code>str | Path</code> <p>Data directory path.</p> <code>vertical_layers</code> <code>list[VerticalLayer]</code> <p>Vertical layers from slicer.</p> <code>horizontal_layers</code> <code>list[Layer]</code> <p>Horizontal layers from slicer.</p> <code>base_boundaries</code> <code>list[BaseBoundary]</code> <p>Base boundaries for each vertical layer.</p> Source code in <code>src/compas_slicer/print_organization/interpolation_print_organizer.py</code> <pre><code>def __init__(\n    self,\n    slicer: InterpolationSlicer,\n    config: InterpolationConfig | None = None,\n    DATA_PATH: str | FilePath = \".\",\n) -&gt; None:\n    from compas_slicer.slicers import InterpolationSlicer\n\n    if not isinstance(slicer, InterpolationSlicer):\n        raise TypeError('Please provide an InterpolationSlicer')\n    BasePrintOrganizer.__init__(self, slicer)\n    self.DATA_PATH = DATA_PATH\n    self.OUTPUT_PATH = utils.get_output_directory(DATA_PATH)\n    self.config = config if config else InterpolationConfig()\n\n    self.vertical_layers = slicer.vertical_layers\n    self.horizontal_layers = slicer.horizontal_layers\n    if len(self.vertical_layers) + len(self.horizontal_layers) != len(slicer.layers):\n        raise ValueError(\n            f\"Layer count mismatch: {len(self.vertical_layers)} vertical + \"\n            f\"{len(self.horizontal_layers)} horizontal != {len(slicer.layers)} total\"\n        )\n\n    if len(self.horizontal_layers) &gt; 0:\n        if len(self.horizontal_layers) != 1:\n            raise ValueError(\"Only one brim horizontal layer is currently supported.\")\n        if not self.horizontal_layers[0].is_brim:\n            raise ValueError(\"Only one brim horizontal layer is currently supported.\")\n        logger.info('Slicer has one horizontal brim layer.')\n\n    # topological sorting of vertical layers depending on their connectivity\n    self.topo_sort_graph: topo_sort.SegmentsDirectedGraph | None = None\n    if len(self.vertical_layers) &gt; 1:\n        try:\n            self.topological_sorting()\n        except AssertionError:\n            logger.exception(\"topology sorting failed\\n\")\n            logger.critical(\"integrity of the output data \")\n            # TODO: perhaps its better to be even more explicit and add a\n            #  FAILED-timestamp.txt file?\n    self.selected_order: list[int] | None = None\n\n    # creation of one base boundary per vertical_layer\n    self.base_boundaries: list[BaseBoundary] = self.create_base_boundaries()\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.InterpolationPrintOrganizer.topological_sorting","title":"topological_sorting","text":"<pre><code>topological_sorting()\n</code></pre> <p>Create directed graph of parts with connectivity.</p> <p>Creates a directed graph where each part's connectivity reflects which other parts it lies on and which other parts lie on it.</p> Source code in <code>src/compas_slicer/print_organization/interpolation_print_organizer.py</code> <pre><code>def topological_sorting(self) -&gt; None:\n    \"\"\"Create directed graph of parts with connectivity.\n\n    Creates a directed graph where each part's connectivity reflects which\n    other parts it lies on and which other parts lie on it.\n\n    \"\"\"\n    avg_layer_height = self.config.avg_layer_height\n    self.topo_sort_graph = topo_sort.SegmentsDirectedGraph(self.slicer.mesh, self.vertical_layers,\n                                                           4 * avg_layer_height, DATA_PATH=self.DATA_PATH)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.InterpolationPrintOrganizer.create_base_boundaries","title":"create_base_boundaries","text":"<pre><code>create_base_boundaries()\n</code></pre> <p>Create one BaseBoundary per vertical_layer.</p> Source code in <code>src/compas_slicer/print_organization/interpolation_print_organizer.py</code> <pre><code>def create_base_boundaries(self) -&gt; list[BaseBoundary]:\n    \"\"\"Create one BaseBoundary per vertical_layer.\"\"\"\n    bs: list[BaseBoundary] = []\n    root_vs = utils.get_mesh_vertex_coords_with_attribute(self.slicer.mesh, 'boundary', 1)\n    root_boundary = BaseBoundary(self.slicer.mesh, [Point(*v) for v in root_vs])\n\n    if len(self.vertical_layers) &gt; 1 and self.topo_sort_graph is not None:\n        for i, _vertical_layer in enumerate(self.vertical_layers):\n            parents_of_current_node = self.topo_sort_graph.get_parents_of_node(i)\n            if len(parents_of_current_node) == 0:\n                boundary = root_boundary\n            else:\n                boundary_pts = []\n                for parent_index in parents_of_current_node:\n                    parent = self.vertical_layers[parent_index]\n                    boundary_pts.extend(parent.paths[-1].points)\n                boundary = BaseBoundary(self.slicer.mesh, boundary_pts)\n            bs.append(boundary)\n    else:\n        bs.append(root_boundary)\n\n    # save intermediary outputs\n    b_data = {i: b.to_data() for i, b in enumerate(bs)}\n    utils.save_to_json(b_data, self.OUTPUT_PATH, 'boundaries.json')\n\n    return bs\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.InterpolationPrintOrganizer.create_printpoints","title":"create_printpoints","text":"<pre><code>create_printpoints()\n</code></pre> <p>Create the print points of the fabrication process.</p> <p>Based on the directed graph, select one topological order. From each path collection in that order, copy PrintPoints in the correct order.</p> Source code in <code>src/compas_slicer/print_organization/interpolation_print_organizer.py</code> <pre><code>def create_printpoints(self) -&gt; None:\n    \"\"\"Create the print points of the fabrication process.\n\n    Based on the directed graph, select one topological order.\n    From each path collection in that order, copy PrintPoints in the correct order.\n\n    \"\"\"\n    current_layer_index = 0\n\n    # (1) --- First add the printpoints of the horizontal brim layer (first layer of print)\n    if len(self.horizontal_layers) &gt; 0:  # first add horizontal brim layers\n        print_layer = PrintLayer()\n        paths = self.horizontal_layers[0].paths\n        for _j, path in enumerate(paths):\n            print_path = PrintPath(printpoints=[\n                PrintPoint(pt=point, layer_height=self.config.avg_layer_height,\n                           mesh_normal=utils.get_normal_of_path_on_xy_plane(k, point, path, self.slicer.mesh))\n                for k, point in enumerate(path.points)\n            ])\n            print_layer.paths.append(print_path)\n        self.printpoints.layers.append(print_layer)\n        current_layer_index += 1\n    else:\n        # Add empty first layer placeholder if no horizontal layers\n        pass\n\n    # (2) --- Select order of vertical layers\n    if len(self.vertical_layers) &gt; 1:  # then you need to select one topological order\n\n        if not self.topo_sort_graph:\n            logger.error(\"no topology graph found, cannnot set the order of vertical layers\")\n            self.selected_order = [0]\n        else:\n            all_orders = self.topo_sort_graph.get_all_topological_orders()\n            self.selected_order = all_orders[0]  # TODO: add more elaborate selection strategy\n    else:\n        self.selected_order = [0]  # there is only one segment, only this option\n\n    # (3) --- Then create the printpoints of all the vertical layers in the selected order\n    if self.selected_order is None:\n        raise RuntimeError(\"selected_order must be set before creating printpoints\")\n    for _index, i in enumerate(self.selected_order):\n        layer = self.vertical_layers[i]\n        print_layer = self.get_layer_ppts(layer, self.base_boundaries[i])\n        self.printpoints.layers.append(print_layer)\n        current_layer_index += 1\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.InterpolationPrintOrganizer.get_layer_ppts","title":"get_layer_ppts","text":"<pre><code>get_layer_ppts(layer, base_boundary)\n</code></pre> <p>Create the PrintPoints of a single layer.</p> Source code in <code>src/compas_slicer/print_organization/interpolation_print_organizer.py</code> <pre><code>def get_layer_ppts(self, layer: VerticalLayer, base_boundary: BaseBoundary) -&gt; PrintLayer:\n    \"\"\"Create the PrintPoints of a single layer.\"\"\"\n    max_layer_height = self.config.max_layer_height\n    min_layer_height = self.config.min_layer_height\n    avg_layer_height = self.config.avg_layer_height\n\n    all_pts = [pt for path in layer.paths for pt in path.points]\n    closest_fks, projected_pts = utils.pull_pts_to_mesh_faces(self.slicer.mesh, all_pts)\n    normals = [Vector(*self.slicer.mesh.face_normal(fkey)) for fkey in closest_fks]\n\n    count = 0\n    support_polyline_pts = base_boundary.points  # Start with base boundary\n\n    print_layer = PrintLayer()\n    for _i, path in enumerate(layer.paths):\n        # Batch query: find closest points for all points in this path at once\n        closest_pts, distances = _batch_closest_points_on_polyline(\n            path.points, support_polyline_pts\n        )\n\n        print_path = PrintPath()\n        for k, p in enumerate(path.points):\n            cp = closest_pts[k]\n            d = distances[k]\n\n            normal = normals[count]\n            ppt = PrintPoint(pt=p, layer_height=avg_layer_height, mesh_normal=normal)\n\n            ppt.closest_support_pt = Point(cp[0], cp[1], cp[2])\n            ppt.distance_to_support = d\n            ppt.layer_height = max(min(d, max_layer_height), min_layer_height)\n            ppt.up_vector = self.get_printpoint_up_vector(path, k, normal)\n            if dot_vectors(subtract_vectors(p, ppt.closest_support_pt), ppt.up_vector) &lt; 0:\n                ppt.up_vector = Vector(*scale_vector(ppt.up_vector, -1))\n            ppt.frame = ppt.get_frame()\n\n            print_path.printpoints.append(ppt)\n            count += 1\n\n        print_layer.paths.append(print_path)\n        support_polyline_pts = path.points  # Next path checks against this one\n\n    return print_layer\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.PlanarPrintOrganizer","title":"PlanarPrintOrganizer","text":"<pre><code>PlanarPrintOrganizer(slicer)\n</code></pre> <p>               Bases: <code>BasePrintOrganizer</code></p> <p>Organize the printing process for planar contours.</p> <p>Attributes:</p> Name Type Description <code>slicer</code> <code>PlanarSlicer</code> <p>An instance of PlanarSlicer.</p> Source code in <code>src/compas_slicer/print_organization/planar_print_organizer.py</code> <pre><code>def __init__(self, slicer: PlanarSlicer) -&gt; None:\n    from compas_slicer.slicers import PlanarSlicer\n\n    if not isinstance(slicer, PlanarSlicer):\n        raise TypeError('Please provide a PlanarSlicer')\n    BasePrintOrganizer.__init__(self, slicer)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.PlanarPrintOrganizer.create_printpoints","title":"create_printpoints","text":"<pre><code>create_printpoints(generate_mesh_normals=True)\n</code></pre> <p>Create the print points of the fabrication process.</p> <p>Parameters:</p> Name Type Description Default <code>generate_mesh_normals</code> <code>bool</code> <p>If True, compute mesh normals. If False, use Vector(0, 1, 0).</p> <code>True</code> Source code in <code>src/compas_slicer/print_organization/planar_print_organizer.py</code> <pre><code>def create_printpoints(self, generate_mesh_normals: bool = True) -&gt; None:\n    \"\"\"Create the print points of the fabrication process.\n\n    Parameters\n    ----------\n    generate_mesh_normals : bool\n        If True, compute mesh normals. If False, use Vector(0, 1, 0).\n\n    \"\"\"\n\n    count = 0\n    logger.info('Creating print points ...')\n    with progressbar.ProgressBar(max_value=self.slicer.number_of_points) as bar:\n\n        if generate_mesh_normals:\n            logger.info('Generating mesh normals ...')\n            # fast method for getting the closest mesh normals to all the printpoints\n            all_pts = [pt for layer in self.slicer.layers for path in layer.paths for pt in path.points]\n            closest_fks, projected_pts = utils.pull_pts_to_mesh_faces(self.slicer.mesh, all_pts)\n            normals = [Vector(*self.slicer.mesh.face_normal(fkey)) for fkey in closest_fks]\n\n        for _i, layer in enumerate(self.slicer.layers):\n            print_layer = PrintLayer()\n\n            for _j, path in enumerate(layer.paths):\n                print_path = PrintPath()\n\n                for k, point in enumerate(path.points):\n\n                    n = normals[count] if generate_mesh_normals else Vector(0, 1, 0)\n                    layer_h = self.slicer.layer_height if self.slicer.layer_height else 2.0\n                    printpoint = PrintPoint(pt=point, layer_height=layer_h, mesh_normal=n)\n\n                    if layer.is_brim or layer.is_raft:\n                        printpoint.up_vector = Vector(0, 0, 1)\n                    else:\n                        printpoint.up_vector = self.get_printpoint_up_vector(path, k, n)\n\n                    print_path.printpoints.append(printpoint)\n                    bar.update(count)\n                    count += 1\n\n                print_layer.paths.append(print_path)\n\n            self.printpoints.layers.append(print_layer)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.ScalarFieldPrintOrganizer","title":"ScalarFieldPrintOrganizer","text":"<pre><code>ScalarFieldPrintOrganizer(slicer, config=None, DATA_PATH='.')\n</code></pre> <p>               Bases: <code>BasePrintOrganizer</code></p> <p>Organize the printing process for scalar field contours.</p> <p>Attributes:</p> Name Type Description <code>slicer</code> <code>ScalarFieldSlicer</code> <p>An instance of ScalarFieldSlicer.</p> <code>config</code> <code>InterpolationConfig</code> <p>Configuration parameters.</p> <code>DATA_PATH</code> <code>str | Path</code> <p>Data directory path.</p> <code>vertical_layers</code> <code>list[VerticalLayer]</code> <p>Vertical layers from slicer.</p> <code>horizontal_layers</code> <code>list[Layer]</code> <p>Horizontal layers from slicer.</p> <code>g_evaluation</code> <code>GradientEvaluation</code> <p>Gradient evaluation object.</p> Source code in <code>src/compas_slicer/print_organization/scalar_field_print_organizer.py</code> <pre><code>def __init__(\n    self,\n    slicer: ScalarFieldSlicer,\n    config: InterpolationConfig | None = None,\n    DATA_PATH: str | FilePath = \".\",\n) -&gt; None:\n    from compas_slicer.slicers import ScalarFieldSlicer\n\n    if not isinstance(slicer, ScalarFieldSlicer):\n        raise TypeError('Please provide a ScalarFieldSlicer')\n    BasePrintOrganizer.__init__(self, slicer)\n    self.DATA_PATH = DATA_PATH\n    self.OUTPUT_PATH = utils.get_output_directory(DATA_PATH)\n    self.config = config if config else InterpolationConfig()\n\n    self.vertical_layers = slicer.vertical_layers\n    self.horizontal_layers = slicer.horizontal_layers\n    if len(self.vertical_layers) + len(self.horizontal_layers) != len(slicer.layers):\n        raise ValueError(\n            f\"Layer count mismatch: {len(self.vertical_layers)} vertical + \"\n            f\"{len(self.horizontal_layers)} horizontal != {len(slicer.layers)} total\"\n        )\n\n    if len(self.horizontal_layers) &gt; 0:\n        if len(self.horizontal_layers) != 1:\n            raise ValueError(\"Only one brim horizontal layer is currently supported.\")\n        if not self.horizontal_layers[0].is_brim:\n            raise ValueError(\"Only one brim horizontal layer is currently supported.\")\n        logger.info('Slicer has one horizontal brim layer.')\n\n    self.g_evaluation: GradientEvaluation = self.add_gradient_to_vertices()\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.ScalarFieldPrintOrganizer.create_printpoints","title":"create_printpoints","text":"<pre><code>create_printpoints()\n</code></pre> <p>Create the print points of the fabrication process.</p> Source code in <code>src/compas_slicer/print_organization/scalar_field_print_organizer.py</code> <pre><code>def create_printpoints(self) -&gt; None:\n    \"\"\"Create the print points of the fabrication process.\"\"\"\n    count = 0\n    logger.info('Creating print points ...')\n    with progressbar.ProgressBar(max_value=self.slicer.number_of_points) as bar:\n\n        for _i, layer in enumerate(self.slicer.layers):\n            print_layer = PrintLayer()\n\n            for _j, path in enumerate(layer.paths):\n                print_path = PrintPath()\n\n                for k, point in enumerate(path.points):\n                    normal = utils.get_normal_of_path_on_xy_plane(k, point, path, self.slicer.mesh)\n\n                    h = self.config.avg_layer_height\n                    printpoint = PrintPoint(pt=point, layer_height=h, mesh_normal=normal)\n\n                    print_path.printpoints.append(printpoint)\n                    bar.update(count)\n                    count += 1\n\n                print_layer.paths.append(print_path)\n\n            self.printpoints.layers.append(print_layer)\n\n    # transfer gradient information to printpoints\n    transfer_mesh_attributes_to_printpoints(self.slicer.mesh, self.printpoints)\n\n    # add non-planar print data to printpoints\n    for layer in self.printpoints:\n        for path in layer:\n            for pp in path:\n                grad_norm = pp.attributes['gradient_norm']\n                grad = pp.attributes['gradient']\n                pp.distance_to_support = grad_norm\n                pp.layer_height = grad_norm\n                pp.up_vector = Vector(*normalize_vector(grad))\n                pp.frame = pp.get_frame()\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer","title":"base_print_organizer","text":""},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer","title":"BasePrintOrganizer","text":"<pre><code>BasePrintOrganizer(slicer)\n</code></pre> <p>Base class for organizing the printing process.</p> <p>This class is meant to be extended for implementing various print organizers. Do not use this class directly. Use PlanarPrintOrganizer or InterpolationPrintOrganizer.</p> <p>Attributes:</p> Name Type Description <code>slicer</code> <code>BaseSlicer</code> <p>An instance of a slicer class.</p> <code>printpoints</code> <code>PrintPointsCollection</code> <p>Collection of printpoints organized by layer and path.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def __init__(self, slicer: BaseSlicer) -&gt; None:\n    if not isinstance(slicer, BaseSlicer):\n        raise TypeError(f\"slicer must be BaseSlicer, not {type(slicer)}\")\n    logger.info(\"Print Organizer\")\n    self.slicer = slicer\n    self.printpoints = PrintPointsCollection()\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer.number_of_printpoints","title":"number_of_printpoints  <code>property</code>","text":"<pre><code>number_of_printpoints\n</code></pre> <p>Total number of printpoints.</p>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer.number_of_paths","title":"number_of_paths  <code>property</code>","text":"<pre><code>number_of_paths\n</code></pre> <p>Total number of paths.</p>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer.number_of_layers","title":"number_of_layers  <code>property</code>","text":"<pre><code>number_of_layers\n</code></pre> <p>Number of layers.</p>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer.total_length_of_paths","title":"total_length_of_paths  <code>property</code>","text":"<pre><code>total_length_of_paths\n</code></pre> <p>Total length of all paths (ignores extruder toggle).</p>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer.total_print_time","title":"total_print_time  <code>property</code>","text":"<pre><code>total_print_time\n</code></pre> <p>Total print time if velocity is defined, else None.</p>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer.printpoints_dict","title":"printpoints_dict  <code>property</code>","text":"<pre><code>printpoints_dict\n</code></pre> <p>Legacy accessor for the old dict format. Prefer using self.printpoints directly.</p>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer.create_printpoints","title":"create_printpoints  <code>abstractmethod</code>","text":"<pre><code>create_printpoints()\n</code></pre> <p>To be implemented by inheriting classes.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>@abstractmethod\ndef create_printpoints(self) -&gt; None:\n    \"\"\"To be implemented by inheriting classes.\"\"\"\n    pass\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer.printpoints_iterator","title":"printpoints_iterator","text":"<pre><code>printpoints_iterator()\n</code></pre> <p>Iterate over all printpoints.</p> <p>Yields:</p> Type Description <code>PrintPoint</code> <p>Each printpoint in the organizer.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def printpoints_iterator(self) -&gt; Generator[PrintPoint, None, None]:\n    \"\"\"Iterate over all printpoints.\n\n    Yields\n    ------\n    PrintPoint\n        Each printpoint in the organizer.\n\n    \"\"\"\n    if not self.printpoints.layers:\n        raise ValueError(\"No printpoints have been created.\")\n    yield from self.printpoints.iter_printpoints()\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer.printpoints_indices_iterator","title":"printpoints_indices_iterator","text":"<pre><code>printpoints_indices_iterator()\n</code></pre> <p>Iterate over printpoints with their indices.</p> <p>Yields:</p> Type Description <code>tuple[PrintPoint, int, int, int]</code> <p>Printpoint, layer index, path index, printpoint index.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def printpoints_indices_iterator(self) -&gt; Iterator[tuple[PrintPoint, int, int, int]]:\n    \"\"\"Iterate over printpoints with their indices.\n\n    Yields\n    ------\n    tuple[PrintPoint, int, int, int]\n        Printpoint, layer index, path index, printpoint index.\n\n    \"\"\"\n    if not self.printpoints.layers:\n        raise ValueError(\"No printpoints have been created.\")\n    yield from self.printpoints.iter_with_indices()\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer.number_of_paths_on_layer","title":"number_of_paths_on_layer","text":"<pre><code>number_of_paths_on_layer(layer_index)\n</code></pre> <p>Number of paths within a layer.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def number_of_paths_on_layer(self, layer_index: int) -&gt; int:\n    \"\"\"Number of paths within a layer.\"\"\"\n    return len(self.printpoints[layer_index])\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer.remove_duplicate_points_in_path","title":"remove_duplicate_points_in_path","text":"<pre><code>remove_duplicate_points_in_path(layer_idx, path_idx, tolerance=0.0001)\n</code></pre> <p>Remove subsequent points within a threshold distance.</p> <p>Parameters:</p> Name Type Description Default <code>layer_idx</code> <code>int</code> <p>The layer index.</p> required <code>path_idx</code> <code>int</code> <p>The path index.</p> required <code>tolerance</code> <code>float</code> <p>Distance threshold for duplicate detection.</p> <code>0.0001</code> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def remove_duplicate_points_in_path(\n    self, layer_idx: int, path_idx: int, tolerance: float = 0.0001\n) -&gt; None:\n    \"\"\"Remove subsequent points within a threshold distance.\n\n    Parameters\n    ----------\n    layer_idx : int\n        The layer index.\n    path_idx : int\n        The path index.\n    tolerance : float\n        Distance threshold for duplicate detection.\n\n    \"\"\"\n    dup_index = []\n    duplicate_ppts = []\n\n    path = self.printpoints[layer_idx][path_idx]\n    for i, printpoint in enumerate(path.printpoints[:-1]):\n        next_ppt = path.printpoints[i + 1]\n        if np.linalg.norm(np.array(printpoint.pt) - np.array(next_ppt.pt)) &lt; tolerance:\n            dup_index.append(i)\n            duplicate_ppts.append(printpoint)\n\n    if duplicate_ppts:\n        logger.warning(\n            f\"Attention! {len(duplicate_ppts)} Duplicate printpoint(s) on \"\n            f\"layer {layer_idx}, path {path_idx}, indices: {dup_index}. They will be removed.\"\n        )\n        for ppt in duplicate_ppts:\n            path.printpoints.remove(ppt)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer.get_printpoint_neighboring_items","title":"get_printpoint_neighboring_items","text":"<pre><code>get_printpoint_neighboring_items(layer_idx, path_idx, i)\n</code></pre> <p>Get neighboring printpoints.</p> <p>Parameters:</p> Name Type Description Default <code>layer_idx</code> <code>int</code> <p>The layer index.</p> required <code>path_idx</code> <code>int</code> <p>The path index.</p> required <code>i</code> <code>int</code> <p>Index of current printpoint.</p> required <p>Returns:</p> Type Description <code>list[PrintPoint | None]</code> <p>Previous and next printpoints (None if at boundary).</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def get_printpoint_neighboring_items(\n    self, layer_idx: int, path_idx: int, i: int\n) -&gt; list[PrintPoint | None]:\n    \"\"\"Get neighboring printpoints.\n\n    Parameters\n    ----------\n    layer_idx : int\n        The layer index.\n    path_idx : int\n        The path index.\n    i : int\n        Index of current printpoint.\n\n    Returns\n    -------\n    list[PrintPoint | None]\n        Previous and next printpoints (None if at boundary).\n\n    \"\"\"\n    path = self.printpoints[layer_idx][path_idx]\n    prev_pt = path[i - 1] if i &gt; 0 else None\n    next_pt = path[i + 1] if i &lt; len(path) - 1 else None\n    return [prev_pt, next_pt]\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer.printout_info","title":"printout_info","text":"<pre><code>printout_info()\n</code></pre> <p>Print information about the PrintOrganizer.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def printout_info(self) -&gt; None:\n    \"\"\"Print information about the PrintOrganizer.\"\"\"\n    ppts_attributes = {\n        key: str(type(val))\n        for key, val in self.printpoints[0][0][0].attributes.items()\n    }\n\n    logger.info(\"---- PrintOrganizer Info ----\")\n    logger.info(f\"Number of layers: {self.number_of_layers}\")\n    logger.info(f\"Number of paths: {self.number_of_paths}\")\n    logger.info(f\"Number of PrintPoints: {self.number_of_printpoints}\")\n    logger.info(\"PrintPoints attributes: \")\n    for key, val in ppts_attributes.items():\n        logger.info(f\"     {key} : {val}\")\n    logger.info(f\"Toolpath length: {self.total_length_of_paths:.0f} mm\")\n\n    print_time = self.total_print_time\n    if print_time:\n        minutes, sec = divmod(print_time, 60)\n        hour, minutes = divmod(minutes, 60)\n        logger.info(f\"Total print time: {int(hour)} hours, {int(minutes)} minutes, {int(sec)} seconds\")\n    else:\n        logger.info(\"Print Velocity has not been assigned, thus print time is not calculated.\")\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer.get_printpoint_up_vector","title":"get_printpoint_up_vector","text":"<pre><code>get_printpoint_up_vector(path, k, normal)\n</code></pre> <p>Get printpoint up-vector orthogonal to path direction and normal.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path containing the point.</p> required <code>k</code> <code>int</code> <p>Index of the point in path.points.</p> required <code>normal</code> <code>Vector</code> <p>The normal vector.</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>The up vector.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def get_printpoint_up_vector(self, path: Path, k: int, normal: Vector) -&gt; Vector:\n    \"\"\"Get printpoint up-vector orthogonal to path direction and normal.\n\n    Parameters\n    ----------\n    path : Path\n        The path containing the point.\n    k : int\n        Index of the point in path.points.\n    normal : Vector\n        The normal vector.\n\n    Returns\n    -------\n    Vector\n        The up vector.\n\n    \"\"\"\n    p = path.points[k]\n    if k &lt; len(path.points) - 1:\n        negative = False\n        other_pt = path.points[k + 1]\n    else:\n        negative = True\n        other_pt = path.points[k - 1]\n\n    diff = normalize_vector(subtract_vectors(p, other_pt))\n    up_vec = normalize_vector(cross_vectors(normal, diff))\n\n    if negative:\n        up_vec = scale_vector(up_vec, -1.0)\n    if norm_vector(up_vec) == 0:\n        up_vec = Vector(0, 0, 1)\n\n    return Vector(*up_vec)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer.output_printpoints_dict","title":"output_printpoints_dict","text":"<pre><code>output_printpoints_dict()\n</code></pre> <p>Create a flattened printpoints dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Flattened printpoints data for JSON serialization.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def output_printpoints_dict(self) -&gt; dict[int, dict[str, Any]]:\n    \"\"\"Create a flattened printpoints dictionary.\n\n    Returns\n    -------\n    dict\n        Flattened printpoints data for JSON serialization.\n\n    \"\"\"\n    data = {}\n    count = 0\n\n    for i, layer in enumerate(self.printpoints):\n        for j, path in enumerate(layer):\n            self.remove_duplicate_points_in_path(i, j)\n            for printpoint in path:\n                data[count] = printpoint.to_data()\n                count += 1\n\n    logger.info(f\"Generated {count} print points\")\n    return data\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer.output_nested_printpoints_dict","title":"output_nested_printpoints_dict","text":"<pre><code>output_nested_printpoints_dict()\n</code></pre> <p>Create a nested printpoints dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Nested printpoints data for JSON serialization.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def output_nested_printpoints_dict(self) -&gt; dict[str, dict[str, dict[int, dict[str, Any]]]]:\n    \"\"\"Create a nested printpoints dictionary.\n\n    Returns\n    -------\n    dict\n        Nested printpoints data for JSON serialization.\n\n    \"\"\"\n    data: dict[str, dict[str, dict[int, dict[str, Any]]]] = {}\n    count = 0\n\n    for i, layer in enumerate(self.printpoints):\n        layer_key = f\"layer_{i}\"\n        data[layer_key] = {}\n        for j, path in enumerate(layer):\n            path_key = f\"path_{j}\"\n            data[layer_key][path_key] = {}\n            self.remove_duplicate_points_in_path(i, j)\n            for k, printpoint in enumerate(path):\n                data[layer_key][path_key][k] = printpoint.to_data()\n                count += 1\n\n    logger.info(f\"Generated {count} print points\")\n    return data\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer.output_gcode","title":"output_gcode","text":"<pre><code>output_gcode(config=None)\n</code></pre> <p>Generate G-code text.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>GcodeConfig | None</code> <p>G-code configuration. If None, uses defaults.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>G-code text.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def output_gcode(self, config: GcodeConfig | None = None) -&gt; str:\n    \"\"\"Generate G-code text.\n\n    Parameters\n    ----------\n    config : GcodeConfig | None\n        G-code configuration. If None, uses defaults.\n\n    Returns\n    -------\n    str\n        G-code text.\n\n    \"\"\"\n    return create_gcode_text(self, config)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.base_print_organizer.BasePrintOrganizer.get_printpoints_attribute","title":"get_printpoints_attribute","text":"<pre><code>get_printpoints_attribute(attr_name)\n</code></pre> <p>Get a list of attribute values from all printpoints.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>Name of the attribute.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Attribute values from all printpoints.</p> Source code in <code>src/compas_slicer/print_organization/base_print_organizer.py</code> <pre><code>def get_printpoints_attribute(self, attr_name: str) -&gt; list[Any]:\n    \"\"\"Get a list of attribute values from all printpoints.\n\n    Parameters\n    ----------\n    attr_name : str\n        Name of the attribute.\n\n    Returns\n    -------\n    list\n        Attribute values from all printpoints.\n\n    \"\"\"\n    attr_values = []\n    for pp in self.printpoints.iter_printpoints():\n        if attr_name not in pp.attributes:\n            raise KeyError(f\"Attribute '{attr_name}' not in printpoint.attributes\")\n        attr_values.append(pp.attributes[attr_name])\n    return attr_values\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.curved_print_organization","title":"curved_print_organization","text":""},{"location":"api/print_organization/#compas_slicer.print_organization.curved_print_organization.BaseBoundary","title":"BaseBoundary","text":"<pre><code>BaseBoundary(mesh, points, override_vector=None)\n</code></pre> <p>The BaseBoundary is like a fake initial layer that supports the first path of the segment. This is useful, because for our computations we need to have a support layer for evey path. The first path has as support the Base Boundary, and every other path has its previous path.</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>points</code> <code>override_vector</code> Source code in <code>src/compas_slicer/print_organization/curved_print_organization/base_boundary.py</code> <pre><code>def __init__(\n    self, mesh: Mesh, points: list[Point], override_vector: Vector | None = None\n) -&gt; None:\n    self.mesh = mesh\n    self.points = points\n    self.override_vector = override_vector\n    closest_fks, projected_pts = utils.pull_pts_to_mesh_faces(self.mesh, list(self.points))\n    self.normals = [Vector(*self.mesh.face_normal(fkey)) for fkey in closest_fks]\n\n    if self.override_vector:\n        self.up_vectors = [self.override_vector for p in self.points]\n    else:\n        self.up_vectors = self.get_up_vectors()\n\n    self.printpoints = [PrintPoint(pt=pt,  # Create fake print points\n                                   layer_height=1.0,\n                                   mesh_normal=self.normals[i]) for i, pt in enumerate(self.points)]\n\n    for i, pp in enumerate(self.printpoints):\n        pp.up_vector = self.up_vectors[i]\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.curved_print_organization.BaseBoundary.get_up_vectors","title":"get_up_vectors","text":"<pre><code>get_up_vectors()\n</code></pre> <p>Finds the up_vectors of each point of the boundary. A smoothing step is also included.</p> Source code in <code>src/compas_slicer/print_organization/curved_print_organization/base_boundary.py</code> <pre><code>def get_up_vectors(self) -&gt; list[Vector]:\n    \"\"\" Finds the up_vectors of each point of the boundary. A smoothing step is also included. \"\"\"\n    up_vectors = []\n    for i, p in enumerate(self.points):\n        v1 = Vector.from_start_end(p, self.points[(i + 1) % len(self.points)])\n        cross = v1.cross(self.normals[i])\n        v = Vector(*normalize_vector(cross))\n        if v[2] &lt; 0:\n            v.scale(-1)\n        up_vectors.append(v)\n    up_vectors = utils.smooth_vectors(up_vectors, strength=0.4, iterations=3)\n    return up_vectors\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.curved_print_organization.BaseBoundary.to_data","title":"to_data","text":"<pre><code>to_data()\n</code></pre> <p>Returns a dictionary with the data of the class.</p> Source code in <code>src/compas_slicer/print_organization/curved_print_organization/base_boundary.py</code> <pre><code>def to_data(self) -&gt; dict[str, Any]:\n    \"\"\" Returns a dictionary with the data of the class. \"\"\"\n    return {\"points\": utils.point_list_to_dict(self.points),\n            \"up_vectors\": utils.point_list_to_dict(self.up_vectors)}\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.curved_print_organization.base_boundary","title":"base_boundary","text":""},{"location":"api/print_organization/#compas_slicer.print_organization.curved_print_organization.base_boundary.BaseBoundary","title":"BaseBoundary","text":"<pre><code>BaseBoundary(mesh, points, override_vector=None)\n</code></pre> <p>The BaseBoundary is like a fake initial layer that supports the first path of the segment. This is useful, because for our computations we need to have a support layer for evey path. The first path has as support the Base Boundary, and every other path has its previous path.</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>points</code> <code>override_vector</code> Source code in <code>src/compas_slicer/print_organization/curved_print_organization/base_boundary.py</code> <pre><code>def __init__(\n    self, mesh: Mesh, points: list[Point], override_vector: Vector | None = None\n) -&gt; None:\n    self.mesh = mesh\n    self.points = points\n    self.override_vector = override_vector\n    closest_fks, projected_pts = utils.pull_pts_to_mesh_faces(self.mesh, list(self.points))\n    self.normals = [Vector(*self.mesh.face_normal(fkey)) for fkey in closest_fks]\n\n    if self.override_vector:\n        self.up_vectors = [self.override_vector for p in self.points]\n    else:\n        self.up_vectors = self.get_up_vectors()\n\n    self.printpoints = [PrintPoint(pt=pt,  # Create fake print points\n                                   layer_height=1.0,\n                                   mesh_normal=self.normals[i]) for i, pt in enumerate(self.points)]\n\n    for i, pp in enumerate(self.printpoints):\n        pp.up_vector = self.up_vectors[i]\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.curved_print_organization.base_boundary.BaseBoundary.get_up_vectors","title":"get_up_vectors","text":"<pre><code>get_up_vectors()\n</code></pre> <p>Finds the up_vectors of each point of the boundary. A smoothing step is also included.</p> Source code in <code>src/compas_slicer/print_organization/curved_print_organization/base_boundary.py</code> <pre><code>def get_up_vectors(self) -&gt; list[Vector]:\n    \"\"\" Finds the up_vectors of each point of the boundary. A smoothing step is also included. \"\"\"\n    up_vectors = []\n    for i, p in enumerate(self.points):\n        v1 = Vector.from_start_end(p, self.points[(i + 1) % len(self.points)])\n        cross = v1.cross(self.normals[i])\n        v = Vector(*normalize_vector(cross))\n        if v[2] &lt; 0:\n            v.scale(-1)\n        up_vectors.append(v)\n    up_vectors = utils.smooth_vectors(up_vectors, strength=0.4, iterations=3)\n    return up_vectors\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.curved_print_organization.base_boundary.BaseBoundary.to_data","title":"to_data","text":"<pre><code>to_data()\n</code></pre> <p>Returns a dictionary with the data of the class.</p> Source code in <code>src/compas_slicer/print_organization/curved_print_organization/base_boundary.py</code> <pre><code>def to_data(self) -&gt; dict[str, Any]:\n    \"\"\" Returns a dictionary with the data of the class. \"\"\"\n    return {\"points\": utils.point_list_to_dict(self.points),\n            \"up_vectors\": utils.point_list_to_dict(self.up_vectors)}\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.interpolation_print_organizer","title":"interpolation_print_organizer","text":""},{"location":"api/print_organization/#compas_slicer.print_organization.interpolation_print_organizer.InterpolationPrintOrganizer","title":"InterpolationPrintOrganizer","text":"<pre><code>InterpolationPrintOrganizer(slicer, config=None, DATA_PATH='.')\n</code></pre> <p>               Bases: <code>BasePrintOrganizer</code></p> <p>Organize the printing process for non-planar contours.</p> <p>Attributes:</p> Name Type Description <code>slicer</code> <code>InterpolationSlicer</code> <p>An instance of InterpolationSlicer.</p> <code>config</code> <code>InterpolationConfig</code> <p>Interpolation configuration.</p> <code>DATA_PATH</code> <code>str | Path</code> <p>Data directory path.</p> <code>vertical_layers</code> <code>list[VerticalLayer]</code> <p>Vertical layers from slicer.</p> <code>horizontal_layers</code> <code>list[Layer]</code> <p>Horizontal layers from slicer.</p> <code>base_boundaries</code> <code>list[BaseBoundary]</code> <p>Base boundaries for each vertical layer.</p> Source code in <code>src/compas_slicer/print_organization/interpolation_print_organizer.py</code> <pre><code>def __init__(\n    self,\n    slicer: InterpolationSlicer,\n    config: InterpolationConfig | None = None,\n    DATA_PATH: str | FilePath = \".\",\n) -&gt; None:\n    from compas_slicer.slicers import InterpolationSlicer\n\n    if not isinstance(slicer, InterpolationSlicer):\n        raise TypeError('Please provide an InterpolationSlicer')\n    BasePrintOrganizer.__init__(self, slicer)\n    self.DATA_PATH = DATA_PATH\n    self.OUTPUT_PATH = utils.get_output_directory(DATA_PATH)\n    self.config = config if config else InterpolationConfig()\n\n    self.vertical_layers = slicer.vertical_layers\n    self.horizontal_layers = slicer.horizontal_layers\n    if len(self.vertical_layers) + len(self.horizontal_layers) != len(slicer.layers):\n        raise ValueError(\n            f\"Layer count mismatch: {len(self.vertical_layers)} vertical + \"\n            f\"{len(self.horizontal_layers)} horizontal != {len(slicer.layers)} total\"\n        )\n\n    if len(self.horizontal_layers) &gt; 0:\n        if len(self.horizontal_layers) != 1:\n            raise ValueError(\"Only one brim horizontal layer is currently supported.\")\n        if not self.horizontal_layers[0].is_brim:\n            raise ValueError(\"Only one brim horizontal layer is currently supported.\")\n        logger.info('Slicer has one horizontal brim layer.')\n\n    # topological sorting of vertical layers depending on their connectivity\n    self.topo_sort_graph: topo_sort.SegmentsDirectedGraph | None = None\n    if len(self.vertical_layers) &gt; 1:\n        try:\n            self.topological_sorting()\n        except AssertionError:\n            logger.exception(\"topology sorting failed\\n\")\n            logger.critical(\"integrity of the output data \")\n            # TODO: perhaps its better to be even more explicit and add a\n            #  FAILED-timestamp.txt file?\n    self.selected_order: list[int] | None = None\n\n    # creation of one base boundary per vertical_layer\n    self.base_boundaries: list[BaseBoundary] = self.create_base_boundaries()\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.interpolation_print_organizer.InterpolationPrintOrganizer.topological_sorting","title":"topological_sorting","text":"<pre><code>topological_sorting()\n</code></pre> <p>Create directed graph of parts with connectivity.</p> <p>Creates a directed graph where each part's connectivity reflects which other parts it lies on and which other parts lie on it.</p> Source code in <code>src/compas_slicer/print_organization/interpolation_print_organizer.py</code> <pre><code>def topological_sorting(self) -&gt; None:\n    \"\"\"Create directed graph of parts with connectivity.\n\n    Creates a directed graph where each part's connectivity reflects which\n    other parts it lies on and which other parts lie on it.\n\n    \"\"\"\n    avg_layer_height = self.config.avg_layer_height\n    self.topo_sort_graph = topo_sort.SegmentsDirectedGraph(self.slicer.mesh, self.vertical_layers,\n                                                           4 * avg_layer_height, DATA_PATH=self.DATA_PATH)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.interpolation_print_organizer.InterpolationPrintOrganizer.create_base_boundaries","title":"create_base_boundaries","text":"<pre><code>create_base_boundaries()\n</code></pre> <p>Create one BaseBoundary per vertical_layer.</p> Source code in <code>src/compas_slicer/print_organization/interpolation_print_organizer.py</code> <pre><code>def create_base_boundaries(self) -&gt; list[BaseBoundary]:\n    \"\"\"Create one BaseBoundary per vertical_layer.\"\"\"\n    bs: list[BaseBoundary] = []\n    root_vs = utils.get_mesh_vertex_coords_with_attribute(self.slicer.mesh, 'boundary', 1)\n    root_boundary = BaseBoundary(self.slicer.mesh, [Point(*v) for v in root_vs])\n\n    if len(self.vertical_layers) &gt; 1 and self.topo_sort_graph is not None:\n        for i, _vertical_layer in enumerate(self.vertical_layers):\n            parents_of_current_node = self.topo_sort_graph.get_parents_of_node(i)\n            if len(parents_of_current_node) == 0:\n                boundary = root_boundary\n            else:\n                boundary_pts = []\n                for parent_index in parents_of_current_node:\n                    parent = self.vertical_layers[parent_index]\n                    boundary_pts.extend(parent.paths[-1].points)\n                boundary = BaseBoundary(self.slicer.mesh, boundary_pts)\n            bs.append(boundary)\n    else:\n        bs.append(root_boundary)\n\n    # save intermediary outputs\n    b_data = {i: b.to_data() for i, b in enumerate(bs)}\n    utils.save_to_json(b_data, self.OUTPUT_PATH, 'boundaries.json')\n\n    return bs\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.interpolation_print_organizer.InterpolationPrintOrganizer.create_printpoints","title":"create_printpoints","text":"<pre><code>create_printpoints()\n</code></pre> <p>Create the print points of the fabrication process.</p> <p>Based on the directed graph, select one topological order. From each path collection in that order, copy PrintPoints in the correct order.</p> Source code in <code>src/compas_slicer/print_organization/interpolation_print_organizer.py</code> <pre><code>def create_printpoints(self) -&gt; None:\n    \"\"\"Create the print points of the fabrication process.\n\n    Based on the directed graph, select one topological order.\n    From each path collection in that order, copy PrintPoints in the correct order.\n\n    \"\"\"\n    current_layer_index = 0\n\n    # (1) --- First add the printpoints of the horizontal brim layer (first layer of print)\n    if len(self.horizontal_layers) &gt; 0:  # first add horizontal brim layers\n        print_layer = PrintLayer()\n        paths = self.horizontal_layers[0].paths\n        for _j, path in enumerate(paths):\n            print_path = PrintPath(printpoints=[\n                PrintPoint(pt=point, layer_height=self.config.avg_layer_height,\n                           mesh_normal=utils.get_normal_of_path_on_xy_plane(k, point, path, self.slicer.mesh))\n                for k, point in enumerate(path.points)\n            ])\n            print_layer.paths.append(print_path)\n        self.printpoints.layers.append(print_layer)\n        current_layer_index += 1\n    else:\n        # Add empty first layer placeholder if no horizontal layers\n        pass\n\n    # (2) --- Select order of vertical layers\n    if len(self.vertical_layers) &gt; 1:  # then you need to select one topological order\n\n        if not self.topo_sort_graph:\n            logger.error(\"no topology graph found, cannnot set the order of vertical layers\")\n            self.selected_order = [0]\n        else:\n            all_orders = self.topo_sort_graph.get_all_topological_orders()\n            self.selected_order = all_orders[0]  # TODO: add more elaborate selection strategy\n    else:\n        self.selected_order = [0]  # there is only one segment, only this option\n\n    # (3) --- Then create the printpoints of all the vertical layers in the selected order\n    if self.selected_order is None:\n        raise RuntimeError(\"selected_order must be set before creating printpoints\")\n    for _index, i in enumerate(self.selected_order):\n        layer = self.vertical_layers[i]\n        print_layer = self.get_layer_ppts(layer, self.base_boundaries[i])\n        self.printpoints.layers.append(print_layer)\n        current_layer_index += 1\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.interpolation_print_organizer.InterpolationPrintOrganizer.get_layer_ppts","title":"get_layer_ppts","text":"<pre><code>get_layer_ppts(layer, base_boundary)\n</code></pre> <p>Create the PrintPoints of a single layer.</p> Source code in <code>src/compas_slicer/print_organization/interpolation_print_organizer.py</code> <pre><code>def get_layer_ppts(self, layer: VerticalLayer, base_boundary: BaseBoundary) -&gt; PrintLayer:\n    \"\"\"Create the PrintPoints of a single layer.\"\"\"\n    max_layer_height = self.config.max_layer_height\n    min_layer_height = self.config.min_layer_height\n    avg_layer_height = self.config.avg_layer_height\n\n    all_pts = [pt for path in layer.paths for pt in path.points]\n    closest_fks, projected_pts = utils.pull_pts_to_mesh_faces(self.slicer.mesh, all_pts)\n    normals = [Vector(*self.slicer.mesh.face_normal(fkey)) for fkey in closest_fks]\n\n    count = 0\n    support_polyline_pts = base_boundary.points  # Start with base boundary\n\n    print_layer = PrintLayer()\n    for _i, path in enumerate(layer.paths):\n        # Batch query: find closest points for all points in this path at once\n        closest_pts, distances = _batch_closest_points_on_polyline(\n            path.points, support_polyline_pts\n        )\n\n        print_path = PrintPath()\n        for k, p in enumerate(path.points):\n            cp = closest_pts[k]\n            d = distances[k]\n\n            normal = normals[count]\n            ppt = PrintPoint(pt=p, layer_height=avg_layer_height, mesh_normal=normal)\n\n            ppt.closest_support_pt = Point(cp[0], cp[1], cp[2])\n            ppt.distance_to_support = d\n            ppt.layer_height = max(min(d, max_layer_height), min_layer_height)\n            ppt.up_vector = self.get_printpoint_up_vector(path, k, normal)\n            if dot_vectors(subtract_vectors(p, ppt.closest_support_pt), ppt.up_vector) &lt; 0:\n                ppt.up_vector = Vector(*scale_vector(ppt.up_vector, -1))\n            ppt.frame = ppt.get_frame()\n\n            print_path.printpoints.append(ppt)\n            count += 1\n\n        print_layer.paths.append(print_path)\n        support_polyline_pts = path.points  # Next path checks against this one\n\n    return print_layer\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.planar_print_organizer","title":"planar_print_organizer","text":""},{"location":"api/print_organization/#compas_slicer.print_organization.planar_print_organizer.PlanarPrintOrganizer","title":"PlanarPrintOrganizer","text":"<pre><code>PlanarPrintOrganizer(slicer)\n</code></pre> <p>               Bases: <code>BasePrintOrganizer</code></p> <p>Organize the printing process for planar contours.</p> <p>Attributes:</p> Name Type Description <code>slicer</code> <code>PlanarSlicer</code> <p>An instance of PlanarSlicer.</p> Source code in <code>src/compas_slicer/print_organization/planar_print_organizer.py</code> <pre><code>def __init__(self, slicer: PlanarSlicer) -&gt; None:\n    from compas_slicer.slicers import PlanarSlicer\n\n    if not isinstance(slicer, PlanarSlicer):\n        raise TypeError('Please provide a PlanarSlicer')\n    BasePrintOrganizer.__init__(self, slicer)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.planar_print_organizer.PlanarPrintOrganizer.create_printpoints","title":"create_printpoints","text":"<pre><code>create_printpoints(generate_mesh_normals=True)\n</code></pre> <p>Create the print points of the fabrication process.</p> <p>Parameters:</p> Name Type Description Default <code>generate_mesh_normals</code> <code>bool</code> <p>If True, compute mesh normals. If False, use Vector(0, 1, 0).</p> <code>True</code> Source code in <code>src/compas_slicer/print_organization/planar_print_organizer.py</code> <pre><code>def create_printpoints(self, generate_mesh_normals: bool = True) -&gt; None:\n    \"\"\"Create the print points of the fabrication process.\n\n    Parameters\n    ----------\n    generate_mesh_normals : bool\n        If True, compute mesh normals. If False, use Vector(0, 1, 0).\n\n    \"\"\"\n\n    count = 0\n    logger.info('Creating print points ...')\n    with progressbar.ProgressBar(max_value=self.slicer.number_of_points) as bar:\n\n        if generate_mesh_normals:\n            logger.info('Generating mesh normals ...')\n            # fast method for getting the closest mesh normals to all the printpoints\n            all_pts = [pt for layer in self.slicer.layers for path in layer.paths for pt in path.points]\n            closest_fks, projected_pts = utils.pull_pts_to_mesh_faces(self.slicer.mesh, all_pts)\n            normals = [Vector(*self.slicer.mesh.face_normal(fkey)) for fkey in closest_fks]\n\n        for _i, layer in enumerate(self.slicer.layers):\n            print_layer = PrintLayer()\n\n            for _j, path in enumerate(layer.paths):\n                print_path = PrintPath()\n\n                for k, point in enumerate(path.points):\n\n                    n = normals[count] if generate_mesh_normals else Vector(0, 1, 0)\n                    layer_h = self.slicer.layer_height if self.slicer.layer_height else 2.0\n                    printpoint = PrintPoint(pt=point, layer_height=layer_h, mesh_normal=n)\n\n                    if layer.is_brim or layer.is_raft:\n                        printpoint.up_vector = Vector(0, 0, 1)\n                    else:\n                        printpoint.up_vector = self.get_printpoint_up_vector(path, k, n)\n\n                    print_path.printpoints.append(printpoint)\n                    bar.update(count)\n                    count += 1\n\n                print_layer.paths.append(print_path)\n\n            self.printpoints.layers.append(print_layer)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities","title":"print_organization_utilities","text":""},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.GcodeBuilder","title":"GcodeBuilder","text":"<pre><code>GcodeBuilder()\n</code></pre> <p>Builder for constructing G-code output efficiently.</p> <p>Uses a list internally and joins at the end for better performance than repeated string concatenation.</p> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/gcode.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._lines: list[str] = []\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.GcodeBuilder.comment","title":"comment","text":"<pre><code>comment(text)\n</code></pre> <p>Add a comment line.</p> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/gcode.py</code> <pre><code>def comment(self, text: str) -&gt; None:\n    \"\"\"Add a comment line.\"\"\"\n    self._lines.append(f\";{text}\")\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.GcodeBuilder.cmd","title":"cmd","text":"<pre><code>cmd(gcode, comment='')\n</code></pre> <p>Add a G-code command with optional inline comment.</p> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/gcode.py</code> <pre><code>def cmd(self, gcode: str, comment: str = \"\") -&gt; None:\n    \"\"\"Add a G-code command with optional inline comment.\"\"\"\n    if comment:\n        self._lines.append(f\"{gcode:&lt;30} ;{comment}\")\n    else:\n        self._lines.append(gcode)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.GcodeBuilder.blank","title":"blank","text":"<pre><code>blank()\n</code></pre> <p>Add a blank line.</p> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/gcode.py</code> <pre><code>def blank(self) -&gt; None:\n    \"\"\"Add a blank line.\"\"\"\n    self._lines.append(\"\")\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.GcodeBuilder.build","title":"build","text":"<pre><code>build()\n</code></pre> <p>Return the complete G-code as a string.</p> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/gcode.py</code> <pre><code>def build(self) -&gt; str:\n    \"\"\"Return the complete G-code as a string.\"\"\"\n    return \"\\n\".join(self._lines)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.set_blend_radius","title":"set_blend_radius","text":"<pre><code>set_blend_radius(print_organizer, d_fillet=10.0, buffer=0.3)\n</code></pre> <p>Sets the blend radius (filleting) for the robotic motion.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>d_fillet</code> <code>float</code> <p>Value to attempt to fillet with. Defaults to 10 mm.</p> <code>10.0</code> <code>buffer</code> <code>float</code> <p>Buffer to make sure that the blend radius is never too big. Defaults to 0.3.</p> <code>0.3</code> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/blend_radius.py</code> <pre><code>def set_blend_radius(\n    print_organizer: BasePrintOrganizer, d_fillet: float = 10.0, buffer: float = 0.3\n) -&gt; None:\n    \"\"\"Sets the blend radius (filleting) for the robotic motion.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.slicers.BasePrintOrganizer`\n    d_fillet: float\n        Value to attempt to fillet with. Defaults to 10 mm.\n    buffer: float\n        Buffer to make sure that the blend radius is never too big.\n        Defaults to 0.3.\n    \"\"\"\n\n    logger.info(\"Setting blend radius\")\n\n    extruder_state: bool | None = None\n\n    for printpoint, i, j, k in print_organizer.printpoints_indices_iterator():\n        neighboring_items = print_organizer.get_printpoint_neighboring_items(i, j, k)\n\n        if not printpoint.wait_time:\n\n            # if the extruder_toggle changes, it must be a new path and therefore the blend radius should be 0\n            if extruder_state != printpoint.extruder_toggle:\n                extruder_state = printpoint.extruder_toggle\n                radius = 0.0\n\n            else:\n\n                radius = d_fillet\n                if neighboring_items[0]:\n                    radius = min(radius, norm_vector(Vector.from_start_end(neighboring_items[0].pt, printpoint.pt)) * buffer)\n\n                if neighboring_items[1]:\n                    radius = min(radius, norm_vector(Vector.from_start_end(neighboring_items[1].pt, printpoint.pt)) * buffer)\n\n                radius = round(radius, 5)\n\n        else:\n            radius = 0.0  # 0.0 blend radius for points where the robot will pause and wait\n\n        printpoint.blend_radius = radius\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.smooth_printpoint_attribute","title":"smooth_printpoint_attribute","text":"<pre><code>smooth_printpoint_attribute(print_organizer, iterations, strength, get_attr_value, set_attr_value)\n</code></pre> <p>Iterative smoothing of the printpoints attribute. The attribute is accessed using the function 'get_attr_value(ppt)', and is set using the function 'set_attr_value(ppt, v)'. All attributes are smoothened continuously (i.e. as if their printpoints belong into one long uninterrupted path) For examples of how to use this function look at 'smooth_printpoints_layer_heights' and 'smooth_printpoints_up_vectors' below. The smoothing is happening by taking an average of the previous and next point attributes, and combining them with the current value of the print point; On every iteration: new_val = (0.5*(neighbor_left_val + neighbor_right_attr)) * strength - current_val * (1-strength)</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>iterations</code> <code>int</code> required <code>strength</code> <code>float</code> <p>the current value with the average of the two neighbors on every interation stop. On each iteration: new_val = (0.5*(neighbor_left_val + neighbor_right_attr)) * strength - current_val * (1-strength)</p> required <code>get_attr_value</code> <code>Callable[[PrintPoint], Any]</code> required <code>set_attr_value</code> <code>Callable[[PrintPoint, Any], None]</code> required Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/data_smoothing.py</code> <pre><code>def smooth_printpoint_attribute(\n    print_organizer: BasePrintOrganizer,\n    iterations: int,\n    strength: float,\n    get_attr_value: Callable[[PrintPoint], Any],\n    set_attr_value: Callable[[PrintPoint, Any], None],\n) -&gt; None:\n    \"\"\"\n    Iterative smoothing of the printpoints attribute.\n    The attribute is accessed using the function 'get_attr_value(ppt)', and is set using the function\n    'set_attr_value(ppt, v)'.\n    All attributes are smoothened continuously (i.e. as if their printpoints belong into one long uninterrupted path)\n    For examples of how to use this function look at 'smooth_printpoints_layer_heights' and\n    'smooth_printpoints_up_vectors' below.\n    The smoothing is happening by taking an average of the previous and next point attributes, and combining them with\n    the current value of the print point; On every iteration:\n    new_val = (0.5*(neighbor_left_val + neighbor_right_attr)) * strength - current_val * (1-strength)\n\n    Parameters\n    ----------\n    print_organizer: :class: 'compas_slicer.print_organization.BasePrintOrganizer', or other class inheriting from it.\n    iterations: int, smoothing iterations\n    strength: float. in the range [0.0 - 1.0]. 0.0 corresponds to no smoothing at all, 1.0 corresponds to overwriting\n        the current value with the average of the two neighbors on every interation stop. On each iteration:\n        new_val = (0.5*(neighbor_left_val + neighbor_right_attr)) * strength - current_val * (1-strength)\n    get_attr_value: function that returns an attribute of a printpoint, get_attr_value(ppt)\n    set_attr_value: function that sets an attribute of a printpoint, set_attr_value(ppt, new_value)\n    \"\"\"\n\n    # first smoothen the values\n    for ppt in print_organizer.printpoints_iterator():\n        if get_attr_value(ppt) is None:\n            raise ValueError('The attribute you are trying to smooth has not been assigned a value')\n\n    attrs = np.array([get_attr_value(ppt) for ppt in print_organizer.printpoints_iterator()])\n\n    # Vectorized smoothing: use numpy slicing instead of per-element loop\n    for _ in range(iterations):\n        # mid = 0.5 * (attrs[i-1] + attrs[i+1]) for interior points\n        mid = 0.5 * (attrs[:-2] + attrs[2:])  # shape: (n-2,)\n        # new_val = mid * strength + attrs[1:-1] * (1 - strength)\n        attrs[1:-1] = mid * strength + attrs[1:-1] * (1 - strength)\n\n    # Assign the smoothened values back to the printpoints\n    for i, ppt in enumerate(print_organizer.printpoints_iterator()):\n        val = attrs[i]\n        # Convert back from numpy type if needed\n        set_attr_value(ppt, val.tolist() if hasattr(val, 'tolist') else float(val))\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.smooth_printpoints_layer_heights","title":"smooth_printpoints_layer_heights","text":"<pre><code>smooth_printpoints_layer_heights(print_organizer, iterations, strength)\n</code></pre> <p>This function is an example for how the 'smooth_printpoint_attribute' function can be used.</p> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/data_smoothing.py</code> <pre><code>def smooth_printpoints_layer_heights(\n    print_organizer: BasePrintOrganizer, iterations: int, strength: float\n) -&gt; None:\n    \"\"\" This function is an example for how the 'smooth_printpoint_attribute' function can be used. \"\"\"\n\n    def get_ppt_layer_height(printpoint):\n        return printpoint.layer_height  # get value\n\n    def set_ppt_layer_height(printpoint, v):\n        printpoint.layer_height = v  # set value\n\n    smooth_printpoint_attribute(print_organizer, iterations, strength, get_ppt_layer_height, set_ppt_layer_height)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.smooth_printpoints_up_vectors","title":"smooth_printpoints_up_vectors","text":"<pre><code>smooth_printpoints_up_vectors(print_organizer, iterations, strength)\n</code></pre> <p>This function is an example for how the 'smooth_printpoint_attribute' function can be used.</p> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/data_smoothing.py</code> <pre><code>def smooth_printpoints_up_vectors(\n    print_organizer: BasePrintOrganizer, iterations: int, strength: float\n) -&gt; None:\n    \"\"\" This function is an example for how the 'smooth_printpoint_attribute' function can be used. \"\"\"\n\n    def get_ppt_up_vec(printpoint):\n        return printpoint.up_vector  # get value\n\n    def set_ppt_up_vec(printpoint, v):\n        # Convert list back to Vector for proper serialization\n        printpoint.up_vector = Vector(*v) if isinstance(v, list) else v\n\n    smooth_printpoint_attribute(print_organizer, iterations, strength, get_ppt_up_vec, set_ppt_up_vec)\n    # finally update any values in the printpoints that are affected by the changed attribute\n    for ppt in print_organizer.printpoints_iterator():\n        ppt.frame = ppt.get_frame()\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.set_extruder_toggle","title":"set_extruder_toggle","text":"<pre><code>set_extruder_toggle(print_organizer, slicer)\n</code></pre> <p>Sets the extruder_toggle value for the printpoints.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>slicer</code> <code>BaseSlicer</code> required Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/extruder_toggle.py</code> <pre><code>def set_extruder_toggle(print_organizer: BasePrintOrganizer, slicer: BaseSlicer) -&gt; None:\n    \"\"\"Sets the extruder_toggle value for the printpoints.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.print_organization.BasePrintOrganizer`\n    slicer: :class:`compas.slicers.BaseSlicer`\n    \"\"\"\n\n    logger.info(\"Setting extruder toggle\")\n\n    for i, layer in enumerate(slicer.layers):\n        is_vertical_layer = isinstance(layer, compas_slicer.geometry.VerticalLayer)\n        is_brim_layer = layer.is_brim\n\n        for j, path in enumerate(layer.paths):\n            is_closed_path = path.is_closed\n\n            # --- decide if the path should be interrupted at the end\n            interrupt_path = False\n\n            if not is_closed_path:\n                interrupt_path = True\n                # open paths should always be interrupted\n\n            if not is_vertical_layer and len(layer.paths) &gt; 1:\n                interrupt_path = True\n                # horizontal layers with multiple paths should be interrupted so that the extruder\n                # can travel from one path to the other, exception is added for the brim layers\n                if is_brim_layer and (j + 1) % layer.number_of_brim_offsets != 0:\n                    interrupt_path = False\n\n            if is_vertical_layer and j == len(layer.paths) - 1:\n                interrupt_path = True\n                # the last path of a vertical layer should be interrupted\n\n            if i &lt; len(slicer.layers)-1 and not slicer.layers[i+1].paths[0].is_closed:\n                interrupt_path = True\n\n            # --- create extruder toggles\n            try:\n                path_printpoints = print_organizer.printpoints[i][j]\n            except (KeyError, IndexError):\n                logger.exception(f\"no path found for layer {i}\")\n            else:\n                for k, printpoint in enumerate(path_printpoints):\n\n                    if interrupt_path:\n                        if k == len(path_printpoints) - 1:\n                            printpoint.extruder_toggle = False\n                        else:\n                            printpoint.extruder_toggle = True\n                    else:\n                        printpoint.extruder_toggle = True\n\n    # set extruder toggle of last print point to false\n    try:\n        print_organizer.printpoints[-1][-1][-1].extruder_toggle = False\n    except (KeyError, IndexError) as e:\n        logger.exception(e)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.override_extruder_toggle","title":"override_extruder_toggle","text":"<pre><code>override_extruder_toggle(print_organizer, override_value)\n</code></pre> <p>Overrides the extruder_toggle value for the printpoints with a user-defined value.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>override_value</code> <code>bool</code> <p>Value to override the extruder_toggle values with.</p> required Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/extruder_toggle.py</code> <pre><code>def override_extruder_toggle(print_organizer: BasePrintOrganizer, override_value: bool) -&gt; None:\n    \"\"\"Overrides the extruder_toggle value for the printpoints with a user-defined value.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas.print_organization.BasePrintOrganizer`\n    override_value: bool\n        Value to override the extruder_toggle values with.\n\n    \"\"\"\n    if not isinstance(override_value, bool):\n        raise TypeError(\"Override value must be of type bool\")\n    for printpoint in print_organizer.printpoints_iterator():\n        printpoint.extruder_toggle = override_value\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.check_assigned_extruder_toggle","title":"check_assigned_extruder_toggle","text":"<pre><code>check_assigned_extruder_toggle(print_organizer)\n</code></pre> <p>Checks that all the printpoints have an assigned extruder toggle.</p> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/extruder_toggle.py</code> <pre><code>def check_assigned_extruder_toggle(print_organizer: BasePrintOrganizer) -&gt; bool:\n    \"\"\" Checks that all the printpoints have an assigned extruder toggle. \"\"\"\n    all_toggles_assigned = True\n    for printpoint in print_organizer.printpoints_iterator():\n        if printpoint.extruder_toggle is None:\n            all_toggles_assigned = False\n    return all_toggles_assigned\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.create_gcode_text","title":"create_gcode_text","text":"<pre><code>create_gcode_text(print_organizer, config=None)\n</code></pre> <p>Create G-code text from organized print points.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> <p>The print organizer containing printpoints.</p> required <code>config</code> <code>GcodeConfig | None</code> <p>G-code configuration. If None, uses defaults.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Complete G-code file content.</p> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/gcode.py</code> <pre><code>def create_gcode_text(\n    print_organizer: BasePrintOrganizer, config: GcodeConfig | None = None\n) -&gt; str:\n    \"\"\"Create G-code text from organized print points.\n\n    Parameters\n    ----------\n    print_organizer : BasePrintOrganizer\n        The print organizer containing printpoints.\n    config : GcodeConfig | None\n        G-code configuration. If None, uses defaults.\n\n    Returns\n    -------\n    str\n        Complete G-code file content.\n\n    \"\"\"\n    config = config or GcodeConfig()\n    logger.info(\"Generating G-code\")\n\n    gb = GcodeBuilder()\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    _write_header(gb, config, timestamp)\n    _write_purge_line(gb, config)\n    final_z = _write_toolpath(gb, print_organizer, config)\n    _write_footer(gb, config, final_z)\n\n    return gb.build()\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.set_linear_velocity_constant","title":"set_linear_velocity_constant","text":"<pre><code>set_linear_velocity_constant(print_organizer, v=25.0)\n</code></pre> <p>Sets the linear velocity parameter of the printpoints depending on the selected type.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>v</code> <code>float</code> <code>25.0</code> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/linear_velocity.py</code> <pre><code>def set_linear_velocity_constant(print_organizer: BasePrintOrganizer, v: float = 25.0) -&gt; None:\n    \"\"\"Sets the linear velocity parameter of the printpoints depending on the selected type.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.print_organization.BasePrintOrganizer`\n    v:  float. Velocity value (in mm/s) to set for printpoints. Defaults to 25 mm/s.\n    \"\"\"\n\n    logger.info(\"Setting constant linear velocity\")\n    for printpoint in print_organizer.printpoints_iterator():\n        printpoint.velocity = v\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.set_linear_velocity_per_layer","title":"set_linear_velocity_per_layer","text":"<pre><code>set_linear_velocity_per_layer(print_organizer, per_layer_velocities)\n</code></pre> <p>Sets the linear velocity parameter of the printpoints depending on the selected type.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>per_layer_velocities</code> <code>list[float]</code> <p>A list of velocities (floats) with equal length to the number of layers.</p> required Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/linear_velocity.py</code> <pre><code>def set_linear_velocity_per_layer(\n    print_organizer: BasePrintOrganizer, per_layer_velocities: list[float]\n) -&gt; None:\n    \"\"\"Sets the linear velocity parameter of the printpoints depending on the selected type.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.print_organization.BasePrintOrganizer`\n    per_layer_velocities: list\n        A list of velocities (floats) with equal length to the number of layers.\n    \"\"\"\n\n    logger.info(\"Setting per-layer linear velocity\")\n    if len(per_layer_velocities) != print_organizer.number_of_layers:\n        raise ValueError(\n            f'Wrong number of velocity values: got {len(per_layer_velocities)}, '\n            f'need {print_organizer.number_of_layers} (one per layer)'\n        )\n    for printpoint, i, _j, _k in print_organizer.printpoints_indices_iterator():\n        printpoint.velocity = per_layer_velocities[i]\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.set_linear_velocity_by_range","title":"set_linear_velocity_by_range","text":"<pre><code>set_linear_velocity_by_range(print_organizer, param_func, parameter_range, velocity_range, bound_remapping=True)\n</code></pre> <p>Sets the linear velocity parameter of the printpoints depending on the selected type.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>param_func</code> <code>Callable[[PrintPoint], float]</code> <p>and returns the parameter value that will be used for the remapping</p> required <code>parameter_range</code> <code>tuple[float, float]</code> <p>An example of a parameter that can be used is the overhang angle, or the layer height.</p> required <code>velocity_range</code> <code>tuple[float, float]</code> <p>The range of velocities where the parameter will be remapped</p> required <code>bound_remapping</code> <code>bool</code> <p>If True, the remapping is bound in the domain velocity_range, else it is unbound.</p> <code>True</code> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/linear_velocity.py</code> <pre><code>def set_linear_velocity_by_range(\n    print_organizer: BasePrintOrganizer,\n    param_func: Callable[[PrintPoint], float],\n    parameter_range: tuple[float, float],\n    velocity_range: tuple[float, float],\n    bound_remapping: bool = True,\n) -&gt; None:\n    \"\"\"Sets the linear velocity parameter of the printpoints depending on the selected type.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.print_organization.BasePrintOrganizer`\n    param_func: function that takes as argument a :class: 'compas_slicer.geometry.Printpoint': get_param_func(pp)\n        and returns the parameter value that will be used for the remapping\n    parameter_range: tuple\n        An example of a parameter that can be used is the overhang angle, or the layer height.\n    velocity_range: tuple\n        The range of velocities where the parameter will be remapped\n    bound_remapping: bool\n        If True, the remapping is bound in the domain velocity_range, else it is unbound.\n    \"\"\"\n\n    logger.info(\"Setting linear velocity based on parameter range\")\n    for printpoint in print_organizer.printpoints_iterator():\n        param = param_func(printpoint)\n        if param is None:\n            raise ValueError('The param_func does not return any value for calculating the velocity range.')\n        if bound_remapping:\n            v = remap(param, parameter_range[0], parameter_range[1], velocity_range[0], velocity_range[1])\n        else:\n            v = remap_unbound(param, parameter_range[0], parameter_range[1], velocity_range[0], velocity_range[1])\n        printpoint.velocity = v\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.set_linear_velocity_by_overhang","title":"set_linear_velocity_by_overhang","text":"<pre><code>set_linear_velocity_by_overhang(print_organizer, overhang_range, velocity_range, bound_remapping=True)\n</code></pre> <p>Set velocity by overhang by using set_linear_velocity_by_range.</p> <p>An example function for how to use the 'set_linear_velocity_by_range'. In this case the parameter that controls the velocity is the overhang, measured as a dot product with the horizontal direction.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>overhang_range</code> <code>tuple[float, float]</code> <p>should be within [0.0, 1.0]. For example a reasonable value would be [0.0, 0.5], that would be remapping overhangs up to 45 degrees</p> required <code>velocity_range</code> <code>tuple[float, float]</code> required <code>bound_remapping</code> <code>bool</code> <code>True</code> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/linear_velocity.py</code> <pre><code>def set_linear_velocity_by_overhang(\n    print_organizer: BasePrintOrganizer,\n    overhang_range: tuple[float, float],\n    velocity_range: tuple[float, float],\n    bound_remapping: bool = True,\n) -&gt; None:\n    \"\"\"Set velocity by overhang by using set_linear_velocity_by_range.\n\n    An example function for how to use the 'set_linear_velocity_by_range'. In this case the parameter that controls the\n    velocity is the overhang, measured as a dot product with the horizontal direction.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.print_organization.BasePrintOrganizer`\n    overhang_range: tuple:\n        should be within [0.0, 1.0]. For example a reasonable value would be [0.0, 0.5], that would\n        be remapping overhangs up to 45 degrees\n    velocity_range: tuple\n    bound_remapping: bool\n    \"\"\"\n\n    def param_func(ppt): return dot_vectors(ppt.mesh_normal, Vector(0.0, 0.0, 1.0))\n    # returns values from 0.0 (no overhang) to 1.0 (horizontal overhang)\n    set_linear_velocity_by_range(print_organizer, param_func, overhang_range, velocity_range, bound_remapping)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.add_safety_printpoints","title":"add_safety_printpoints","text":"<pre><code>add_safety_printpoints(print_organizer, z_hop=10.0)\n</code></pre> <p>Generates a safety print point at the interruptions of the print paths.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> <p>An instance of the BasePrintOrganizer class.</p> required <code>z_hop</code> <code>float</code> <p>Vertical distance (in millimeters) of the safety point above the PrintPoint.</p> <code>10.0</code> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/safety_printpoints.py</code> <pre><code>def add_safety_printpoints(print_organizer: BasePrintOrganizer, z_hop: float = 10.0) -&gt; None:\n    \"\"\"Generates a safety print point at the interruptions of the print paths.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.print_organization.BasePrintOrganizer`\n        An instance of the BasePrintOrganizer class.\n    z_hop: float\n        Vertical distance (in millimeters) of the safety point above the PrintPoint.\n    \"\"\"\n    if not check_assigned_extruder_toggle(print_organizer):\n        raise ValueError('You need to set the extruder toggles first, before you can create safety points')\n    logger.info(f\"Generating safety print points with height {z_hop} mm\")\n\n    from compas_slicer.geometry import PrintPointsCollection\n\n    new_collection = PrintPointsCollection()\n\n    for i, layer in enumerate(print_organizer.printpoints):\n        new_layer = PrintLayer()\n\n        for j, path in enumerate(layer):\n            new_path = PrintPath()\n\n            for k, printpoint in enumerate(path):\n                #  add regular printing points\n                new_path.printpoints.append(printpoint)\n\n                # add safety printpoints if there is an interruption\n                if printpoint.extruder_toggle is False:\n\n                    # safety ppt after current printpoint\n                    new_path.printpoints.append(create_safety_printpoint(printpoint, z_hop, False))\n\n                    #  safety ppt before next printpoint (if there exists one)\n                    next_ppt = find_next_printpoint(print_organizer.printpoints, i, j, k)\n                    if next_ppt and next_ppt.extruder_toggle is True:  # if it is a printing ppt\n                        new_path.printpoints.append(create_safety_printpoint(next_ppt, z_hop, False))\n\n            new_layer.paths.append(new_path)\n\n        new_collection.layers.append(new_layer)\n\n    #  finally, insert a safety print point at the beginning of the entire print\n    try:\n        safety_printpoint = create_safety_printpoint(new_collection[0][0][0], z_hop, False)\n        new_collection[0][0].printpoints.insert(0, safety_printpoint)\n    except (KeyError, IndexError) as e:\n        logger.exception(e)\n\n    #  the safety printpoint has already been added at the end since the last printpoint extruder_toggle_type is False\n    print_organizer.printpoints = new_collection\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.set_wait_time_on_sharp_corners","title":"set_wait_time_on_sharp_corners","text":"<pre><code>set_wait_time_on_sharp_corners(print_organizer, threshold=0.5 * pi, wait_time=0.3)\n</code></pre> <p>Sets a wait time at the sharp corners of the path, based on the angle threshold.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>threshold</code> <code>float</code> <p>angle_threshold</p> <code>0.5 * pi</code> <code>wait_time</code> <code>float</code> <p>Time in seconds to introduce to add as a wait time</p> <code>0.3</code> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/wait_time.py</code> <pre><code>def set_wait_time_on_sharp_corners(\n    print_organizer: BasePrintOrganizer, threshold: float = 0.5 * math.pi, wait_time: float = 0.3\n) -&gt; None:\n    \"\"\"\n    Sets a wait time at the sharp corners of the path, based on the angle threshold.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.print_organization.BasePrintOrganizer`\n    threshold: float\n        angle_threshold\n    wait_time: float\n        Time in seconds to introduce to add as a wait time\n    \"\"\"\n    number_of_wait_points = 0\n    for printpoint, i, j, k in print_organizer.printpoints_indices_iterator():\n        neighbors = print_organizer.get_printpoint_neighboring_items(i, j, k)\n        prev_ppt = neighbors[0]\n        next_ppt = neighbors[1]\n\n        if prev_ppt and next_ppt:\n            v_to_prev = normalize_vector(Vector.from_start_end(printpoint.pt, prev_ppt.pt))\n            v_to_next = normalize_vector(Vector.from_start_end(printpoint.pt, next_ppt.pt))\n            a = abs(Vector(*v_to_prev).angle(v_to_next))\n\n            if a &lt; threshold:\n                printpoint.wait_time = wait_time\n                printpoint.blend_radius = 0.0  # 0.0 blend radius for points where the robot will wait\n                number_of_wait_points += 1\n    logger.info(f'Added wait times for {number_of_wait_points} points')\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.set_wait_time_based_on_extruder_toggle","title":"set_wait_time_based_on_extruder_toggle","text":"<pre><code>set_wait_time_based_on_extruder_toggle(print_organizer, wait_type, wait_time=0.3)\n</code></pre> <p>Sets a wait time for the printpoints, either before extrusion starts, after extrusion finishes, or in both cases.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>wait_type</code> <code>WaitType</code> <p>wait_before_extrusion:  sets a wait time before extrusion (extruder_toggle False to True) wait_after_extrusion: sets a wait time after extrusion (extruder_toggle True to False) wait_before_and_after_extrusion: sets a wait time before, and after extrusion wait_at_sharp_corners: sets a wait time at the sharp corners of the path</p> required <code>wait_time</code> <code>float</code> <p>Time in seconds to introduce to add as a wait time</p> <code>0.3</code> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/wait_time.py</code> <pre><code>def set_wait_time_based_on_extruder_toggle(\n    print_organizer: BasePrintOrganizer, wait_type: WaitType, wait_time: float = 0.3\n) -&gt; None:\n    \"\"\"\n    Sets a wait time for the printpoints, either before extrusion starts,\n    after extrusion finishes, or in both cases.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.print_organization.BasePrintOrganizer`\n    wait_type: str\n        wait_before_extrusion:  sets a wait time before extrusion (extruder_toggle False to True)\n        wait_after_extrusion: sets a wait time after extrusion (extruder_toggle True to False)\n        wait_before_and_after_extrusion: sets a wait time before, and after extrusion\n        wait_at_sharp_corners: sets a wait time at the sharp corners of the path\n    wait_time: float\n        Time in seconds to introduce to add as a wait time\n    \"\"\"\n\n    for printpoint in print_organizer.printpoints_iterator():\n        if printpoint.extruder_toggle is None:\n            raise ValueError('You need to set the extruder toggles first, before you can automatically set the wait time')\n\n    logger.info(\"Setting wait time\")\n\n    for printpoint, i, j, k in print_organizer.printpoints_indices_iterator():\n        number_of_wait_points = 0\n        next_ppt = find_next_printpoint(print_organizer.printpoints, i, j, k)\n\n        # for the brim layer don't add any wait times\n        if not print_organizer.slicer.layers[i].is_brim and next_ppt:\n            if wait_type == \"wait_before_extrusion\":\n                if printpoint.extruder_toggle is False and next_ppt.extruder_toggle is True:\n                    next_ppt.wait_time = wait_time\n                    next_ppt.blend_radius = 0.0\n                    number_of_wait_points += 1\n            elif wait_type == \"wait_after_extrusion\":\n                if printpoint.extruder_toggle is True and next_ppt.extruder_toggle is False:\n                    next_ppt.wait_time = wait_time\n                    next_ppt.blend_radius = 0.0\n                    number_of_wait_points += 1\n            elif wait_type == \"wait_before_and_after_extrusion\":\n                if printpoint.extruder_toggle is False and next_ppt.extruder_toggle is True:\n                    next_ppt.wait_time = wait_time\n                    next_ppt.blend_radius = 0.0\n                    number_of_wait_points += 1\n                if printpoint.extruder_toggle is True and next_ppt.extruder_toggle is False:\n                    next_ppt.wait_time = wait_time\n                    next_ppt.blend_radius = 0.0\n                    number_of_wait_points += 1\n            else:\n                logger.error(f'Unknown wait type: {wait_type}')\n\n        logger.info(f'Added wait times for {number_of_wait_points} points')\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.override_wait_time","title":"override_wait_time","text":"<pre><code>override_wait_time(print_organizer, override_value)\n</code></pre> <p>Overrides the wait_time value for the printpoints with a user-defined value.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>override_value</code> <code>float</code> <p>Value to override the wait_time values with.</p> required Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/wait_time.py</code> <pre><code>def override_wait_time(print_organizer: BasePrintOrganizer, override_value: float) -&gt; None:\n    \"\"\"\n    Overrides the wait_time value for the printpoints with a user-defined value.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.print_organization.BasePrintOrganizer`\n    override_value: float\n        Value to override the wait_time values with.\n    \"\"\"\n    for printpoint in print_organizer.printpoints_iterator():\n        printpoint.wait_time = override_value\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.blend_radius","title":"blend_radius","text":""},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.blend_radius.set_blend_radius","title":"set_blend_radius","text":"<pre><code>set_blend_radius(print_organizer, d_fillet=10.0, buffer=0.3)\n</code></pre> <p>Sets the blend radius (filleting) for the robotic motion.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>d_fillet</code> <code>float</code> <p>Value to attempt to fillet with. Defaults to 10 mm.</p> <code>10.0</code> <code>buffer</code> <code>float</code> <p>Buffer to make sure that the blend radius is never too big. Defaults to 0.3.</p> <code>0.3</code> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/blend_radius.py</code> <pre><code>def set_blend_radius(\n    print_organizer: BasePrintOrganizer, d_fillet: float = 10.0, buffer: float = 0.3\n) -&gt; None:\n    \"\"\"Sets the blend radius (filleting) for the robotic motion.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.slicers.BasePrintOrganizer`\n    d_fillet: float\n        Value to attempt to fillet with. Defaults to 10 mm.\n    buffer: float\n        Buffer to make sure that the blend radius is never too big.\n        Defaults to 0.3.\n    \"\"\"\n\n    logger.info(\"Setting blend radius\")\n\n    extruder_state: bool | None = None\n\n    for printpoint, i, j, k in print_organizer.printpoints_indices_iterator():\n        neighboring_items = print_organizer.get_printpoint_neighboring_items(i, j, k)\n\n        if not printpoint.wait_time:\n\n            # if the extruder_toggle changes, it must be a new path and therefore the blend radius should be 0\n            if extruder_state != printpoint.extruder_toggle:\n                extruder_state = printpoint.extruder_toggle\n                radius = 0.0\n\n            else:\n\n                radius = d_fillet\n                if neighboring_items[0]:\n                    radius = min(radius, norm_vector(Vector.from_start_end(neighboring_items[0].pt, printpoint.pt)) * buffer)\n\n                if neighboring_items[1]:\n                    radius = min(radius, norm_vector(Vector.from_start_end(neighboring_items[1].pt, printpoint.pt)) * buffer)\n\n                radius = round(radius, 5)\n\n        else:\n            radius = 0.0  # 0.0 blend radius for points where the robot will pause and wait\n\n        printpoint.blend_radius = radius\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.data_smoothing","title":"data_smoothing","text":""},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.data_smoothing.smooth_printpoint_attribute","title":"smooth_printpoint_attribute","text":"<pre><code>smooth_printpoint_attribute(print_organizer, iterations, strength, get_attr_value, set_attr_value)\n</code></pre> <p>Iterative smoothing of the printpoints attribute. The attribute is accessed using the function 'get_attr_value(ppt)', and is set using the function 'set_attr_value(ppt, v)'. All attributes are smoothened continuously (i.e. as if their printpoints belong into one long uninterrupted path) For examples of how to use this function look at 'smooth_printpoints_layer_heights' and 'smooth_printpoints_up_vectors' below. The smoothing is happening by taking an average of the previous and next point attributes, and combining them with the current value of the print point; On every iteration: new_val = (0.5*(neighbor_left_val + neighbor_right_attr)) * strength - current_val * (1-strength)</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>iterations</code> <code>int</code> required <code>strength</code> <code>float</code> <p>the current value with the average of the two neighbors on every interation stop. On each iteration: new_val = (0.5*(neighbor_left_val + neighbor_right_attr)) * strength - current_val * (1-strength)</p> required <code>get_attr_value</code> <code>Callable[[PrintPoint], Any]</code> required <code>set_attr_value</code> <code>Callable[[PrintPoint, Any], None]</code> required Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/data_smoothing.py</code> <pre><code>def smooth_printpoint_attribute(\n    print_organizer: BasePrintOrganizer,\n    iterations: int,\n    strength: float,\n    get_attr_value: Callable[[PrintPoint], Any],\n    set_attr_value: Callable[[PrintPoint, Any], None],\n) -&gt; None:\n    \"\"\"\n    Iterative smoothing of the printpoints attribute.\n    The attribute is accessed using the function 'get_attr_value(ppt)', and is set using the function\n    'set_attr_value(ppt, v)'.\n    All attributes are smoothened continuously (i.e. as if their printpoints belong into one long uninterrupted path)\n    For examples of how to use this function look at 'smooth_printpoints_layer_heights' and\n    'smooth_printpoints_up_vectors' below.\n    The smoothing is happening by taking an average of the previous and next point attributes, and combining them with\n    the current value of the print point; On every iteration:\n    new_val = (0.5*(neighbor_left_val + neighbor_right_attr)) * strength - current_val * (1-strength)\n\n    Parameters\n    ----------\n    print_organizer: :class: 'compas_slicer.print_organization.BasePrintOrganizer', or other class inheriting from it.\n    iterations: int, smoothing iterations\n    strength: float. in the range [0.0 - 1.0]. 0.0 corresponds to no smoothing at all, 1.0 corresponds to overwriting\n        the current value with the average of the two neighbors on every interation stop. On each iteration:\n        new_val = (0.5*(neighbor_left_val + neighbor_right_attr)) * strength - current_val * (1-strength)\n    get_attr_value: function that returns an attribute of a printpoint, get_attr_value(ppt)\n    set_attr_value: function that sets an attribute of a printpoint, set_attr_value(ppt, new_value)\n    \"\"\"\n\n    # first smoothen the values\n    for ppt in print_organizer.printpoints_iterator():\n        if get_attr_value(ppt) is None:\n            raise ValueError('The attribute you are trying to smooth has not been assigned a value')\n\n    attrs = np.array([get_attr_value(ppt) for ppt in print_organizer.printpoints_iterator()])\n\n    # Vectorized smoothing: use numpy slicing instead of per-element loop\n    for _ in range(iterations):\n        # mid = 0.5 * (attrs[i-1] + attrs[i+1]) for interior points\n        mid = 0.5 * (attrs[:-2] + attrs[2:])  # shape: (n-2,)\n        # new_val = mid * strength + attrs[1:-1] * (1 - strength)\n        attrs[1:-1] = mid * strength + attrs[1:-1] * (1 - strength)\n\n    # Assign the smoothened values back to the printpoints\n    for i, ppt in enumerate(print_organizer.printpoints_iterator()):\n        val = attrs[i]\n        # Convert back from numpy type if needed\n        set_attr_value(ppt, val.tolist() if hasattr(val, 'tolist') else float(val))\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.data_smoothing.smooth_printpoints_layer_heights","title":"smooth_printpoints_layer_heights","text":"<pre><code>smooth_printpoints_layer_heights(print_organizer, iterations, strength)\n</code></pre> <p>This function is an example for how the 'smooth_printpoint_attribute' function can be used.</p> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/data_smoothing.py</code> <pre><code>def smooth_printpoints_layer_heights(\n    print_organizer: BasePrintOrganizer, iterations: int, strength: float\n) -&gt; None:\n    \"\"\" This function is an example for how the 'smooth_printpoint_attribute' function can be used. \"\"\"\n\n    def get_ppt_layer_height(printpoint):\n        return printpoint.layer_height  # get value\n\n    def set_ppt_layer_height(printpoint, v):\n        printpoint.layer_height = v  # set value\n\n    smooth_printpoint_attribute(print_organizer, iterations, strength, get_ppt_layer_height, set_ppt_layer_height)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.data_smoothing.smooth_printpoints_up_vectors","title":"smooth_printpoints_up_vectors","text":"<pre><code>smooth_printpoints_up_vectors(print_organizer, iterations, strength)\n</code></pre> <p>This function is an example for how the 'smooth_printpoint_attribute' function can be used.</p> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/data_smoothing.py</code> <pre><code>def smooth_printpoints_up_vectors(\n    print_organizer: BasePrintOrganizer, iterations: int, strength: float\n) -&gt; None:\n    \"\"\" This function is an example for how the 'smooth_printpoint_attribute' function can be used. \"\"\"\n\n    def get_ppt_up_vec(printpoint):\n        return printpoint.up_vector  # get value\n\n    def set_ppt_up_vec(printpoint, v):\n        # Convert list back to Vector for proper serialization\n        printpoint.up_vector = Vector(*v) if isinstance(v, list) else v\n\n    smooth_printpoint_attribute(print_organizer, iterations, strength, get_ppt_up_vec, set_ppt_up_vec)\n    # finally update any values in the printpoints that are affected by the changed attribute\n    for ppt in print_organizer.printpoints_iterator():\n        ppt.frame = ppt.get_frame()\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.extruder_toggle","title":"extruder_toggle","text":""},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.extruder_toggle.set_extruder_toggle","title":"set_extruder_toggle","text":"<pre><code>set_extruder_toggle(print_organizer, slicer)\n</code></pre> <p>Sets the extruder_toggle value for the printpoints.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>slicer</code> <code>BaseSlicer</code> required Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/extruder_toggle.py</code> <pre><code>def set_extruder_toggle(print_organizer: BasePrintOrganizer, slicer: BaseSlicer) -&gt; None:\n    \"\"\"Sets the extruder_toggle value for the printpoints.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.print_organization.BasePrintOrganizer`\n    slicer: :class:`compas.slicers.BaseSlicer`\n    \"\"\"\n\n    logger.info(\"Setting extruder toggle\")\n\n    for i, layer in enumerate(slicer.layers):\n        is_vertical_layer = isinstance(layer, compas_slicer.geometry.VerticalLayer)\n        is_brim_layer = layer.is_brim\n\n        for j, path in enumerate(layer.paths):\n            is_closed_path = path.is_closed\n\n            # --- decide if the path should be interrupted at the end\n            interrupt_path = False\n\n            if not is_closed_path:\n                interrupt_path = True\n                # open paths should always be interrupted\n\n            if not is_vertical_layer and len(layer.paths) &gt; 1:\n                interrupt_path = True\n                # horizontal layers with multiple paths should be interrupted so that the extruder\n                # can travel from one path to the other, exception is added for the brim layers\n                if is_brim_layer and (j + 1) % layer.number_of_brim_offsets != 0:\n                    interrupt_path = False\n\n            if is_vertical_layer and j == len(layer.paths) - 1:\n                interrupt_path = True\n                # the last path of a vertical layer should be interrupted\n\n            if i &lt; len(slicer.layers)-1 and not slicer.layers[i+1].paths[0].is_closed:\n                interrupt_path = True\n\n            # --- create extruder toggles\n            try:\n                path_printpoints = print_organizer.printpoints[i][j]\n            except (KeyError, IndexError):\n                logger.exception(f\"no path found for layer {i}\")\n            else:\n                for k, printpoint in enumerate(path_printpoints):\n\n                    if interrupt_path:\n                        if k == len(path_printpoints) - 1:\n                            printpoint.extruder_toggle = False\n                        else:\n                            printpoint.extruder_toggle = True\n                    else:\n                        printpoint.extruder_toggle = True\n\n    # set extruder toggle of last print point to false\n    try:\n        print_organizer.printpoints[-1][-1][-1].extruder_toggle = False\n    except (KeyError, IndexError) as e:\n        logger.exception(e)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.extruder_toggle.override_extruder_toggle","title":"override_extruder_toggle","text":"<pre><code>override_extruder_toggle(print_organizer, override_value)\n</code></pre> <p>Overrides the extruder_toggle value for the printpoints with a user-defined value.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>override_value</code> <code>bool</code> <p>Value to override the extruder_toggle values with.</p> required Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/extruder_toggle.py</code> <pre><code>def override_extruder_toggle(print_organizer: BasePrintOrganizer, override_value: bool) -&gt; None:\n    \"\"\"Overrides the extruder_toggle value for the printpoints with a user-defined value.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas.print_organization.BasePrintOrganizer`\n    override_value: bool\n        Value to override the extruder_toggle values with.\n\n    \"\"\"\n    if not isinstance(override_value, bool):\n        raise TypeError(\"Override value must be of type bool\")\n    for printpoint in print_organizer.printpoints_iterator():\n        printpoint.extruder_toggle = override_value\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.extruder_toggle.check_assigned_extruder_toggle","title":"check_assigned_extruder_toggle","text":"<pre><code>check_assigned_extruder_toggle(print_organizer)\n</code></pre> <p>Checks that all the printpoints have an assigned extruder toggle.</p> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/extruder_toggle.py</code> <pre><code>def check_assigned_extruder_toggle(print_organizer: BasePrintOrganizer) -&gt; bool:\n    \"\"\" Checks that all the printpoints have an assigned extruder toggle. \"\"\"\n    all_toggles_assigned = True\n    for printpoint in print_organizer.printpoints_iterator():\n        if printpoint.extruder_toggle is None:\n            all_toggles_assigned = False\n    return all_toggles_assigned\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.gcode","title":"gcode","text":"<p>G-code generation for compas_slicer.</p> <p>This module generates G-code for FDM 3D printing from organized print points.</p>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.gcode.GcodeBuilder","title":"GcodeBuilder","text":"<pre><code>GcodeBuilder()\n</code></pre> <p>Builder for constructing G-code output efficiently.</p> <p>Uses a list internally and joins at the end for better performance than repeated string concatenation.</p> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/gcode.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._lines: list[str] = []\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.gcode.GcodeBuilder.comment","title":"comment","text":"<pre><code>comment(text)\n</code></pre> <p>Add a comment line.</p> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/gcode.py</code> <pre><code>def comment(self, text: str) -&gt; None:\n    \"\"\"Add a comment line.\"\"\"\n    self._lines.append(f\";{text}\")\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.gcode.GcodeBuilder.cmd","title":"cmd","text":"<pre><code>cmd(gcode, comment='')\n</code></pre> <p>Add a G-code command with optional inline comment.</p> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/gcode.py</code> <pre><code>def cmd(self, gcode: str, comment: str = \"\") -&gt; None:\n    \"\"\"Add a G-code command with optional inline comment.\"\"\"\n    if comment:\n        self._lines.append(f\"{gcode:&lt;30} ;{comment}\")\n    else:\n        self._lines.append(gcode)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.gcode.GcodeBuilder.blank","title":"blank","text":"<pre><code>blank()\n</code></pre> <p>Add a blank line.</p> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/gcode.py</code> <pre><code>def blank(self) -&gt; None:\n    \"\"\"Add a blank line.\"\"\"\n    self._lines.append(\"\")\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.gcode.GcodeBuilder.build","title":"build","text":"<pre><code>build()\n</code></pre> <p>Return the complete G-code as a string.</p> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/gcode.py</code> <pre><code>def build(self) -&gt; str:\n    \"\"\"Return the complete G-code as a string.\"\"\"\n    return \"\\n\".join(self._lines)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.gcode.create_gcode_text","title":"create_gcode_text","text":"<pre><code>create_gcode_text(print_organizer, config=None)\n</code></pre> <p>Create G-code text from organized print points.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> <p>The print organizer containing printpoints.</p> required <code>config</code> <code>GcodeConfig | None</code> <p>G-code configuration. If None, uses defaults.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Complete G-code file content.</p> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/gcode.py</code> <pre><code>def create_gcode_text(\n    print_organizer: BasePrintOrganizer, config: GcodeConfig | None = None\n) -&gt; str:\n    \"\"\"Create G-code text from organized print points.\n\n    Parameters\n    ----------\n    print_organizer : BasePrintOrganizer\n        The print organizer containing printpoints.\n    config : GcodeConfig | None\n        G-code configuration. If None, uses defaults.\n\n    Returns\n    -------\n    str\n        Complete G-code file content.\n\n    \"\"\"\n    config = config or GcodeConfig()\n    logger.info(\"Generating G-code\")\n\n    gb = GcodeBuilder()\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    _write_header(gb, config, timestamp)\n    _write_purge_line(gb, config)\n    final_z = _write_toolpath(gb, print_organizer, config)\n    _write_footer(gb, config, final_z)\n\n    return gb.build()\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.linear_velocity","title":"linear_velocity","text":""},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.linear_velocity.set_linear_velocity_constant","title":"set_linear_velocity_constant","text":"<pre><code>set_linear_velocity_constant(print_organizer, v=25.0)\n</code></pre> <p>Sets the linear velocity parameter of the printpoints depending on the selected type.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>v</code> <code>float</code> <code>25.0</code> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/linear_velocity.py</code> <pre><code>def set_linear_velocity_constant(print_organizer: BasePrintOrganizer, v: float = 25.0) -&gt; None:\n    \"\"\"Sets the linear velocity parameter of the printpoints depending on the selected type.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.print_organization.BasePrintOrganizer`\n    v:  float. Velocity value (in mm/s) to set for printpoints. Defaults to 25 mm/s.\n    \"\"\"\n\n    logger.info(\"Setting constant linear velocity\")\n    for printpoint in print_organizer.printpoints_iterator():\n        printpoint.velocity = v\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.linear_velocity.set_linear_velocity_per_layer","title":"set_linear_velocity_per_layer","text":"<pre><code>set_linear_velocity_per_layer(print_organizer, per_layer_velocities)\n</code></pre> <p>Sets the linear velocity parameter of the printpoints depending on the selected type.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>per_layer_velocities</code> <code>list[float]</code> <p>A list of velocities (floats) with equal length to the number of layers.</p> required Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/linear_velocity.py</code> <pre><code>def set_linear_velocity_per_layer(\n    print_organizer: BasePrintOrganizer, per_layer_velocities: list[float]\n) -&gt; None:\n    \"\"\"Sets the linear velocity parameter of the printpoints depending on the selected type.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.print_organization.BasePrintOrganizer`\n    per_layer_velocities: list\n        A list of velocities (floats) with equal length to the number of layers.\n    \"\"\"\n\n    logger.info(\"Setting per-layer linear velocity\")\n    if len(per_layer_velocities) != print_organizer.number_of_layers:\n        raise ValueError(\n            f'Wrong number of velocity values: got {len(per_layer_velocities)}, '\n            f'need {print_organizer.number_of_layers} (one per layer)'\n        )\n    for printpoint, i, _j, _k in print_organizer.printpoints_indices_iterator():\n        printpoint.velocity = per_layer_velocities[i]\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.linear_velocity.set_linear_velocity_by_range","title":"set_linear_velocity_by_range","text":"<pre><code>set_linear_velocity_by_range(print_organizer, param_func, parameter_range, velocity_range, bound_remapping=True)\n</code></pre> <p>Sets the linear velocity parameter of the printpoints depending on the selected type.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>param_func</code> <code>Callable[[PrintPoint], float]</code> <p>and returns the parameter value that will be used for the remapping</p> required <code>parameter_range</code> <code>tuple[float, float]</code> <p>An example of a parameter that can be used is the overhang angle, or the layer height.</p> required <code>velocity_range</code> <code>tuple[float, float]</code> <p>The range of velocities where the parameter will be remapped</p> required <code>bound_remapping</code> <code>bool</code> <p>If True, the remapping is bound in the domain velocity_range, else it is unbound.</p> <code>True</code> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/linear_velocity.py</code> <pre><code>def set_linear_velocity_by_range(\n    print_organizer: BasePrintOrganizer,\n    param_func: Callable[[PrintPoint], float],\n    parameter_range: tuple[float, float],\n    velocity_range: tuple[float, float],\n    bound_remapping: bool = True,\n) -&gt; None:\n    \"\"\"Sets the linear velocity parameter of the printpoints depending on the selected type.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.print_organization.BasePrintOrganizer`\n    param_func: function that takes as argument a :class: 'compas_slicer.geometry.Printpoint': get_param_func(pp)\n        and returns the parameter value that will be used for the remapping\n    parameter_range: tuple\n        An example of a parameter that can be used is the overhang angle, or the layer height.\n    velocity_range: tuple\n        The range of velocities where the parameter will be remapped\n    bound_remapping: bool\n        If True, the remapping is bound in the domain velocity_range, else it is unbound.\n    \"\"\"\n\n    logger.info(\"Setting linear velocity based on parameter range\")\n    for printpoint in print_organizer.printpoints_iterator():\n        param = param_func(printpoint)\n        if param is None:\n            raise ValueError('The param_func does not return any value for calculating the velocity range.')\n        if bound_remapping:\n            v = remap(param, parameter_range[0], parameter_range[1], velocity_range[0], velocity_range[1])\n        else:\n            v = remap_unbound(param, parameter_range[0], parameter_range[1], velocity_range[0], velocity_range[1])\n        printpoint.velocity = v\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.linear_velocity.set_linear_velocity_by_overhang","title":"set_linear_velocity_by_overhang","text":"<pre><code>set_linear_velocity_by_overhang(print_organizer, overhang_range, velocity_range, bound_remapping=True)\n</code></pre> <p>Set velocity by overhang by using set_linear_velocity_by_range.</p> <p>An example function for how to use the 'set_linear_velocity_by_range'. In this case the parameter that controls the velocity is the overhang, measured as a dot product with the horizontal direction.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>overhang_range</code> <code>tuple[float, float]</code> <p>should be within [0.0, 1.0]. For example a reasonable value would be [0.0, 0.5], that would be remapping overhangs up to 45 degrees</p> required <code>velocity_range</code> <code>tuple[float, float]</code> required <code>bound_remapping</code> <code>bool</code> <code>True</code> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/linear_velocity.py</code> <pre><code>def set_linear_velocity_by_overhang(\n    print_organizer: BasePrintOrganizer,\n    overhang_range: tuple[float, float],\n    velocity_range: tuple[float, float],\n    bound_remapping: bool = True,\n) -&gt; None:\n    \"\"\"Set velocity by overhang by using set_linear_velocity_by_range.\n\n    An example function for how to use the 'set_linear_velocity_by_range'. In this case the parameter that controls the\n    velocity is the overhang, measured as a dot product with the horizontal direction.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.print_organization.BasePrintOrganizer`\n    overhang_range: tuple:\n        should be within [0.0, 1.0]. For example a reasonable value would be [0.0, 0.5], that would\n        be remapping overhangs up to 45 degrees\n    velocity_range: tuple\n    bound_remapping: bool\n    \"\"\"\n\n    def param_func(ppt): return dot_vectors(ppt.mesh_normal, Vector(0.0, 0.0, 1.0))\n    # returns values from 0.0 (no overhang) to 1.0 (horizontal overhang)\n    set_linear_velocity_by_range(print_organizer, param_func, overhang_range, velocity_range, bound_remapping)\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.safety_printpoints","title":"safety_printpoints","text":""},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.safety_printpoints.add_safety_printpoints","title":"add_safety_printpoints","text":"<pre><code>add_safety_printpoints(print_organizer, z_hop=10.0)\n</code></pre> <p>Generates a safety print point at the interruptions of the print paths.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> <p>An instance of the BasePrintOrganizer class.</p> required <code>z_hop</code> <code>float</code> <p>Vertical distance (in millimeters) of the safety point above the PrintPoint.</p> <code>10.0</code> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/safety_printpoints.py</code> <pre><code>def add_safety_printpoints(print_organizer: BasePrintOrganizer, z_hop: float = 10.0) -&gt; None:\n    \"\"\"Generates a safety print point at the interruptions of the print paths.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.print_organization.BasePrintOrganizer`\n        An instance of the BasePrintOrganizer class.\n    z_hop: float\n        Vertical distance (in millimeters) of the safety point above the PrintPoint.\n    \"\"\"\n    if not check_assigned_extruder_toggle(print_organizer):\n        raise ValueError('You need to set the extruder toggles first, before you can create safety points')\n    logger.info(f\"Generating safety print points with height {z_hop} mm\")\n\n    from compas_slicer.geometry import PrintPointsCollection\n\n    new_collection = PrintPointsCollection()\n\n    for i, layer in enumerate(print_organizer.printpoints):\n        new_layer = PrintLayer()\n\n        for j, path in enumerate(layer):\n            new_path = PrintPath()\n\n            for k, printpoint in enumerate(path):\n                #  add regular printing points\n                new_path.printpoints.append(printpoint)\n\n                # add safety printpoints if there is an interruption\n                if printpoint.extruder_toggle is False:\n\n                    # safety ppt after current printpoint\n                    new_path.printpoints.append(create_safety_printpoint(printpoint, z_hop, False))\n\n                    #  safety ppt before next printpoint (if there exists one)\n                    next_ppt = find_next_printpoint(print_organizer.printpoints, i, j, k)\n                    if next_ppt and next_ppt.extruder_toggle is True:  # if it is a printing ppt\n                        new_path.printpoints.append(create_safety_printpoint(next_ppt, z_hop, False))\n\n            new_layer.paths.append(new_path)\n\n        new_collection.layers.append(new_layer)\n\n    #  finally, insert a safety print point at the beginning of the entire print\n    try:\n        safety_printpoint = create_safety_printpoint(new_collection[0][0][0], z_hop, False)\n        new_collection[0][0].printpoints.insert(0, safety_printpoint)\n    except (KeyError, IndexError) as e:\n        logger.exception(e)\n\n    #  the safety printpoint has already been added at the end since the last printpoint extruder_toggle_type is False\n    print_organizer.printpoints = new_collection\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.safety_printpoints.create_safety_printpoint","title":"create_safety_printpoint","text":"<pre><code>create_safety_printpoint(printpoint, z_hop, extruder_toggle)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>printpoint</code> <code>PrintPoint</code> required <code>z_hop</code> <code>float</code> required <code>extruder_toggle</code> <code>bool</code> required <p>Returns:</p> Type Description <code>class: 'compas_slicer.geometry.PrintPoint'</code> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/safety_printpoints.py</code> <pre><code>def create_safety_printpoint(printpoint: PrintPoint, z_hop: float, extruder_toggle: bool) -&gt; PrintPoint:\n    \"\"\"\n\n    Parameters\n    ----------\n    printpoint: :class: 'compas_slicer.geometry.PrintPoint'\n    z_hop: float\n    extruder_toggle: bool\n\n    Returns\n    ----------\n    :class: 'compas_slicer.geometry.PrintPoint'\n    \"\"\"\n\n    pt0 = printpoint.pt\n    safety_printpoint = copy.deepcopy(printpoint)\n    safety_printpoint.pt = pt0 + Vector(0, 0, z_hop)\n    if safety_printpoint.frame is not None:\n        safety_printpoint.frame.point = safety_printpoint.pt\n    safety_printpoint.extruder_toggle = extruder_toggle\n    return safety_printpoint\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.wait_time","title":"wait_time","text":""},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.wait_time.set_wait_time_on_sharp_corners","title":"set_wait_time_on_sharp_corners","text":"<pre><code>set_wait_time_on_sharp_corners(print_organizer, threshold=0.5 * pi, wait_time=0.3)\n</code></pre> <p>Sets a wait time at the sharp corners of the path, based on the angle threshold.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>threshold</code> <code>float</code> <p>angle_threshold</p> <code>0.5 * pi</code> <code>wait_time</code> <code>float</code> <p>Time in seconds to introduce to add as a wait time</p> <code>0.3</code> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/wait_time.py</code> <pre><code>def set_wait_time_on_sharp_corners(\n    print_organizer: BasePrintOrganizer, threshold: float = 0.5 * math.pi, wait_time: float = 0.3\n) -&gt; None:\n    \"\"\"\n    Sets a wait time at the sharp corners of the path, based on the angle threshold.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.print_organization.BasePrintOrganizer`\n    threshold: float\n        angle_threshold\n    wait_time: float\n        Time in seconds to introduce to add as a wait time\n    \"\"\"\n    number_of_wait_points = 0\n    for printpoint, i, j, k in print_organizer.printpoints_indices_iterator():\n        neighbors = print_organizer.get_printpoint_neighboring_items(i, j, k)\n        prev_ppt = neighbors[0]\n        next_ppt = neighbors[1]\n\n        if prev_ppt and next_ppt:\n            v_to_prev = normalize_vector(Vector.from_start_end(printpoint.pt, prev_ppt.pt))\n            v_to_next = normalize_vector(Vector.from_start_end(printpoint.pt, next_ppt.pt))\n            a = abs(Vector(*v_to_prev).angle(v_to_next))\n\n            if a &lt; threshold:\n                printpoint.wait_time = wait_time\n                printpoint.blend_radius = 0.0  # 0.0 blend radius for points where the robot will wait\n                number_of_wait_points += 1\n    logger.info(f'Added wait times for {number_of_wait_points} points')\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.wait_time.set_wait_time_based_on_extruder_toggle","title":"set_wait_time_based_on_extruder_toggle","text":"<pre><code>set_wait_time_based_on_extruder_toggle(print_organizer, wait_type, wait_time=0.3)\n</code></pre> <p>Sets a wait time for the printpoints, either before extrusion starts, after extrusion finishes, or in both cases.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>wait_type</code> <code>WaitType</code> <p>wait_before_extrusion:  sets a wait time before extrusion (extruder_toggle False to True) wait_after_extrusion: sets a wait time after extrusion (extruder_toggle True to False) wait_before_and_after_extrusion: sets a wait time before, and after extrusion wait_at_sharp_corners: sets a wait time at the sharp corners of the path</p> required <code>wait_time</code> <code>float</code> <p>Time in seconds to introduce to add as a wait time</p> <code>0.3</code> Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/wait_time.py</code> <pre><code>def set_wait_time_based_on_extruder_toggle(\n    print_organizer: BasePrintOrganizer, wait_type: WaitType, wait_time: float = 0.3\n) -&gt; None:\n    \"\"\"\n    Sets a wait time for the printpoints, either before extrusion starts,\n    after extrusion finishes, or in both cases.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.print_organization.BasePrintOrganizer`\n    wait_type: str\n        wait_before_extrusion:  sets a wait time before extrusion (extruder_toggle False to True)\n        wait_after_extrusion: sets a wait time after extrusion (extruder_toggle True to False)\n        wait_before_and_after_extrusion: sets a wait time before, and after extrusion\n        wait_at_sharp_corners: sets a wait time at the sharp corners of the path\n    wait_time: float\n        Time in seconds to introduce to add as a wait time\n    \"\"\"\n\n    for printpoint in print_organizer.printpoints_iterator():\n        if printpoint.extruder_toggle is None:\n            raise ValueError('You need to set the extruder toggles first, before you can automatically set the wait time')\n\n    logger.info(\"Setting wait time\")\n\n    for printpoint, i, j, k in print_organizer.printpoints_indices_iterator():\n        number_of_wait_points = 0\n        next_ppt = find_next_printpoint(print_organizer.printpoints, i, j, k)\n\n        # for the brim layer don't add any wait times\n        if not print_organizer.slicer.layers[i].is_brim and next_ppt:\n            if wait_type == \"wait_before_extrusion\":\n                if printpoint.extruder_toggle is False and next_ppt.extruder_toggle is True:\n                    next_ppt.wait_time = wait_time\n                    next_ppt.blend_radius = 0.0\n                    number_of_wait_points += 1\n            elif wait_type == \"wait_after_extrusion\":\n                if printpoint.extruder_toggle is True and next_ppt.extruder_toggle is False:\n                    next_ppt.wait_time = wait_time\n                    next_ppt.blend_radius = 0.0\n                    number_of_wait_points += 1\n            elif wait_type == \"wait_before_and_after_extrusion\":\n                if printpoint.extruder_toggle is False and next_ppt.extruder_toggle is True:\n                    next_ppt.wait_time = wait_time\n                    next_ppt.blend_radius = 0.0\n                    number_of_wait_points += 1\n                if printpoint.extruder_toggle is True and next_ppt.extruder_toggle is False:\n                    next_ppt.wait_time = wait_time\n                    next_ppt.blend_radius = 0.0\n                    number_of_wait_points += 1\n            else:\n                logger.error(f'Unknown wait type: {wait_type}')\n\n        logger.info(f'Added wait times for {number_of_wait_points} points')\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.print_organization_utilities.wait_time.override_wait_time","title":"override_wait_time","text":"<pre><code>override_wait_time(print_organizer, override_value)\n</code></pre> <p>Overrides the wait_time value for the printpoints with a user-defined value.</p> <p>Parameters:</p> Name Type Description Default <code>print_organizer</code> <code>BasePrintOrganizer</code> required <code>override_value</code> <code>float</code> <p>Value to override the wait_time values with.</p> required Source code in <code>src/compas_slicer/print_organization/print_organization_utilities/wait_time.py</code> <pre><code>def override_wait_time(print_organizer: BasePrintOrganizer, override_value: float) -&gt; None:\n    \"\"\"\n    Overrides the wait_time value for the printpoints with a user-defined value.\n\n    Parameters\n    ----------\n    print_organizer: :class:`compas_slicer.print_organization.BasePrintOrganizer`\n    override_value: float\n        Value to override the wait_time values with.\n    \"\"\"\n    for printpoint in print_organizer.printpoints_iterator():\n        printpoint.wait_time = override_value\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.scalar_field_print_organizer","title":"scalar_field_print_organizer","text":""},{"location":"api/print_organization/#compas_slicer.print_organization.scalar_field_print_organizer.ScalarFieldPrintOrganizer","title":"ScalarFieldPrintOrganizer","text":"<pre><code>ScalarFieldPrintOrganizer(slicer, config=None, DATA_PATH='.')\n</code></pre> <p>               Bases: <code>BasePrintOrganizer</code></p> <p>Organize the printing process for scalar field contours.</p> <p>Attributes:</p> Name Type Description <code>slicer</code> <code>ScalarFieldSlicer</code> <p>An instance of ScalarFieldSlicer.</p> <code>config</code> <code>InterpolationConfig</code> <p>Configuration parameters.</p> <code>DATA_PATH</code> <code>str | Path</code> <p>Data directory path.</p> <code>vertical_layers</code> <code>list[VerticalLayer]</code> <p>Vertical layers from slicer.</p> <code>horizontal_layers</code> <code>list[Layer]</code> <p>Horizontal layers from slicer.</p> <code>g_evaluation</code> <code>GradientEvaluation</code> <p>Gradient evaluation object.</p> Source code in <code>src/compas_slicer/print_organization/scalar_field_print_organizer.py</code> <pre><code>def __init__(\n    self,\n    slicer: ScalarFieldSlicer,\n    config: InterpolationConfig | None = None,\n    DATA_PATH: str | FilePath = \".\",\n) -&gt; None:\n    from compas_slicer.slicers import ScalarFieldSlicer\n\n    if not isinstance(slicer, ScalarFieldSlicer):\n        raise TypeError('Please provide a ScalarFieldSlicer')\n    BasePrintOrganizer.__init__(self, slicer)\n    self.DATA_PATH = DATA_PATH\n    self.OUTPUT_PATH = utils.get_output_directory(DATA_PATH)\n    self.config = config if config else InterpolationConfig()\n\n    self.vertical_layers = slicer.vertical_layers\n    self.horizontal_layers = slicer.horizontal_layers\n    if len(self.vertical_layers) + len(self.horizontal_layers) != len(slicer.layers):\n        raise ValueError(\n            f\"Layer count mismatch: {len(self.vertical_layers)} vertical + \"\n            f\"{len(self.horizontal_layers)} horizontal != {len(slicer.layers)} total\"\n        )\n\n    if len(self.horizontal_layers) &gt; 0:\n        if len(self.horizontal_layers) != 1:\n            raise ValueError(\"Only one brim horizontal layer is currently supported.\")\n        if not self.horizontal_layers[0].is_brim:\n            raise ValueError(\"Only one brim horizontal layer is currently supported.\")\n        logger.info('Slicer has one horizontal brim layer.')\n\n    self.g_evaluation: GradientEvaluation = self.add_gradient_to_vertices()\n</code></pre>"},{"location":"api/print_organization/#compas_slicer.print_organization.scalar_field_print_organizer.ScalarFieldPrintOrganizer.create_printpoints","title":"create_printpoints","text":"<pre><code>create_printpoints()\n</code></pre> <p>Create the print points of the fabrication process.</p> Source code in <code>src/compas_slicer/print_organization/scalar_field_print_organizer.py</code> <pre><code>def create_printpoints(self) -&gt; None:\n    \"\"\"Create the print points of the fabrication process.\"\"\"\n    count = 0\n    logger.info('Creating print points ...')\n    with progressbar.ProgressBar(max_value=self.slicer.number_of_points) as bar:\n\n        for _i, layer in enumerate(self.slicer.layers):\n            print_layer = PrintLayer()\n\n            for _j, path in enumerate(layer.paths):\n                print_path = PrintPath()\n\n                for k, point in enumerate(path.points):\n                    normal = utils.get_normal_of_path_on_xy_plane(k, point, path, self.slicer.mesh)\n\n                    h = self.config.avg_layer_height\n                    printpoint = PrintPoint(pt=point, layer_height=h, mesh_normal=normal)\n\n                    print_path.printpoints.append(printpoint)\n                    bar.update(count)\n                    count += 1\n\n                print_layer.paths.append(print_path)\n\n            self.printpoints.layers.append(print_layer)\n\n    # transfer gradient information to printpoints\n    transfer_mesh_attributes_to_printpoints(self.slicer.mesh, self.printpoints)\n\n    # add non-planar print data to printpoints\n    for layer in self.printpoints:\n        for path in layer:\n            for pp in path:\n                grad_norm = pp.attributes['gradient_norm']\n                grad = pp.attributes['gradient']\n                pp.distance_to_support = grad_norm\n                pp.layer_height = grad_norm\n                pp.up_vector = Vector(*normalize_vector(grad))\n                pp.frame = pp.get_frame()\n</code></pre>"},{"location":"api/slicers/","title":"Slicers","text":"<p>Mesh slicing algorithms.</p>"},{"location":"api/slicers/#compas_slicer.slicers","title":"slicers","text":"<p>Mesh slicing algorithms.</p>"},{"location":"api/slicers/#compas_slicer.slicers.BaseSlicer","title":"BaseSlicer","text":"<pre><code>BaseSlicer(mesh)\n</code></pre> <p>Base class for slicers that holds all information for the slice process.</p> <p>Do not use this class directly. Instead use PlanarSlicer or InterpolationSlicer. This class is meant to be extended for implementing various slicers.</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>Mesh</code> <p>Input mesh, must be triangular (no quads or n-gons allowed).</p> <code>layer_height</code> <code>float | None</code> <p>Height between layers.</p> <code>layers</code> <code>list[Layer]</code> <p>List of layers generated by slicing.</p> Source code in <code>src/compas_slicer/slicers/base_slicer.py</code> <pre><code>def __init__(self, mesh: Mesh) -&gt; None:\n    if not isinstance(mesh, Mesh):\n        raise TypeError(f\"Input mesh must be Mesh, not {type(mesh)}\")\n    utils.check_triangular_mesh(mesh)\n\n    self.mesh = mesh\n    logger.info(f\"Input Mesh with: {len(list(self.mesh.vertices()))} vertices, {len(list(self.mesh.faces()))} faces\")\n\n    self.layer_height: float | None = None\n    self.layers: list[Layer] = []\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.BaseSlicer.number_of_points","title":"number_of_points  <code>property</code>","text":"<pre><code>number_of_points\n</code></pre> <p>Total number of points in the slicer.</p>"},{"location":"api/slicers/#compas_slicer.slicers.BaseSlicer.number_of_layers","title":"number_of_layers  <code>property</code>","text":"<pre><code>number_of_layers\n</code></pre> <p>Total number of layers.</p>"},{"location":"api/slicers/#compas_slicer.slicers.BaseSlicer.number_of_paths","title":"number_of_paths  <code>property</code>","text":"<pre><code>number_of_paths\n</code></pre> <p>Total paths, open paths, closed paths.</p>"},{"location":"api/slicers/#compas_slicer.slicers.BaseSlicer.vertical_layers","title":"vertical_layers  <code>property</code>","text":"<pre><code>vertical_layers\n</code></pre> <p>List of all vertical layers in the slicer.</p>"},{"location":"api/slicers/#compas_slicer.slicers.BaseSlicer.horizontal_layers","title":"horizontal_layers  <code>property</code>","text":"<pre><code>horizontal_layers\n</code></pre> <p>List of all non-vertical layers in the slicer.</p>"},{"location":"api/slicers/#compas_slicer.slicers.BaseSlicer.slice_model","title":"slice_model","text":"<pre><code>slice_model(*args, **kwargs)\n</code></pre> <p>Slices the model and applies standard post-processing.</p> Source code in <code>src/compas_slicer/slicers/base_slicer.py</code> <pre><code>def slice_model(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Slices the model and applies standard post-processing.\"\"\"\n    self.generate_paths()\n    self.remove_invalid_paths_and_layers()\n    self.post_processing()\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.BaseSlicer.generate_paths","title":"generate_paths  <code>abstractmethod</code>","text":"<pre><code>generate_paths()\n</code></pre> <p>Generate paths. To be implemented by inheriting classes.</p> Source code in <code>src/compas_slicer/slicers/base_slicer.py</code> <pre><code>@abstractmethod\ndef generate_paths(self) -&gt; None:\n    \"\"\"Generate paths. To be implemented by inheriting classes.\"\"\"\n    pass\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.BaseSlicer.post_processing","title":"post_processing","text":"<pre><code>post_processing()\n</code></pre> <p>Applies standard post-processing: seams_align and unify_paths.</p> Source code in <code>src/compas_slicer/slicers/base_slicer.py</code> <pre><code>def post_processing(self) -&gt; None:\n    \"\"\"Applies standard post-processing: seams_align and unify_paths.\"\"\"\n    self.close_paths()\n    seams_align(self, align_with=\"next_path\")\n    unify_paths_orientation(self)\n    self.close_paths()\n    logger.info(f\"Created {len(self.layers)} Layers with {self.number_of_points} total points\")\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.BaseSlicer.close_paths","title":"close_paths","text":"<pre><code>close_paths()\n</code></pre> <p>For closed paths, ensures first and last point are identical.</p> Source code in <code>src/compas_slicer/slicers/base_slicer.py</code> <pre><code>def close_paths(self) -&gt; None:\n    \"\"\"For closed paths, ensures first and last point are identical.\"\"\"\n    for layer in self.layers:\n        for path in layer.paths:\n            if path.is_closed and distance_point_point_sqrd(path.points[0], path.points[-1]) &gt; 0.00001:\n                path.points.append(path.points[0])\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.BaseSlicer.remove_invalid_paths_and_layers","title":"remove_invalid_paths_and_layers","text":"<pre><code>remove_invalid_paths_and_layers()\n</code></pre> <p>Removes invalid layers and paths from the slicer.</p> Source code in <code>src/compas_slicer/slicers/base_slicer.py</code> <pre><code>def remove_invalid_paths_and_layers(self) -&gt; None:\n    \"\"\"Removes invalid layers and paths from the slicer.\"\"\"\n    paths_to_remove = []\n    layers_to_remove = []\n\n    for i, layer in enumerate(self.layers):\n        for j, path in enumerate(layer.paths):\n            if len(path.points) &lt; 2:\n                paths_to_remove.append(path)\n                logger.warning(f\"Invalid Path: Layer {i}, Path {j}, {path}\")\n                if len(layer.paths) == 1:\n                    layers_to_remove.append(layer)\n                    logger.warning(f\"Invalid Layer: Layer {i}, {layer}\")\n        if len(layer.paths) &lt; 1:\n            layers_to_remove.append(layer)\n            logger.warning(f\"Invalid Layer: Layer {i}, {layer}\")\n\n    for layer in self.layers:\n        for path in list(layer.paths):\n            if path in paths_to_remove:\n                layer.paths.remove(path)\n        if layer in layers_to_remove:\n            self.layers.remove(layer)\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.BaseSlicer.find_vertical_layers_with_first_path_on_base","title":"find_vertical_layers_with_first_path_on_base","text":"<pre><code>find_vertical_layers_with_first_path_on_base()\n</code></pre> <p>Find vertical layers whose first path is on the base.</p> <p>Returns:</p> Type Description <code>tuple[list[Path], list[int]]</code> <p>Paths on base and their vertical layer indices.</p> Source code in <code>src/compas_slicer/slicers/base_slicer.py</code> <pre><code>def find_vertical_layers_with_first_path_on_base(self) -&gt; tuple[list[Path], list[int]]:\n    \"\"\"Find vertical layers whose first path is on the base.\n\n    Returns\n    -------\n    tuple[list[Path], list[int]]\n        Paths on base and their vertical layer indices.\n\n    \"\"\"\n    vertices = list(self.mesh.vertices_attributes('xyz'))\n    bbox = bounding_box(vertices)\n    z_min = min(p[2] for p in bbox)\n    paths_on_base = []\n    vertical_layer_indices = []\n    d_threshold = 30\n\n    for i, vertical_layer in enumerate(self.vertical_layers):\n        first_path = vertical_layer.paths[0]\n        avg_z_dist = np.average(np.array([abs(pt[2] - z_min) for pt in first_path.points]))\n        if avg_z_dist &lt; d_threshold:\n            paths_on_base.append(first_path)\n            vertical_layer_indices.append(i)\n\n    return paths_on_base, vertical_layer_indices\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.BaseSlicer.printout_info","title":"printout_info","text":"<pre><code>printout_info()\n</code></pre> <p>Prints out slicing information.</p> Source code in <code>src/compas_slicer/slicers/base_slicer.py</code> <pre><code>def printout_info(self) -&gt; None:\n    \"\"\"Prints out slicing information.\"\"\"\n    no_of_paths, closed_paths, open_paths = self.number_of_paths\n    logger.info(\"---- Slicer Info ----\")\n    logger.info(f\"Number of layers: {self.number_of_layers}\")\n    logger.info(f\"Number of paths: {no_of_paths}, open: {open_paths}, closed: {closed_paths}\")\n    logger.info(f\"Number of sampling printpoints: {self.number_of_points}\")\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.BaseSlicer.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(data)\n</code></pre> <p>Construct a slicer from its data representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The data dictionary.</p> required <p>Returns:</p> Type Description <code>BaseSlicer</code> <p>The constructed slicer.</p> Source code in <code>src/compas_slicer/slicers/base_slicer.py</code> <pre><code>@classmethod\ndef from_data(cls, data: dict[str, Any]) -&gt; BaseSlicer:\n    \"\"\"Construct a slicer from its data representation.\n\n    Parameters\n    ----------\n    data : dict\n        The data dictionary.\n\n    Returns\n    -------\n    BaseSlicer\n        The constructed slicer.\n\n    \"\"\"\n    mesh = Mesh.__from_data__(data[\"mesh\"])\n    slicer = cls(mesh)\n    layers_data = data[\"layers\"]\n    for layer_key in layers_data:\n        if layers_data[layer_key][\"layer_type\"] == \"horizontal_layer\":\n            slicer.layers.append(Layer.from_data(layers_data[layer_key]))\n        else:\n            slicer.layers.append(VerticalLayer.from_data(layers_data[layer_key]))\n    slicer.layer_height = data[\"layer_height\"]\n    return slicer\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.BaseSlicer.to_json","title":"to_json","text":"<pre><code>to_json(filepath, name)\n</code></pre> <p>Writes the slicer to a JSON file.</p> Source code in <code>src/compas_slicer/slicers/base_slicer.py</code> <pre><code>def to_json(self, filepath: str | FilePath, name: str) -&gt; None:\n    \"\"\"Writes the slicer to a JSON file.\"\"\"\n    utils.save_to_json(self.to_data(), filepath, name)\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.BaseSlicer.to_data","title":"to_data","text":"<pre><code>to_data()\n</code></pre> <p>Returns a dictionary of structured data representing the slicer.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The slicer's data.</p> Source code in <code>src/compas_slicer/slicers/base_slicer.py</code> <pre><code>def to_data(self) -&gt; dict[str, Any]:\n    \"\"\"Returns a dictionary of structured data representing the slicer.\n\n    Returns\n    -------\n    dict\n        The slicer's data.\n\n    \"\"\"\n    mesh = self.mesh.copy()\n    v_key = next(iter(mesh.vertices()))\n    v_attrs = mesh.vertex_attributes(v_key)\n    for attr_key in v_attrs:\n        if not utils.is_jsonable(v_attrs[attr_key]):\n            logger.error(f\"vertex: {attr_key} {v_attrs[attr_key]}\")\n            for v in mesh.vertices():\n                mesh.unset_vertex_attribute(v, attr_key)\n\n    f_key = next(iter(mesh.faces()))\n    f_attrs = mesh.face_attributes(f_key)\n    for attr_key in f_attrs:\n        if not utils.is_jsonable(f_attrs[attr_key]):\n            logger.error(f\"face: {attr_key} {f_attrs[attr_key]}\")\n            mesh.update_default_face_attributes({attr_key: 0.0})\n\n    return {\n        \"layers\": self.get_layers_dict(),\n        \"mesh\": mesh.__data__,\n        \"layer_height\": self.layer_height,\n    }\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.BaseSlicer.get_layers_dict","title":"get_layers_dict","text":"<pre><code>get_layers_dict()\n</code></pre> <p>Returns a dictionary of layers.</p> Source code in <code>src/compas_slicer/slicers/base_slicer.py</code> <pre><code>def get_layers_dict(self) -&gt; dict[int, dict[str, Any]]:\n    \"\"\"Returns a dictionary of layers.\"\"\"\n    return {i: layer.to_data() for i, layer in enumerate(self.layers)}\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.PlanarSlicer","title":"PlanarSlicer","text":"<pre><code>PlanarSlicer(mesh, layer_height=2.0, slice_height_range=None)\n</code></pre> <p>               Bases: <code>BaseSlicer</code></p> <p>Generates planar contours on a mesh that are parallel to the xy plane.</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>Mesh</code> <p>Input mesh, must be triangular (no quads or n-gons allowed).</p> <code>layer_height</code> <code>float</code> <p>Distance between layers (slices) in mm.</p> <code>slice_height_range</code> <code>tuple[float, float] | None</code> <p>Optional tuple (z_start, z_end) to slice only part of the model. Values are relative to mesh minimum height.</p> Source code in <code>src/compas_slicer/slicers/planar_slicer.py</code> <pre><code>def __init__(\n    self,\n    mesh: Mesh,\n    layer_height: float = 2.0,\n    slice_height_range: tuple[float, float] | None = None,\n) -&gt; None:\n    logger.info('PlanarSlicer')\n    BaseSlicer.__init__(self, mesh)\n\n    self.layer_height = layer_height\n    self.slice_height_range = slice_height_range\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.PlanarSlicer.generate_paths","title":"generate_paths","text":"<pre><code>generate_paths()\n</code></pre> <p>Generate the planar slicing paths.</p> Source code in <code>src/compas_slicer/slicers/planar_slicer.py</code> <pre><code>def generate_paths(self) -&gt; None:\n    \"\"\"Generate the planar slicing paths.\"\"\"\n    z = [self.mesh.vertex_attribute(key, 'z') for key in self.mesh.vertices()]\n    min_z, max_z = min(z), max(z)\n\n    if self.slice_height_range:\n        if min_z &lt;= self.slice_height_range[0] &lt;= max_z and min_z &lt;= self.slice_height_range[1] &lt;= max_z:\n            logger.info(f\"Slicing mesh in range from Z = {self.slice_height_range[0]} to Z = {self.slice_height_range[1]}.\")\n            max_z = min_z + self.slice_height_range[1]\n            min_z = min_z + self.slice_height_range[0]\n        else:\n            logger.warning(\"Slice height range out of bounds of geometry, slice height range not used.\")\n\n    d = abs(min_z - max_z)\n    no_of_layers = int(d / self.layer_height) + 1\n    normal = Vector(0, 0, 1)\n    planes = [Plane(Point(0, 0, min_z + i * self.layer_height), normal) for i in range(no_of_layers)]\n\n    logger.info(\"Planar slicing using CGAL ...\")\n    self.layers = create_planar_paths(self.mesh, planes)\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.InterpolationSlicer","title":"InterpolationSlicer","text":"<pre><code>InterpolationSlicer(mesh, preprocessor=None, config=None)\n</code></pre> <p>               Bases: <code>BaseSlicer</code></p> <p>Generates non-planar contours that interpolate user-defined boundaries.</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>Mesh</code> <p>Input mesh, must be triangular (no quads or n-gons allowed). Topology matters; irregular tessellation can lead to undesired results. Recommend: re-topologize, triangulate, and weld mesh in advance.</p> <code>preprocessor</code> <code>InterpolationSlicingPreprocessor | None</code> <p>Preprocessor containing compound targets.</p> <code>config</code> <code>InterpolationConfig</code> <p>Interpolation configuration.</p> <code>n_multiplier</code> <code>float</code> <p>Multiplier for number of isocurves.</p> Source code in <code>src/compas_slicer/slicers/interpolation_slicer.py</code> <pre><code>def __init__(\n    self,\n    mesh: Mesh,\n    preprocessor: InterpolationSlicingPreprocessor | None = None,\n    config: InterpolationConfig | None = None,\n) -&gt; None:\n    logger.info('InterpolationSlicer')\n    BaseSlicer.__init__(self, mesh)\n\n    # make sure the mesh of the preprocessor and the mesh of the slicer match\n    if preprocessor and len(list(mesh.vertices())) != len(list(preprocessor.mesh.vertices())):\n        raise ValueError(\n            f\"Mesh vertex count mismatch: slicer mesh has {len(list(mesh.vertices()))} vertices, \"\n            f\"preprocessor mesh has {len(list(preprocessor.mesh.vertices()))} vertices\"\n        )\n\n    self.config = config if config else InterpolationConfig()\n    self.preprocessor = preprocessor\n    self.n_multiplier: float = 1.0\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.InterpolationSlicer.generate_paths","title":"generate_paths","text":"<pre><code>generate_paths()\n</code></pre> <p>Generate curved paths.</p> Source code in <code>src/compas_slicer/slicers/interpolation_slicer.py</code> <pre><code>def generate_paths(self) -&gt; None:\n    \"\"\"Generate curved paths.\"\"\"\n    if not self.preprocessor:\n        raise ValueError('You need to provide a pre-processor in order to generate paths.')\n\n    avg_layer_height = self.config.avg_layer_height\n    n = find_no_of_isocurves(self.preprocessor.target_LOW, self.preprocessor.target_HIGH, avg_layer_height)\n    params_list = get_interpolation_parameters_list(n)\n    logger.info(f'{n} paths will be generated')\n\n    vertical_layers_manager = VerticalLayersManager(avg_layer_height)\n\n    # create paths + layers\n    with progressbar.ProgressBar(max_value=len(params_list)) as bar:\n        for i, param in enumerate(params_list):\n            assign_interpolation_distance_to_mesh_vertices(self.mesh, param, self.preprocessor.target_LOW,\n                                                           self.preprocessor.target_HIGH)\n            contours = ScalarFieldContours(self.mesh)\n            contours.compute()\n            contours.add_to_vertical_layers_manager(vertical_layers_manager)\n\n            bar.update(i)  # advance progress bar\n\n    self.layers = vertical_layers_manager.layers\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.ScalarFieldSlicer","title":"ScalarFieldSlicer","text":"<pre><code>ScalarFieldSlicer(mesh, scalar_field, no_of_isocurves, config=None)\n</code></pre> <p>               Bases: <code>BaseSlicer</code></p> <p>Generates the isocontours of a scalar field defined on mesh vertices.</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>Mesh</code> <p>Input mesh, must be triangular (no quads or n-gons allowed). Topology matters; irregular tessellation can lead to undesired results. Recommend: re-topologize, triangulate, and weld mesh in advance.</p> <code>scalar_field</code> <code>list[float]</code> <p>One float per vertex representing the scalar field.</p> <code>no_of_isocurves</code> <code>int</code> <p>Number of isocontours to generate.</p> <code>config</code> <code>InterpolationConfig</code> <p>Configuration parameters.</p> Source code in <code>src/compas_slicer/slicers/scalar_field_slicer.py</code> <pre><code>def __init__(\n    self,\n    mesh: Mesh,\n    scalar_field: Sequence[float],\n    no_of_isocurves: int,\n    config: InterpolationConfig | None = None,\n) -&gt; None:\n    logger.info('ScalarFieldSlicer')\n    BaseSlicer.__init__(self, mesh)\n\n    self.no_of_isocurves = no_of_isocurves\n    self.scalar_field: list[float] = list(np.array(scalar_field) - np.min(np.array(scalar_field)))\n    self.config = config if config else InterpolationConfig()\n\n    mesh.update_default_vertex_attributes({'scalar_field': 0})\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.ScalarFieldSlicer.generate_paths","title":"generate_paths","text":"<pre><code>generate_paths()\n</code></pre> <p>Generate isocontours.</p> Source code in <code>src/compas_slicer/slicers/scalar_field_slicer.py</code> <pre><code>def generate_paths(self) -&gt; None:\n    \"\"\"Generate isocontours.\"\"\"\n    start_domain, end_domain = min(self.scalar_field), max(self.scalar_field)\n    step = (end_domain - start_domain) / (self.no_of_isocurves + 1)\n\n    max_dist = self.config.vertical_layers_max_centroid_dist\n    vertical_layers_manager = VerticalLayersManager(max_dist)\n\n    # create paths + layers\n    with progressbar.ProgressBar(max_value=self.no_of_isocurves) as bar:\n        for i in range(0, self.no_of_isocurves + 1):\n            for vkey, data in self.mesh.vertices(data=True):\n                if i == 0:\n                    data['scalar_field'] = self.scalar_field[vkey] - 0.05 * step  # things can be tricky in the edge\n                else:\n                    data['scalar_field'] = self.scalar_field[vkey] - i * step\n\n            contours = ScalarFieldContours(self.mesh)\n            contours.compute()\n            contours.add_to_vertical_layers_manager(vertical_layers_manager)\n\n            bar.update(i)  # advance progress bar\n\n    self.layers = vertical_layers_manager.layers\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.UVSlicer","title":"UVSlicer","text":"<pre><code>UVSlicer(mesh, vkey_to_uv, no_of_isocurves, config=None)\n</code></pre> <p>               Bases: <code>BaseSlicer</code></p> <p>Generates contours on the mesh corresponding to straight lines on the UV plane.</p> <p>Uses a UV map (from 3D space to plane) defined on mesh vertices.</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>Mesh</code> <p>Input mesh, must be triangular (no quads or n-gons allowed). Topology matters; irregular tessellation can lead to undesired results. Recommend: re-topologize, triangulate, and weld mesh in advance.</p> <code>vkey_to_uv</code> <code>dict[int, tuple[float, float]]</code> <p>Mapping from vertex key to UV coordinates. UV should be in [0,1].</p> <code>no_of_isocurves</code> <code>int</code> <p>Number of levels to generate.</p> <code>config</code> <code>InterpolationConfig</code> <p>Configuration parameters.</p> Source code in <code>src/compas_slicer/slicers/uv_slicer.py</code> <pre><code>def __init__(\n    self,\n    mesh: Mesh,\n    vkey_to_uv: dict[int, tuple[float, float]],\n    no_of_isocurves: int,\n    config: InterpolationConfig | None = None,\n) -&gt; None:\n    logger.info('UVSlicer')\n    BaseSlicer.__init__(self, mesh)\n\n    self.vkey_to_uv = vkey_to_uv\n    self.no_of_isocurves = no_of_isocurves\n    self.config = config if config else InterpolationConfig()\n\n    u = [self.vkey_to_uv[vkey][0] for vkey in mesh.vertices()]\n    v = [self.vkey_to_uv[vkey][1] for vkey in mesh.vertices()]\n    u_arr = np.array(u) * float(no_of_isocurves + 1)\n    vkey_to_i = self.mesh.key_index()\n\n    mesh.update_default_vertex_attributes({'uv': 0})\n    for vkey in mesh.vertices():\n        mesh.vertex_attribute(vkey, 'uv', (u_arr[vkey_to_i[vkey]], v[vkey_to_i[vkey]]))\n</code></pre>"},{"location":"api/slicers/#compas_slicer.slicers.UVSlicer.generate_paths","title":"generate_paths","text":"<pre><code>generate_paths()\n</code></pre> <p>Generate isocontours.</p> Source code in <code>src/compas_slicer/slicers/uv_slicer.py</code> <pre><code>def generate_paths(self) -&gt; None:\n    \"\"\"Generate isocontours.\"\"\"\n    paths_type = 'flat'  # 'spiral' # 'zigzag'\n    v_left, v_right = 0.0, 1.0 - 1e-5\n\n    max_dist = self.config.vertical_layers_max_centroid_dist\n    vertical_layers_manager = VerticalLayersManager(max_dist)\n\n    # create paths + layers\n    with progressbar.ProgressBar(max_value=self.no_of_isocurves) as bar:\n        for i in range(0, self.no_of_isocurves + 1):\n            u_val = float(i)\n            if i == 0:\n                u_val += 0.05  # contours are a bit tricky in the edges\n            if paths_type == 'spiral':\n                u1, u2 = u_val, u_val + 1.0\n            else:  # 'flat'\n                u1 = u2 = u_val\n\n            p1 = (u1, v_left)\n            p2 = (u2, v_right)\n\n            contours = UVContours(self.mesh, p1, p2)\n            contours.compute()\n            contours.add_to_vertical_layers_manager(vertical_layers_manager)\n\n            bar.update(i)  # advance progress bar\n\n    self.layers = vertical_layers_manager.layers\n</code></pre>"},{"location":"api/utilities/","title":"Utilities","text":"<p>Helper functions for I/O, geometry operations, and more.</p>"},{"location":"api/utilities/#compas_slicer.utilities","title":"utilities","text":"<p>Helper utilities for I/O, geometry operations, and more.</p>"},{"location":"api/utilities/#compas_slicer.utilities.TerminalCommand","title":"TerminalCommand","text":"<pre><code>TerminalCommand(cmd, cwd=None, env=None)\n</code></pre> <p>Creates a new command container. Note that this immediately executes the command synchronously and writes the return values to the corresponding members.</p> <p>Attributes:</p> Name Type Description <code>cmd</code> <code>The command to execute.</code> <code>cwd</code> <code>The working directory to run the command in.</code> <code>env</code> <code>The environment the command is run in.</code> Source code in <code>src/compas_slicer/utilities/terminal_command.py</code> <pre><code>def __init__(self, cmd, cwd=None, env=None):\n    \"\"\"\n    Creates a new command container.\n    Note that this immediately executes the command synchronously and writes the\n    return values to the corresponding members.\n\n    Attributes\n    ----------\n    cmd : The command to execute.\n    cwd : The working directory to run the command in.\n    env : The environment the command is run in.\n    \"\"\"\n    process = p.Popen(cmd, stdout=p.PIPE, stderr=p.PIPE, shell=True, cwd=cwd, env=env)\n    stdout, stderr = process.communicate()\n\n    self.stdout = stdout.decode('utf8')\n    self.stderr = stderr.decode('utf8')\n\n    self.return_code = process.returncode\n    process.kill()\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.transfer_mesh_attributes_to_printpoints","title":"transfer_mesh_attributes_to_printpoints","text":"<pre><code>transfer_mesh_attributes_to_printpoints(mesh, printpoints)\n</code></pre> <p>Transfers face and vertex attributes from the mesh to the printpoints. Each printpoint is projected to the closest mesh face. It takes directly all the face attributes. It takes the averaged vertex attributes of the face vertices using barycentric coordinates.</p> <p>Face attributes can be anything. Vertex attributes can only be entities that support multiplication with a scalar. They have been tested to work with scalars and np.arrays.</p> <p>The reserved attribute names (see 'is_reserved_attribute(attr)') are not passed on to the printpoints.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh to transfer attributes from.</p> required <code>printpoints</code> <code>PrintPointsCollection</code> <p>The collection of printpoints to transfer attributes to.</p> required Source code in <code>src/compas_slicer/utilities/attributes_transfer.py</code> <pre><code>def transfer_mesh_attributes_to_printpoints(\n    mesh: Mesh,\n    printpoints: PrintPointsCollection,\n) -&gt; None:\n    \"\"\"\n    Transfers face and vertex attributes from the mesh to the printpoints.\n    Each printpoint is projected to the closest mesh face. It takes directly all the face attributes.\n    It takes the averaged vertex attributes of the face vertices using barycentric coordinates.\n\n    Face attributes can be anything.\n    Vertex attributes can only be entities that support multiplication with a scalar. They have been tested to work\n    with scalars and np.arrays.\n\n    The reserved attribute names (see 'is_reserved_attribute(attr)') are not passed on to the printpoints.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh to transfer attributes from.\n    printpoints : PrintPointsCollection\n        The collection of printpoints to transfer attributes to.\n\n    \"\"\"\n    logger.info('Transferring mesh attributes to the printpoints.')\n\n    all_pts = [ppt.pt for ppt in printpoints.iter_printpoints()]\n\n    closest_fks, projected_pts = pull_pts_to_mesh_faces(mesh, all_pts)\n\n    i = 0\n    with progressbar.ProgressBar(max_value=len(all_pts)) as bar:\n        for pp in printpoints.iter_printpoints():\n            fkey = closest_fks[i]\n            proj_pt = projected_pts[i]\n            pp.attributes = transfer_mesh_attributes_to_point(mesh, fkey, proj_pt)\n            i += 1\n            bar.update(i)\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.remap","title":"remap","text":"<pre><code>remap(input_val, in_from, in_to, out_from, out_to)\n</code></pre> <p>Bounded remap from source domain to target domain.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def remap(input_val: float, in_from: float, in_to: float, out_from: float, out_to: float) -&gt; float:\n    \"\"\"Bounded remap from source domain to target domain.\"\"\"\n    if input_val &lt;= in_from:\n        return out_from\n    elif input_val &gt;= in_to:\n        return out_to\n    else:\n        return remap_unbound(input_val, in_from, in_to, out_from, out_to)\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.remap_unbound","title":"remap_unbound","text":"<pre><code>remap_unbound(input_val, in_from, in_to, out_from, out_to)\n</code></pre> <p>Remap input_val from source domain to target domain (no clamping).</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def remap_unbound(input_val: float, in_from: float, in_to: float, out_from: float, out_to: float) -&gt; float:\n    \"\"\"Remap input_val from source domain to target domain (no clamping).\"\"\"\n    out_range = out_to - out_from\n    in_range = in_to - in_from\n    in_val = input_val - in_from\n    val = (float(in_val) / in_range) * out_range\n    out_val = out_from + val\n    return out_val\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.get_output_directory","title":"get_output_directory","text":"<pre><code>get_output_directory(path)\n</code></pre> <p>Get or create 'output' directory in the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path where the 'output' directory will be created.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path to the 'output' directory.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_output_directory(path: str | Path) -&gt; Path:\n    \"\"\"Get or create 'output' directory in the given path.\n\n    Parameters\n    ----------\n    path : str | Path\n        The path where the 'output' directory will be created.\n\n    Returns\n    -------\n    Path\n        The path to the 'output' directory.\n\n    \"\"\"\n    output_dir = Path(path) / 'output'\n    output_dir.mkdir(exist_ok=True)\n    return output_dir\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.get_closest_pt_index","title":"get_closest_pt_index","text":"<pre><code>get_closest_pt_index(pt, pts)\n</code></pre> <p>Find the index of the closest point to pt in pts.</p> <p>Parameters:</p> Name Type Description Default <code>pt</code> <code>Point | NDArray</code> <p>Query point.</p> required <code>pts</code> <code>list[Point] | NDArray</code> <p>Point cloud to search.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index of the closest point.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_closest_pt_index(pt: Point | NDArray, pts: list[Point] | NDArray) -&gt; int:\n    \"\"\"Find the index of the closest point to pt in pts.\n\n    Parameters\n    ----------\n    pt : Point | NDArray\n        Query point.\n    pts : list[Point] | NDArray\n        Point cloud to search.\n\n    Returns\n    -------\n    int\n        Index of the closest point.\n\n    \"\"\"\n    ci: int = closest_point_in_cloud(point=pt, cloud=pts)[2]\n    return ci\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.get_closest_pt","title":"get_closest_pt","text":"<pre><code>get_closest_pt(pt, pts)\n</code></pre> <p>Find the closest point to pt in pts.</p> <p>Parameters:</p> Name Type Description Default <code>pt</code> <code>Point | NDArray</code> <p>Query point.</p> required <code>pts</code> <code>list[Point]</code> <p>Point cloud to search.</p> required <p>Returns:</p> Type Description <code>Point</code> <p>The closest point.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_closest_pt(pt: Point | NDArray, pts: list[Point]) -&gt; Point:\n    \"\"\"Find the closest point to pt in pts.\n\n    Parameters\n    ----------\n    pt : Point | NDArray\n        Query point.\n    pts : list[Point]\n        Point cloud to search.\n\n    Returns\n    -------\n    Point\n        The closest point.\n\n    \"\"\"\n    ci = closest_point_in_cloud(point=pt, cloud=pts)[2]\n    return pts[ci]\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.pull_pts_to_mesh_faces","title":"pull_pts_to_mesh_faces","text":"<pre><code>pull_pts_to_mesh_faces(mesh, points)\n</code></pre> <p>Project points to mesh and find their closest face keys.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh to project onto.</p> required <code>points</code> <code>list[Point]</code> <p>Points to project.</p> required <p>Returns:</p> Type Description <code>tuple[list[int], list[Point]]</code> <p>Closest face keys and projected points.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def pull_pts_to_mesh_faces(mesh: Mesh, points: list[Point]) -&gt; tuple[list[int], list[Point]]:\n    \"\"\"Project points to mesh and find their closest face keys.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh to project onto.\n    points : list[Point]\n        Points to project.\n\n    Returns\n    -------\n    tuple[list[int], list[Point]]\n        Closest face keys and projected points.\n\n    \"\"\"\n    points_arr = np.array(points, dtype=np.float64).reshape((-1, 3))\n    fi_fk = dict(enumerate(mesh.faces()))\n    f_centroids = np.array([mesh.face_centroid(fkey) for fkey in mesh.faces()], dtype=np.float64)\n    closest_fis = np.argmin(scipy.spatial.distance_matrix(points_arr, f_centroids), axis=1)\n    closest_fks = [fi_fk[fi] for fi in closest_fis]\n    projected_pts = [closest_point_on_plane(point, mesh.face_plane(fi)) for point, fi in zip(points_arr, closest_fis)]\n    return closest_fks, projected_pts\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.smooth_vectors","title":"smooth_vectors","text":"<pre><code>smooth_vectors(vectors, strength, iterations)\n</code></pre> <p>Smooth vectors iteratively.</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>list[Vector]</code> <p>Vectors to smooth.</p> required <code>strength</code> <code>float</code> <p>Smoothing strength (0-1).</p> required <code>iterations</code> <code>int</code> <p>Number of smoothing iterations.</p> required <p>Returns:</p> Type Description <code>list[Vector]</code> <p>Smoothed vectors.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def smooth_vectors(vectors: list[Vector], strength: float, iterations: int) -&gt; list[Vector]:\n    \"\"\"Smooth vectors iteratively.\n\n    Parameters\n    ----------\n    vectors : list[Vector]\n        Vectors to smooth.\n    strength : float\n        Smoothing strength (0-1).\n    iterations : int\n        Number of smoothing iterations.\n\n    Returns\n    -------\n    list[Vector]\n        Smoothed vectors.\n\n    \"\"\"\n    for _ in range(iterations):\n        for i, n in enumerate(vectors):\n            if 0 &lt; i &lt; len(vectors) - 1:\n                neighbors_average = (vectors[i - 1] + vectors[i + 1]) * 0.5\n            else:\n                neighbors_average = n\n            vectors[i] = n * (1 - strength) + neighbors_average * strength\n    return vectors\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.save_to_json","title":"save_to_json","text":"<pre><code>save_to_json(data, filepath, name)\n</code></pre> <p>Save data to JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict | list</code> <p>Data to save.</p> required <code>filepath</code> <code>str | Path</code> <p>Directory path.</p> required <code>name</code> <code>str</code> <p>Filename.</p> required Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def save_to_json(\n    data: dict[str, Any] | dict[int, Any] | list[Any], filepath: str | Path, name: str\n) -&gt; None:\n    \"\"\"Save data to JSON file.\n\n    Parameters\n    ----------\n    data : dict | list\n        Data to save.\n    filepath : str | Path\n        Directory path.\n    name : str\n        Filename.\n\n    \"\"\"\n    filename = Path(filepath) / name\n    logger.info(f\"Saving to json: {filename}\")\n    filename.write_text(json.dumps(data, indent=3, sort_keys=True))\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.load_from_json","title":"load_from_json","text":"<pre><code>load_from_json(filepath, name)\n</code></pre> <p>Load data from JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str | Path</code> <p>Directory path.</p> required <code>name</code> <code>str</code> <p>Filename.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Loaded data.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def load_from_json(filepath: str | Path, name: str) -&gt; Any:\n    \"\"\"Load data from JSON file.\n\n    Parameters\n    ----------\n    filepath : str | Path\n        Directory path.\n    name : str\n        Filename.\n\n    Returns\n    -------\n    Any\n        Loaded data.\n\n    \"\"\"\n    filename = Path(filepath) / name\n    data = json.loads(filename.read_text())\n    logger.info(f\"Loaded json: {filename}\")\n    return data\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.is_jsonable","title":"is_jsonable","text":"<pre><code>is_jsonable(x)\n</code></pre> <p>Return True if x can be JSON-serialized.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def is_jsonable(x: Any) -&gt; bool:\n    \"\"\"Return True if x can be JSON-serialized.\"\"\"\n    try:\n        json.dumps(x)\n        return True\n    except TypeError:\n        return False\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.get_jsonable_attributes","title":"get_jsonable_attributes","text":"<pre><code>get_jsonable_attributes(attributes_dict)\n</code></pre> <p>Convert attributes dict to JSON-serializable form.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_jsonable_attributes(attributes_dict: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Convert attributes dict to JSON-serializable form.\"\"\"\n    jsonable_attr: dict[str, Any] = {}\n    for attr_key in attributes_dict:\n        attr = attributes_dict[attr_key]\n        if is_jsonable(attr):\n            jsonable_attr[attr_key] = attr\n        else:\n            if isinstance(attr, np.ndarray):\n                jsonable_attr[attr_key] = list(attr)\n            else:\n                jsonable_attr[attr_key] = 'non serializable attribute'\n    return jsonable_attr\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.save_to_text_file","title":"save_to_text_file","text":"<pre><code>save_to_text_file(data, filepath, name)\n</code></pre> <p>Save text to file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Text to save.</p> required <code>filepath</code> <code>str | Path</code> <p>Directory path.</p> required <code>name</code> <code>str</code> <p>Filename.</p> required Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def save_to_text_file(data: str, filepath: str | Path, name: str) -&gt; None:\n    \"\"\"Save text to file.\n\n    Parameters\n    ----------\n    data : str\n        Text to save.\n    filepath : str | Path\n        Directory path.\n    name : str\n        Filename.\n\n    \"\"\"\n    filename = Path(filepath) / name\n    logger.info(f\"Saving to text file: {filename}\")\n    filename.write_text(data)\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.get_closest_mesh_vkey_to_pt","title":"get_closest_mesh_vkey_to_pt","text":"<pre><code>get_closest_mesh_vkey_to_pt(mesh, pt)\n</code></pre> <p>Find the vertex key closest to the point.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh.</p> required <code>pt</code> <code>Point</code> <p>Query point.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Closest vertex key.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_closest_mesh_vkey_to_pt(mesh: Mesh, pt: Point) -&gt; int:\n    \"\"\"Find the vertex key closest to the point.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh.\n    pt : Point\n        Query point.\n\n    Returns\n    -------\n    int\n        Closest vertex key.\n\n    \"\"\"\n    vertex_tupples = [(v_key, Point(data['x'], data['y'], data['z'])) for v_key, data in mesh.vertices(data=True)]\n    vertex_tupples = sorted(vertex_tupples, key=lambda v_tupple: distance_point_point_sqrd(pt, v_tupple[1]))\n    closest_vkey: int = vertex_tupples[0][0]\n    return closest_vkey\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.get_closest_mesh_normal_to_pt","title":"get_closest_mesh_normal_to_pt","text":"<pre><code>get_closest_mesh_normal_to_pt(mesh, pt)\n</code></pre> <p>Find the closest vertex normal to the point.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh.</p> required <code>pt</code> <code>Point</code> <p>Query point.</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>Normal at closest vertex.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_closest_mesh_normal_to_pt(mesh: Mesh, pt: Point) -&gt; Vector:\n    \"\"\"Find the closest vertex normal to the point.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh.\n    pt : Point\n        Query point.\n\n    Returns\n    -------\n    Vector\n        Normal at closest vertex.\n\n    \"\"\"\n    closest_vkey = get_closest_mesh_vkey_to_pt(mesh, pt)\n    v = mesh.vertex_normal(closest_vkey)\n    return Vector(v[0], v[1], v[2])\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.get_mesh_vertex_coords_with_attribute","title":"get_mesh_vertex_coords_with_attribute","text":"<pre><code>get_mesh_vertex_coords_with_attribute(mesh, attr, value)\n</code></pre> <p>Get coordinates of vertices where attribute equals value.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh.</p> required <code>attr</code> <code>str</code> <p>Attribute name.</p> required <code>value</code> <code>Any</code> <p>Value to match.</p> required <p>Returns:</p> Type Description <code>list[Point]</code> <p>Points of matching vertices.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_mesh_vertex_coords_with_attribute(mesh: Mesh, attr: str, value: Any) -&gt; list[Point]:\n    \"\"\"Get coordinates of vertices where attribute equals value.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh.\n    attr : str\n        Attribute name.\n    value : Any\n        Value to match.\n\n    Returns\n    -------\n    list[Point]\n        Points of matching vertices.\n\n    \"\"\"\n    pts: list[Point] = []\n    for vkey, data in mesh.vertices(data=True):\n        if data[attr] == value:\n            pts.append(Point(*mesh.vertex_coordinates(vkey)))\n    return pts\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.get_normal_of_path_on_xy_plane","title":"get_normal_of_path_on_xy_plane","text":"<pre><code>get_normal_of_path_on_xy_plane(k, point, path, mesh)\n</code></pre> <p>Find the normal of the curve on xy plane at point with index k.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>Index of the point.</p> required <code>point</code> <code>Point</code> <p>The point.</p> required <code>path</code> <code>Path</code> <p>The path containing the point.</p> required <code>mesh</code> <code>Mesh</code> <p>The mesh (fallback for degenerate cases).</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>Normal vector.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_normal_of_path_on_xy_plane(k: int, point: Point, path: SlicerPath, mesh: Mesh) -&gt; Vector:\n    \"\"\"Find the normal of the curve on xy plane at point with index k.\n\n    Parameters\n    ----------\n    k : int\n        Index of the point.\n    point : Point\n        The point.\n    path : SlicerPath\n        The path containing the point.\n    mesh : Mesh\n        The mesh (fallback for degenerate cases).\n\n    Returns\n    -------\n    Vector\n        Normal vector.\n\n    \"\"\"\n    # find mesh normal is not really needed in the 2D case of planar slicer\n    # instead we only need the normal of the curve based on the neighboring pts\n    if (0 &lt; k &lt; len(path.points) - 1) or path.is_closed:\n        prev_pt = path.points[k - 1]\n        next_pt = path.points[(k + 1) % len(path.points)]\n        v1 = np.array(normalize_vector(Vector.from_start_end(prev_pt, point)))\n        v2 = np.array(normalize_vector(Vector.from_start_end(point, next_pt)))\n        v = (v1 + v2) * 0.5\n        normal = [-v[1], v[0], v[2]]  # rotate 90 degrees COUNTER-clockwise on the xy plane\n\n    else:\n        if k == 0:\n            next_pt = path.points[k + 1]\n            v = normalize_vector(Vector.from_start_end(point, next_pt))\n            normal = [-v[1], v[0], v[2]]  # rotate 90 degrees COUNTER-clockwise on the xy plane\n        else:  # k == len(path.points)-1:\n            prev_pt = path.points[k - 1]\n            v = normalize_vector(Vector.from_start_end(point, prev_pt))\n            normal = [v[1], -v[0], v[2]]  # rotate 90 degrees clockwise on the xy plane\n\n    if length_vector(normal) == 0:\n        # When the neighboring elements happen to cancel out, then search for the true normal,\n        # and project it on the xy plane for consistency\n        normal = get_closest_mesh_normal_to_pt(mesh, point)\n        normal = [normal[0], normal[1], 0]\n\n    normal = normalize_vector(normal)\n    normal = Vector(*list(normal))\n    return normal\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.get_mesh_cotmatrix","title":"get_mesh_cotmatrix","text":"<pre><code>get_mesh_cotmatrix(mesh, fix_boundaries=True)\n</code></pre> <p>Get the cotangent Laplacian matrix of the mesh.</p> <p>Computes L_ij = (cot \u03b1_ij + cot \u03b2_ij) / 2 for adjacent vertices, with L_ii = -sum_j L_ij (row sum = 0).</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh (must be triangulated).</p> required <code>fix_boundaries</code> <code>bool</code> <p>If True, zero out rows for boundary vertices.</p> <code>True</code> <p>Returns:</p> Type Description <code>csr_matrix</code> <p>Sparse matrix (V x V), cotangent Laplacian.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_mesh_cotmatrix(mesh: Mesh, fix_boundaries: bool = True) -&gt; csr_matrix:\n    \"\"\"Get the cotangent Laplacian matrix of the mesh.\n\n    Computes L_ij = (cot \u03b1_ij + cot \u03b2_ij) / 2 for adjacent vertices,\n    with L_ii = -sum_j L_ij (row sum = 0).\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh (must be triangulated).\n    fix_boundaries : bool\n        If True, zero out rows for boundary vertices.\n\n    Returns\n    -------\n    csr_matrix\n        Sparse matrix (V x V), cotangent Laplacian.\n\n    \"\"\"\n    V, F = mesh.to_vertices_and_faces()\n    vertices = np.array(V, dtype=np.float64)\n    faces = np.array(F, dtype=np.int32)\n\n    n_vertices = len(vertices)\n\n    # Get cotangent weights for each half-edge\n    # For each face, compute cotangents of all three angles\n    i0, i1, i2 = faces[:, 0], faces[:, 1], faces[:, 2]\n    v0, v1, v2 = vertices[i0], vertices[i1], vertices[i2]\n\n    # Edge vectors\n    e0 = v2 - v1  # opposite to vertex 0\n    e1 = v0 - v2  # opposite to vertex 1\n    e2 = v1 - v0  # opposite to vertex 2\n\n    # Cotangent of angle at vertex i = dot(e_j, e_k) / |cross(e_j, e_k)|\n    # where e_j and e_k are edges adjacent to vertex i\n    def cotangent(a: NDArray, b: NDArray) -&gt; NDArray:\n        cross = np.cross(a, b)\n        cross_norm = np.linalg.norm(cross, axis=1)\n        dot = np.sum(a * b, axis=1)\n        # Avoid division by zero\n        cross_norm = np.maximum(cross_norm, 1e-10)\n        return dot / cross_norm\n\n    # Cotangent at each vertex of each face\n    cot0 = cotangent(-e2, e1)  # angle at vertex 0\n    cot1 = cotangent(-e0, e2)  # angle at vertex 1\n    cot2 = cotangent(-e1, e0)  # angle at vertex 2\n\n    # Build sparse matrix\n    # L_ij += 0.5 * cot(angle opposite to edge ij)\n    row = np.concatenate([i0, i1, i1, i2, i2, i0])\n    col = np.concatenate([i1, i0, i2, i1, i0, i2])\n    data = np.concatenate([cot2, cot2, cot0, cot0, cot1, cot1]) * 0.5\n\n    L = csr_matrix((data, (row, col)), shape=(n_vertices, n_vertices))\n\n    # Make symmetric and set diagonal to negative row sum\n    L = L + L.T\n    L = L - scipy.sparse.diags(np.array(L.sum(axis=1)).flatten())\n\n    if fix_boundaries:\n        # Zero out rows for boundary vertices\n        boundary_mask = np.zeros(n_vertices, dtype=bool)\n        for i, (_vkey, vdata) in enumerate(mesh.vertices(data=True)):\n            if vdata.get('boundary', 0) &gt; 0:\n                boundary_mask[i] = True\n\n        if np.any(boundary_mask):\n            L = L.tolil()\n            for i in np.where(boundary_mask)[0]:\n                L[i, :] = 0\n            L = L.tocsr()\n\n    return L\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.get_mesh_cotans","title":"get_mesh_cotans","text":"<pre><code>get_mesh_cotans(mesh)\n</code></pre> <p>Get the cotangent entries of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh (must be triangulated).</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>F x 3 array of \u00bd*cotangents for corresponding angles. Column i contains cotangent of angle at vertex i of each face.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_mesh_cotans(mesh: Mesh) -&gt; NDArray:\n    \"\"\"Get the cotangent entries of the mesh.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh (must be triangulated).\n\n    Returns\n    -------\n    NDArray\n        F x 3 array of 1/2*cotangents for corresponding angles.\n        Column i contains cotangent of angle at vertex i of each face.\n\n    \"\"\"\n    V, F = mesh.to_vertices_and_faces()\n    vertices = np.array(V, dtype=np.float64)\n    faces = np.array(F, dtype=np.int32)\n\n    i0, i1, i2 = faces[:, 0], faces[:, 1], faces[:, 2]\n    v0, v1, v2 = vertices[i0], vertices[i1], vertices[i2]\n\n    e0 = v2 - v1\n    e1 = v0 - v2\n    e2 = v1 - v0\n\n    def cotangent(a: NDArray, b: NDArray) -&gt; NDArray:\n        cross = np.cross(a, b)\n        cross_norm = np.linalg.norm(cross, axis=1)\n        dot = np.sum(a * b, axis=1)\n        cross_norm = np.maximum(cross_norm, 1e-10)\n        return dot / cross_norm\n\n    cot0 = cotangent(-e2, e1)\n    cot1 = cotangent(-e0, e2)\n    cot2 = cotangent(-e1, e0)\n\n    return np.column_stack([cot0, cot1, cot2]) * 0.5\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.get_mesh_massmatrix","title":"get_mesh_massmatrix","text":"<pre><code>get_mesh_massmatrix(mesh)\n</code></pre> <p>Get the mass matrix of the mesh (Voronoi area weights).</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh (must be triangulated).</p> required <p>Returns:</p> Type Description <code>csr_matrix</code> <p>Sparse diagonal matrix (V x V), vertex areas.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_mesh_massmatrix(mesh: Mesh) -&gt; csr_matrix:\n    \"\"\"Get the mass matrix of the mesh (Voronoi area weights).\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh (must be triangulated).\n\n    Returns\n    -------\n    csr_matrix\n        Sparse diagonal matrix (V x V), vertex areas.\n\n    \"\"\"\n    V, F = mesh.to_vertices_and_faces()\n    vertices = np.array(V, dtype=np.float64)\n    faces = np.array(F, dtype=np.int32)\n\n    n_vertices = len(vertices)\n\n    # Compute face areas\n    i0, i1, i2 = faces[:, 0], faces[:, 1], faces[:, 2]\n    v0, v1, v2 = vertices[i0], vertices[i1], vertices[i2]\n\n    cross = np.cross(v1 - v0, v2 - v0)\n    face_areas = 0.5 * np.linalg.norm(cross, axis=1)\n\n    # Distribute 1/3 of each face area to each vertex\n    vertex_areas = np.zeros(n_vertices)\n    np.add.at(vertex_areas, i0, face_areas / 3)\n    np.add.at(vertex_areas, i1, face_areas / 3)\n    np.add.at(vertex_areas, i2, face_areas / 3)\n\n    return scipy.sparse.diags(vertex_areas)\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.point_list_to_dict","title":"point_list_to_dict","text":"<pre><code>point_list_to_dict(pts_list)\n</code></pre> <p>Convert list of points/vectors to dict for JSON.</p> <p>Parameters:</p> Name Type Description Default <code>pts_list</code> <code>list[Point | Vector]</code> <p>List of points or vectors.</p> required <p>Returns:</p> Type Description <code>dict[int, list[float]]</code> <p>Dict mapping index to [x, y, z].</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def point_list_to_dict(pts_list: list[Point | Vector]) -&gt; dict[int, list[float]]:\n    \"\"\"Convert list of points/vectors to dict for JSON.\n\n    Parameters\n    ----------\n    pts_list : list[Point | Vector]\n        List of points or vectors.\n\n    Returns\n    -------\n    dict[int, list[float]]\n        Dict mapping index to [x, y, z].\n\n    \"\"\"\n    data: dict[int, list[float]] = {}\n    for i in range(len(pts_list)):\n        data[i] = list(pts_list[i])\n    return data\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.point_list_from_dict","title":"point_list_from_dict","text":"<pre><code>point_list_from_dict(data)\n</code></pre> <p>Convert dict of points to list of [x, y, z].</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[Any, list[float]]</code> <p>Dict mapping keys to [x, y, z].</p> required <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>List of [x, y, z] coordinates.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def point_list_from_dict(data: dict[Any, list[float]]) -&gt; list[list[float]]:\n    \"\"\"Convert dict of points to list of [x, y, z].\n\n    Parameters\n    ----------\n    data : dict[Any, list[float]]\n        Dict mapping keys to [x, y, z].\n\n    Returns\n    -------\n    list[list[float]]\n        List of [x, y, z] coordinates.\n\n    \"\"\"\n    return [[data[i][0], data[i][1], data[i][2]] for i in data]\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.flattened_list_of_dictionary","title":"flattened_list_of_dictionary","text":"<pre><code>flattened_list_of_dictionary(dictionary)\n</code></pre> <p>Flatten dictionary values into a single list.</p> <p>Parameters:</p> Name Type Description Default <code>dictionary</code> <code>dict[Any, list[Any]]</code> <p>Dictionary with list values.</p> required <p>Returns:</p> Type Description <code>list[Any]</code> <p>Flattened list.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def flattened_list_of_dictionary(dictionary: dict[Any, list[Any]]) -&gt; list[Any]:\n    \"\"\"Flatten dictionary values into a single list.\n\n    Parameters\n    ----------\n    dictionary : dict[Any, list[Any]]\n        Dictionary with list values.\n\n    Returns\n    -------\n    list[Any]\n        Flattened list.\n\n    \"\"\"\n    flattened_list: list[Any] = []\n    for key in dictionary:\n        for item in dictionary[key]:\n            flattened_list.append(item)\n    return flattened_list\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.get_dict_key_from_value","title":"get_dict_key_from_value","text":"<pre><code>get_dict_key_from_value(dictionary, val)\n</code></pre> <p>Return the key of a dictionary that stores the value.</p> <p>Parameters:</p> Name Type Description Default <code>dictionary</code> <code>dict</code> <p>The dictionary to search.</p> required <code>val</code> <code>Any</code> <p>Value to find.</p> required <p>Returns:</p> Type Description <code>Any | None</code> <p>The key, or None if not found.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_dict_key_from_value(dictionary: dict[Any, Any], val: Any) -&gt; Any | None:\n    \"\"\"Return the key of a dictionary that stores the value.\n\n    Parameters\n    ----------\n    dictionary : dict\n        The dictionary to search.\n    val : Any\n        Value to find.\n\n    Returns\n    -------\n    Any | None\n        The key, or None if not found.\n\n    \"\"\"\n    for key in dictionary:\n        value = dictionary[key]\n        if val == value:\n            return key\n    return None\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.find_next_printpoint","title":"find_next_printpoint","text":"<pre><code>find_next_printpoint(printpoints, i, j, k)\n</code></pre> <p>Returns the next printpoint from the current printpoint if it exists, otherwise returns None.</p> <p>Parameters:</p> Name Type Description Default <code>printpoints</code> <code>PrintPointsCollection</code> <p>The collection of printpoints.</p> required <code>i</code> <code>int</code> <p>Layer index.</p> required <code>j</code> <code>int</code> <p>Path index.</p> required <code>k</code> <code>int</code> <p>Printpoint index within the path.</p> required <p>Returns:</p> Type Description <code>PrintPoint | None</code> <p>The next printpoint or None if at the end.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def find_next_printpoint(\n    printpoints: PrintPointsCollection, i: int, j: int, k: int\n) -&gt; PrintPoint | None:\n    \"\"\"\n    Returns the next printpoint from the current printpoint if it exists, otherwise returns None.\n\n    Parameters\n    ----------\n    printpoints : PrintPointsCollection\n        The collection of printpoints.\n    i : int\n        Layer index.\n    j : int\n        Path index.\n    k : int\n        Printpoint index within the path.\n\n    Returns\n    -------\n    PrintPoint | None\n        The next printpoint or None if at the end.\n\n    \"\"\"\n    next_ppt = None\n    if k &lt; len(printpoints[i][j]) - 1:  # If there are more ppts in the current path\n        next_ppt = printpoints[i][j][k + 1]\n    else:\n        if j &lt; len(printpoints[i]) - 1:  # Otherwise take the next path\n            next_ppt = printpoints[i][j + 1][0]\n        else:\n            if i &lt; len(printpoints) - 1:  # Otherwise take the next layer\n                next_ppt = printpoints[i + 1][0][0]\n    return next_ppt\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.find_previous_printpoint","title":"find_previous_printpoint","text":"<pre><code>find_previous_printpoint(printpoints, i, j, k)\n</code></pre> <p>Returns the previous printpoint from the current printpoint if it exists, otherwise returns None.</p> <p>Parameters:</p> Name Type Description Default <code>printpoints</code> <code>PrintPointsCollection</code> <p>The collection of printpoints.</p> required <code>i</code> <code>int</code> <p>Layer index.</p> required <code>j</code> <code>int</code> <p>Path index.</p> required <code>k</code> <code>int</code> <p>Printpoint index within the path.</p> required <p>Returns:</p> Type Description <code>PrintPoint | None</code> <p>The previous printpoint or None if at the start.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def find_previous_printpoint(\n    printpoints: PrintPointsCollection, i: int, j: int, k: int\n) -&gt; PrintPoint | None:\n    \"\"\"\n    Returns the previous printpoint from the current printpoint if it exists, otherwise returns None.\n\n    Parameters\n    ----------\n    printpoints : PrintPointsCollection\n        The collection of printpoints.\n    i : int\n        Layer index.\n    j : int\n        Path index.\n    k : int\n        Printpoint index within the path.\n\n    Returns\n    -------\n    PrintPoint | None\n        The previous printpoint or None if at the start.\n\n    \"\"\"\n    prev_ppt = None\n    if k &gt; 0:  # If not the first point in a path\n        prev_ppt = printpoints[i][j][k - 1]\n    else:\n        if j &gt; 0:  # Otherwise take the last point of the previous path\n            prev_ppt = printpoints[i][j - 1][-1]\n        else:\n            if i &gt; 0:  # Otherwise take the last path of the previous layer\n                prev_ppt = printpoints[i - 1][-1][-1]\n    return prev_ppt\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.interrupt","title":"interrupt","text":"<pre><code>interrupt()\n</code></pre> <p>Interrupts the flow of the code while it is running. It asks for the user to press a enter to continue or abort.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def interrupt() -&gt; None:\n    \"\"\"\n    Interrupts the flow of the code while it is running.\n    It asks for the user to press a enter to continue or abort.\n    \"\"\"\n    value = input(\"Press enter to continue, Press 1 to abort \")\n    if isinstance(value, str) and value == '1':\n        raise ValueError(\"Aborted\")\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.get_all_files_with_name","title":"get_all_files_with_name","text":"<pre><code>get_all_files_with_name(startswith, endswith, DATA_PATH)\n</code></pre> <p>Finds all the filenames in the DATA_PATH that start and end with the provided strings</p> <p>Parameters:</p> Name Type Description Default <code>startswith</code> <code>str</code> required <code>endswith</code> <code>str</code> required <code>DATA_PATH</code> <code>str | Path</code> required <p>Returns:</p> Type Description <code>list[str]</code> <p>All the filenames</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_all_files_with_name(\n    startswith: str, endswith: str, DATA_PATH: str | Path\n) -&gt; list[str]:\n    \"\"\"\n    Finds all the filenames in the DATA_PATH that start and end with the provided strings\n\n    Parameters\n    ----------\n    startswith: str\n    endswith: str\n    DATA_PATH: str | Path\n\n    Returns\n    ----------\n    list[str]\n        All the filenames\n    \"\"\"\n    files = [f.name for f in Path(DATA_PATH).iterdir()\n             if f.name.startswith(startswith) and f.name.endswith(endswith)]\n    logger.info(f'Reloading: {files}')\n    return files\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.check_package_is_installed","title":"check_package_is_installed","text":"<pre><code>check_package_is_installed(package_name)\n</code></pre> <p>Throws an error if igl python bindings are not installed in the current environment.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def check_package_is_installed(package_name: str) -&gt; None:\n    \"\"\" Throws an error if igl python bindings are not installed in the current environment. \"\"\"\n    packages = TerminalCommand('conda list').get_split_output_strings()\n    if package_name not in packages:\n        raise PluginNotInstalledError(\" ATTENTION! Package : \" + package_name +\n                                      \" is missing! Please follow installation guide to install it.\")\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.attributes_transfer","title":"attributes_transfer","text":""},{"location":"api/utilities/#compas_slicer.utilities.attributes_transfer.transfer_mesh_attributes_to_printpoints","title":"transfer_mesh_attributes_to_printpoints","text":"<pre><code>transfer_mesh_attributes_to_printpoints(mesh, printpoints)\n</code></pre> <p>Transfers face and vertex attributes from the mesh to the printpoints. Each printpoint is projected to the closest mesh face. It takes directly all the face attributes. It takes the averaged vertex attributes of the face vertices using barycentric coordinates.</p> <p>Face attributes can be anything. Vertex attributes can only be entities that support multiplication with a scalar. They have been tested to work with scalars and np.arrays.</p> <p>The reserved attribute names (see 'is_reserved_attribute(attr)') are not passed on to the printpoints.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh to transfer attributes from.</p> required <code>printpoints</code> <code>PrintPointsCollection</code> <p>The collection of printpoints to transfer attributes to.</p> required Source code in <code>src/compas_slicer/utilities/attributes_transfer.py</code> <pre><code>def transfer_mesh_attributes_to_printpoints(\n    mesh: Mesh,\n    printpoints: PrintPointsCollection,\n) -&gt; None:\n    \"\"\"\n    Transfers face and vertex attributes from the mesh to the printpoints.\n    Each printpoint is projected to the closest mesh face. It takes directly all the face attributes.\n    It takes the averaged vertex attributes of the face vertices using barycentric coordinates.\n\n    Face attributes can be anything.\n    Vertex attributes can only be entities that support multiplication with a scalar. They have been tested to work\n    with scalars and np.arrays.\n\n    The reserved attribute names (see 'is_reserved_attribute(attr)') are not passed on to the printpoints.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh to transfer attributes from.\n    printpoints : PrintPointsCollection\n        The collection of printpoints to transfer attributes to.\n\n    \"\"\"\n    logger.info('Transferring mesh attributes to the printpoints.')\n\n    all_pts = [ppt.pt for ppt in printpoints.iter_printpoints()]\n\n    closest_fks, projected_pts = pull_pts_to_mesh_faces(mesh, all_pts)\n\n    i = 0\n    with progressbar.ProgressBar(max_value=len(all_pts)) as bar:\n        for pp in printpoints.iter_printpoints():\n            fkey = closest_fks[i]\n            proj_pt = projected_pts[i]\n            pp.attributes = transfer_mesh_attributes_to_point(mesh, fkey, proj_pt)\n            i += 1\n            bar.update(i)\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.attributes_transfer.is_reserved_attribute","title":"is_reserved_attribute","text":"<pre><code>is_reserved_attribute(attr)\n</code></pre> <p>Returns True if the attribute name is a reserved, false otherwise.</p> Source code in <code>src/compas_slicer/utilities/attributes_transfer.py</code> <pre><code>def is_reserved_attribute(attr: str) -&gt; bool:\n    \"\"\" Returns True if the attribute name is a reserved, false otherwise. \"\"\"\n    taken_attributes = ['x', 'y', 'z', 'uv',\n                        'scalar_field']\n    return attr in taken_attributes\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.attributes_transfer.transfer_mesh_attributes_to_point","title":"transfer_mesh_attributes_to_point","text":"<pre><code>transfer_mesh_attributes_to_point(mesh, fkey, proj_pt)\n</code></pre> <p>It projects the point on the closest face of the mesh. Then if finds all the vertex and face attributes of the face and its attributes and transfers them to the point. The vertex attributes are transferred using barycentric coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> required <code>fkey</code> <code>int</code> required <code>proj_pt</code> <code>list[float]</code> required <p>Returns:</p> Type Description <code>dict that contains all the attributes that correspond to the printpoints position</code> Source code in <code>src/compas_slicer/utilities/attributes_transfer.py</code> <pre><code>def transfer_mesh_attributes_to_point(mesh: Mesh, fkey: int, proj_pt: list[float]) -&gt; dict[str, Any]:\n    \"\"\"\n    It projects the point on the closest face of the mesh. Then if finds\n    all the vertex and face attributes of the face and its attributes and transfers them to the point.\n    The vertex attributes are transferred using barycentric coordinates.\n\n    Parameters\n    ----------\n    mesh: compas.datastructures.Mesh\n    fkey: face key\n    proj_pt: list [x,y,z], point projected on the plane of the face fkey\n\n    Returns\n    -------\n    dict that contains all the attributes that correspond to the printpoints position\n    \"\"\"\n\n    vs = mesh.face_vertices(fkey)\n    bar_coords = barycentric_coordinates(proj_pt, triangle=(mesh.vertex_coordinates(vs[0]),\n                                                            mesh.vertex_coordinates(vs[1]),\n                                                            mesh.vertex_coordinates(vs[2])))\n\n    # get face attributes\n    face_attrs = mesh.face_attributes(fkey)\n    keys_to_remove = [attr for attr in face_attrs if is_reserved_attribute(attr)]\n    for key in keys_to_remove:\n        del face_attrs[key]  # remove from face_attrs dictionary\n\n    # get vertex attributes using barycentric coordinates\n    vs = mesh.face_vertices(fkey)\n    vertex_attrs: dict[str, Any] = {}\n    checked_attrs: list[str] = []\n    for attr in mesh.vertex_attributes(vs[0]):\n        if not is_reserved_attribute(attr):\n            if attr not in checked_attrs:\n                check_that_attribute_can_be_multiplied(attr, mesh.vertex_attributes(vs[0])[attr])\n                checked_attrs.append(attr)\n            vertex_attrs[attr] = 0\n            vertex_attrs[attr] += bar_coords[0] * mesh.vertex_attributes(vs[0])[attr]\n            vertex_attrs[attr] += bar_coords[1] * mesh.vertex_attributes(vs[1])[attr]\n            vertex_attrs[attr] += bar_coords[2] * mesh.vertex_attributes(vs[2])[attr]\n\n    vertex_attrs.update(face_attrs)  # merge two dictionaries\n    return vertex_attrs\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.terminal_command","title":"terminal_command","text":"<p>TerminalCommand class is used to run commands from python as if we are in a shell/cmd</p>"},{"location":"api/utilities/#compas_slicer.utilities.terminal_command.TerminalCommand","title":"TerminalCommand","text":"<pre><code>TerminalCommand(cmd, cwd=None, env=None)\n</code></pre> <p>Creates a new command container. Note that this immediately executes the command synchronously and writes the return values to the corresponding members.</p> <p>Attributes:</p> Name Type Description <code>cmd</code> <code>The command to execute.</code> <code>cwd</code> <code>The working directory to run the command in.</code> <code>env</code> <code>The environment the command is run in.</code> Source code in <code>src/compas_slicer/utilities/terminal_command.py</code> <pre><code>def __init__(self, cmd, cwd=None, env=None):\n    \"\"\"\n    Creates a new command container.\n    Note that this immediately executes the command synchronously and writes the\n    return values to the corresponding members.\n\n    Attributes\n    ----------\n    cmd : The command to execute.\n    cwd : The working directory to run the command in.\n    env : The environment the command is run in.\n    \"\"\"\n    process = p.Popen(cmd, stdout=p.PIPE, stderr=p.PIPE, shell=True, cwd=cwd, env=env)\n    stdout, stderr = process.communicate()\n\n    self.stdout = stdout.decode('utf8')\n    self.stderr = stderr.decode('utf8')\n\n    self.return_code = process.returncode\n    process.kill()\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils","title":"utils","text":""},{"location":"api/utilities/#compas_slicer.utilities.utils.remap","title":"remap","text":"<pre><code>remap(input_val, in_from, in_to, out_from, out_to)\n</code></pre> <p>Bounded remap from source domain to target domain.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def remap(input_val: float, in_from: float, in_to: float, out_from: float, out_to: float) -&gt; float:\n    \"\"\"Bounded remap from source domain to target domain.\"\"\"\n    if input_val &lt;= in_from:\n        return out_from\n    elif input_val &gt;= in_to:\n        return out_to\n    else:\n        return remap_unbound(input_val, in_from, in_to, out_from, out_to)\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.remap_unbound","title":"remap_unbound","text":"<pre><code>remap_unbound(input_val, in_from, in_to, out_from, out_to)\n</code></pre> <p>Remap input_val from source domain to target domain (no clamping).</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def remap_unbound(input_val: float, in_from: float, in_to: float, out_from: float, out_to: float) -&gt; float:\n    \"\"\"Remap input_val from source domain to target domain (no clamping).\"\"\"\n    out_range = out_to - out_from\n    in_range = in_to - in_from\n    in_val = input_val - in_from\n    val = (float(in_val) / in_range) * out_range\n    out_val = out_from + val\n    return out_val\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.get_output_directory","title":"get_output_directory","text":"<pre><code>get_output_directory(path)\n</code></pre> <p>Get or create 'output' directory in the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path where the 'output' directory will be created.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path to the 'output' directory.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_output_directory(path: str | Path) -&gt; Path:\n    \"\"\"Get or create 'output' directory in the given path.\n\n    Parameters\n    ----------\n    path : str | Path\n        The path where the 'output' directory will be created.\n\n    Returns\n    -------\n    Path\n        The path to the 'output' directory.\n\n    \"\"\"\n    output_dir = Path(path) / 'output'\n    output_dir.mkdir(exist_ok=True)\n    return output_dir\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.get_closest_pt_index","title":"get_closest_pt_index","text":"<pre><code>get_closest_pt_index(pt, pts)\n</code></pre> <p>Find the index of the closest point to pt in pts.</p> <p>Parameters:</p> Name Type Description Default <code>pt</code> <code>Point | NDArray</code> <p>Query point.</p> required <code>pts</code> <code>list[Point] | NDArray</code> <p>Point cloud to search.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index of the closest point.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_closest_pt_index(pt: Point | NDArray, pts: list[Point] | NDArray) -&gt; int:\n    \"\"\"Find the index of the closest point to pt in pts.\n\n    Parameters\n    ----------\n    pt : Point | NDArray\n        Query point.\n    pts : list[Point] | NDArray\n        Point cloud to search.\n\n    Returns\n    -------\n    int\n        Index of the closest point.\n\n    \"\"\"\n    ci: int = closest_point_in_cloud(point=pt, cloud=pts)[2]\n    return ci\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.get_closest_pt","title":"get_closest_pt","text":"<pre><code>get_closest_pt(pt, pts)\n</code></pre> <p>Find the closest point to pt in pts.</p> <p>Parameters:</p> Name Type Description Default <code>pt</code> <code>Point | NDArray</code> <p>Query point.</p> required <code>pts</code> <code>list[Point]</code> <p>Point cloud to search.</p> required <p>Returns:</p> Type Description <code>Point</code> <p>The closest point.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_closest_pt(pt: Point | NDArray, pts: list[Point]) -&gt; Point:\n    \"\"\"Find the closest point to pt in pts.\n\n    Parameters\n    ----------\n    pt : Point | NDArray\n        Query point.\n    pts : list[Point]\n        Point cloud to search.\n\n    Returns\n    -------\n    Point\n        The closest point.\n\n    \"\"\"\n    ci = closest_point_in_cloud(point=pt, cloud=pts)[2]\n    return pts[ci]\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.pull_pts_to_mesh_faces","title":"pull_pts_to_mesh_faces","text":"<pre><code>pull_pts_to_mesh_faces(mesh, points)\n</code></pre> <p>Project points to mesh and find their closest face keys.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh to project onto.</p> required <code>points</code> <code>list[Point]</code> <p>Points to project.</p> required <p>Returns:</p> Type Description <code>tuple[list[int], list[Point]]</code> <p>Closest face keys and projected points.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def pull_pts_to_mesh_faces(mesh: Mesh, points: list[Point]) -&gt; tuple[list[int], list[Point]]:\n    \"\"\"Project points to mesh and find their closest face keys.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh to project onto.\n    points : list[Point]\n        Points to project.\n\n    Returns\n    -------\n    tuple[list[int], list[Point]]\n        Closest face keys and projected points.\n\n    \"\"\"\n    points_arr = np.array(points, dtype=np.float64).reshape((-1, 3))\n    fi_fk = dict(enumerate(mesh.faces()))\n    f_centroids = np.array([mesh.face_centroid(fkey) for fkey in mesh.faces()], dtype=np.float64)\n    closest_fis = np.argmin(scipy.spatial.distance_matrix(points_arr, f_centroids), axis=1)\n    closest_fks = [fi_fk[fi] for fi in closest_fis]\n    projected_pts = [closest_point_on_plane(point, mesh.face_plane(fi)) for point, fi in zip(points_arr, closest_fis)]\n    return closest_fks, projected_pts\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.smooth_vectors","title":"smooth_vectors","text":"<pre><code>smooth_vectors(vectors, strength, iterations)\n</code></pre> <p>Smooth vectors iteratively.</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>list[Vector]</code> <p>Vectors to smooth.</p> required <code>strength</code> <code>float</code> <p>Smoothing strength (0-1).</p> required <code>iterations</code> <code>int</code> <p>Number of smoothing iterations.</p> required <p>Returns:</p> Type Description <code>list[Vector]</code> <p>Smoothed vectors.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def smooth_vectors(vectors: list[Vector], strength: float, iterations: int) -&gt; list[Vector]:\n    \"\"\"Smooth vectors iteratively.\n\n    Parameters\n    ----------\n    vectors : list[Vector]\n        Vectors to smooth.\n    strength : float\n        Smoothing strength (0-1).\n    iterations : int\n        Number of smoothing iterations.\n\n    Returns\n    -------\n    list[Vector]\n        Smoothed vectors.\n\n    \"\"\"\n    for _ in range(iterations):\n        for i, n in enumerate(vectors):\n            if 0 &lt; i &lt; len(vectors) - 1:\n                neighbors_average = (vectors[i - 1] + vectors[i + 1]) * 0.5\n            else:\n                neighbors_average = n\n            vectors[i] = n * (1 - strength) + neighbors_average * strength\n    return vectors\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.save_to_json","title":"save_to_json","text":"<pre><code>save_to_json(data, filepath, name)\n</code></pre> <p>Save data to JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict | list</code> <p>Data to save.</p> required <code>filepath</code> <code>str | Path</code> <p>Directory path.</p> required <code>name</code> <code>str</code> <p>Filename.</p> required Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def save_to_json(\n    data: dict[str, Any] | dict[int, Any] | list[Any], filepath: str | Path, name: str\n) -&gt; None:\n    \"\"\"Save data to JSON file.\n\n    Parameters\n    ----------\n    data : dict | list\n        Data to save.\n    filepath : str | Path\n        Directory path.\n    name : str\n        Filename.\n\n    \"\"\"\n    filename = Path(filepath) / name\n    logger.info(f\"Saving to json: {filename}\")\n    filename.write_text(json.dumps(data, indent=3, sort_keys=True))\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.load_from_json","title":"load_from_json","text":"<pre><code>load_from_json(filepath, name)\n</code></pre> <p>Load data from JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str | Path</code> <p>Directory path.</p> required <code>name</code> <code>str</code> <p>Filename.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Loaded data.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def load_from_json(filepath: str | Path, name: str) -&gt; Any:\n    \"\"\"Load data from JSON file.\n\n    Parameters\n    ----------\n    filepath : str | Path\n        Directory path.\n    name : str\n        Filename.\n\n    Returns\n    -------\n    Any\n        Loaded data.\n\n    \"\"\"\n    filename = Path(filepath) / name\n    data = json.loads(filename.read_text())\n    logger.info(f\"Loaded json: {filename}\")\n    return data\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.is_jsonable","title":"is_jsonable","text":"<pre><code>is_jsonable(x)\n</code></pre> <p>Return True if x can be JSON-serialized.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def is_jsonable(x: Any) -&gt; bool:\n    \"\"\"Return True if x can be JSON-serialized.\"\"\"\n    try:\n        json.dumps(x)\n        return True\n    except TypeError:\n        return False\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.get_jsonable_attributes","title":"get_jsonable_attributes","text":"<pre><code>get_jsonable_attributes(attributes_dict)\n</code></pre> <p>Convert attributes dict to JSON-serializable form.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_jsonable_attributes(attributes_dict: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Convert attributes dict to JSON-serializable form.\"\"\"\n    jsonable_attr: dict[str, Any] = {}\n    for attr_key in attributes_dict:\n        attr = attributes_dict[attr_key]\n        if is_jsonable(attr):\n            jsonable_attr[attr_key] = attr\n        else:\n            if isinstance(attr, np.ndarray):\n                jsonable_attr[attr_key] = list(attr)\n            else:\n                jsonable_attr[attr_key] = 'non serializable attribute'\n    return jsonable_attr\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.save_to_text_file","title":"save_to_text_file","text":"<pre><code>save_to_text_file(data, filepath, name)\n</code></pre> <p>Save text to file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Text to save.</p> required <code>filepath</code> <code>str | Path</code> <p>Directory path.</p> required <code>name</code> <code>str</code> <p>Filename.</p> required Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def save_to_text_file(data: str, filepath: str | Path, name: str) -&gt; None:\n    \"\"\"Save text to file.\n\n    Parameters\n    ----------\n    data : str\n        Text to save.\n    filepath : str | Path\n        Directory path.\n    name : str\n        Filename.\n\n    \"\"\"\n    filename = Path(filepath) / name\n    logger.info(f\"Saving to text file: {filename}\")\n    filename.write_text(data)\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.check_triangular_mesh","title":"check_triangular_mesh","text":"<pre><code>check_triangular_mesh(mesh)\n</code></pre> <p>Check if mesh is triangular, raise TypeError if not.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh to check.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If any face is not a triangle.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def check_triangular_mesh(mesh: Mesh) -&gt; None:\n    \"\"\"Check if mesh is triangular, raise TypeError if not.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh to check.\n\n    Raises\n    ------\n    TypeError\n        If any face is not a triangle.\n\n    \"\"\"\n    for f_key in mesh.faces():\n        vs = mesh.face_vertices(f_key)\n        if len(vs) != 3:\n            raise TypeError(f\"Found quad at face {f_key}, vertices: {len(vs)}. Only triangular meshes supported.\")\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.get_closest_mesh_vkey_to_pt","title":"get_closest_mesh_vkey_to_pt","text":"<pre><code>get_closest_mesh_vkey_to_pt(mesh, pt)\n</code></pre> <p>Find the vertex key closest to the point.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh.</p> required <code>pt</code> <code>Point</code> <p>Query point.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Closest vertex key.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_closest_mesh_vkey_to_pt(mesh: Mesh, pt: Point) -&gt; int:\n    \"\"\"Find the vertex key closest to the point.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh.\n    pt : Point\n        Query point.\n\n    Returns\n    -------\n    int\n        Closest vertex key.\n\n    \"\"\"\n    vertex_tupples = [(v_key, Point(data['x'], data['y'], data['z'])) for v_key, data in mesh.vertices(data=True)]\n    vertex_tupples = sorted(vertex_tupples, key=lambda v_tupple: distance_point_point_sqrd(pt, v_tupple[1]))\n    closest_vkey: int = vertex_tupples[0][0]\n    return closest_vkey\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.get_closest_mesh_normal_to_pt","title":"get_closest_mesh_normal_to_pt","text":"<pre><code>get_closest_mesh_normal_to_pt(mesh, pt)\n</code></pre> <p>Find the closest vertex normal to the point.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh.</p> required <code>pt</code> <code>Point</code> <p>Query point.</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>Normal at closest vertex.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_closest_mesh_normal_to_pt(mesh: Mesh, pt: Point) -&gt; Vector:\n    \"\"\"Find the closest vertex normal to the point.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh.\n    pt : Point\n        Query point.\n\n    Returns\n    -------\n    Vector\n        Normal at closest vertex.\n\n    \"\"\"\n    closest_vkey = get_closest_mesh_vkey_to_pt(mesh, pt)\n    v = mesh.vertex_normal(closest_vkey)\n    return Vector(v[0], v[1], v[2])\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.get_mesh_vertex_coords_with_attribute","title":"get_mesh_vertex_coords_with_attribute","text":"<pre><code>get_mesh_vertex_coords_with_attribute(mesh, attr, value)\n</code></pre> <p>Get coordinates of vertices where attribute equals value.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh.</p> required <code>attr</code> <code>str</code> <p>Attribute name.</p> required <code>value</code> <code>Any</code> <p>Value to match.</p> required <p>Returns:</p> Type Description <code>list[Point]</code> <p>Points of matching vertices.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_mesh_vertex_coords_with_attribute(mesh: Mesh, attr: str, value: Any) -&gt; list[Point]:\n    \"\"\"Get coordinates of vertices where attribute equals value.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh.\n    attr : str\n        Attribute name.\n    value : Any\n        Value to match.\n\n    Returns\n    -------\n    list[Point]\n        Points of matching vertices.\n\n    \"\"\"\n    pts: list[Point] = []\n    for vkey, data in mesh.vertices(data=True):\n        if data[attr] == value:\n            pts.append(Point(*mesh.vertex_coordinates(vkey)))\n    return pts\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.get_normal_of_path_on_xy_plane","title":"get_normal_of_path_on_xy_plane","text":"<pre><code>get_normal_of_path_on_xy_plane(k, point, path, mesh)\n</code></pre> <p>Find the normal of the curve on xy plane at point with index k.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>Index of the point.</p> required <code>point</code> <code>Point</code> <p>The point.</p> required <code>path</code> <code>Path</code> <p>The path containing the point.</p> required <code>mesh</code> <code>Mesh</code> <p>The mesh (fallback for degenerate cases).</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>Normal vector.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_normal_of_path_on_xy_plane(k: int, point: Point, path: SlicerPath, mesh: Mesh) -&gt; Vector:\n    \"\"\"Find the normal of the curve on xy plane at point with index k.\n\n    Parameters\n    ----------\n    k : int\n        Index of the point.\n    point : Point\n        The point.\n    path : SlicerPath\n        The path containing the point.\n    mesh : Mesh\n        The mesh (fallback for degenerate cases).\n\n    Returns\n    -------\n    Vector\n        Normal vector.\n\n    \"\"\"\n    # find mesh normal is not really needed in the 2D case of planar slicer\n    # instead we only need the normal of the curve based on the neighboring pts\n    if (0 &lt; k &lt; len(path.points) - 1) or path.is_closed:\n        prev_pt = path.points[k - 1]\n        next_pt = path.points[(k + 1) % len(path.points)]\n        v1 = np.array(normalize_vector(Vector.from_start_end(prev_pt, point)))\n        v2 = np.array(normalize_vector(Vector.from_start_end(point, next_pt)))\n        v = (v1 + v2) * 0.5\n        normal = [-v[1], v[0], v[2]]  # rotate 90 degrees COUNTER-clockwise on the xy plane\n\n    else:\n        if k == 0:\n            next_pt = path.points[k + 1]\n            v = normalize_vector(Vector.from_start_end(point, next_pt))\n            normal = [-v[1], v[0], v[2]]  # rotate 90 degrees COUNTER-clockwise on the xy plane\n        else:  # k == len(path.points)-1:\n            prev_pt = path.points[k - 1]\n            v = normalize_vector(Vector.from_start_end(point, prev_pt))\n            normal = [v[1], -v[0], v[2]]  # rotate 90 degrees clockwise on the xy plane\n\n    if length_vector(normal) == 0:\n        # When the neighboring elements happen to cancel out, then search for the true normal,\n        # and project it on the xy plane for consistency\n        normal = get_closest_mesh_normal_to_pt(mesh, point)\n        normal = [normal[0], normal[1], 0]\n\n    normal = normalize_vector(normal)\n    normal = Vector(*list(normal))\n    return normal\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.get_mesh_cotmatrix","title":"get_mesh_cotmatrix","text":"<pre><code>get_mesh_cotmatrix(mesh, fix_boundaries=True)\n</code></pre> <p>Get the cotangent Laplacian matrix of the mesh.</p> <p>Computes L_ij = (cot \u03b1_ij + cot \u03b2_ij) / 2 for adjacent vertices, with L_ii = -sum_j L_ij (row sum = 0).</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh (must be triangulated).</p> required <code>fix_boundaries</code> <code>bool</code> <p>If True, zero out rows for boundary vertices.</p> <code>True</code> <p>Returns:</p> Type Description <code>csr_matrix</code> <p>Sparse matrix (V x V), cotangent Laplacian.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_mesh_cotmatrix(mesh: Mesh, fix_boundaries: bool = True) -&gt; csr_matrix:\n    \"\"\"Get the cotangent Laplacian matrix of the mesh.\n\n    Computes L_ij = (cot \u03b1_ij + cot \u03b2_ij) / 2 for adjacent vertices,\n    with L_ii = -sum_j L_ij (row sum = 0).\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh (must be triangulated).\n    fix_boundaries : bool\n        If True, zero out rows for boundary vertices.\n\n    Returns\n    -------\n    csr_matrix\n        Sparse matrix (V x V), cotangent Laplacian.\n\n    \"\"\"\n    V, F = mesh.to_vertices_and_faces()\n    vertices = np.array(V, dtype=np.float64)\n    faces = np.array(F, dtype=np.int32)\n\n    n_vertices = len(vertices)\n\n    # Get cotangent weights for each half-edge\n    # For each face, compute cotangents of all three angles\n    i0, i1, i2 = faces[:, 0], faces[:, 1], faces[:, 2]\n    v0, v1, v2 = vertices[i0], vertices[i1], vertices[i2]\n\n    # Edge vectors\n    e0 = v2 - v1  # opposite to vertex 0\n    e1 = v0 - v2  # opposite to vertex 1\n    e2 = v1 - v0  # opposite to vertex 2\n\n    # Cotangent of angle at vertex i = dot(e_j, e_k) / |cross(e_j, e_k)|\n    # where e_j and e_k are edges adjacent to vertex i\n    def cotangent(a: NDArray, b: NDArray) -&gt; NDArray:\n        cross = np.cross(a, b)\n        cross_norm = np.linalg.norm(cross, axis=1)\n        dot = np.sum(a * b, axis=1)\n        # Avoid division by zero\n        cross_norm = np.maximum(cross_norm, 1e-10)\n        return dot / cross_norm\n\n    # Cotangent at each vertex of each face\n    cot0 = cotangent(-e2, e1)  # angle at vertex 0\n    cot1 = cotangent(-e0, e2)  # angle at vertex 1\n    cot2 = cotangent(-e1, e0)  # angle at vertex 2\n\n    # Build sparse matrix\n    # L_ij += 0.5 * cot(angle opposite to edge ij)\n    row = np.concatenate([i0, i1, i1, i2, i2, i0])\n    col = np.concatenate([i1, i0, i2, i1, i0, i2])\n    data = np.concatenate([cot2, cot2, cot0, cot0, cot1, cot1]) * 0.5\n\n    L = csr_matrix((data, (row, col)), shape=(n_vertices, n_vertices))\n\n    # Make symmetric and set diagonal to negative row sum\n    L = L + L.T\n    L = L - scipy.sparse.diags(np.array(L.sum(axis=1)).flatten())\n\n    if fix_boundaries:\n        # Zero out rows for boundary vertices\n        boundary_mask = np.zeros(n_vertices, dtype=bool)\n        for i, (_vkey, vdata) in enumerate(mesh.vertices(data=True)):\n            if vdata.get('boundary', 0) &gt; 0:\n                boundary_mask[i] = True\n\n        if np.any(boundary_mask):\n            L = L.tolil()\n            for i in np.where(boundary_mask)[0]:\n                L[i, :] = 0\n            L = L.tocsr()\n\n    return L\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.get_mesh_cotans","title":"get_mesh_cotans","text":"<pre><code>get_mesh_cotans(mesh)\n</code></pre> <p>Get the cotangent entries of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh (must be triangulated).</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>F x 3 array of \u00bd*cotangents for corresponding angles. Column i contains cotangent of angle at vertex i of each face.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_mesh_cotans(mesh: Mesh) -&gt; NDArray:\n    \"\"\"Get the cotangent entries of the mesh.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh (must be triangulated).\n\n    Returns\n    -------\n    NDArray\n        F x 3 array of 1/2*cotangents for corresponding angles.\n        Column i contains cotangent of angle at vertex i of each face.\n\n    \"\"\"\n    V, F = mesh.to_vertices_and_faces()\n    vertices = np.array(V, dtype=np.float64)\n    faces = np.array(F, dtype=np.int32)\n\n    i0, i1, i2 = faces[:, 0], faces[:, 1], faces[:, 2]\n    v0, v1, v2 = vertices[i0], vertices[i1], vertices[i2]\n\n    e0 = v2 - v1\n    e1 = v0 - v2\n    e2 = v1 - v0\n\n    def cotangent(a: NDArray, b: NDArray) -&gt; NDArray:\n        cross = np.cross(a, b)\n        cross_norm = np.linalg.norm(cross, axis=1)\n        dot = np.sum(a * b, axis=1)\n        cross_norm = np.maximum(cross_norm, 1e-10)\n        return dot / cross_norm\n\n    cot0 = cotangent(-e2, e1)\n    cot1 = cotangent(-e0, e2)\n    cot2 = cotangent(-e1, e0)\n\n    return np.column_stack([cot0, cot1, cot2]) * 0.5\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.get_mesh_massmatrix","title":"get_mesh_massmatrix","text":"<pre><code>get_mesh_massmatrix(mesh)\n</code></pre> <p>Get the mass matrix of the mesh (Voronoi area weights).</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Mesh</code> <p>The mesh (must be triangulated).</p> required <p>Returns:</p> Type Description <code>csr_matrix</code> <p>Sparse diagonal matrix (V x V), vertex areas.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_mesh_massmatrix(mesh: Mesh) -&gt; csr_matrix:\n    \"\"\"Get the mass matrix of the mesh (Voronoi area weights).\n\n    Parameters\n    ----------\n    mesh : Mesh\n        The mesh (must be triangulated).\n\n    Returns\n    -------\n    csr_matrix\n        Sparse diagonal matrix (V x V), vertex areas.\n\n    \"\"\"\n    V, F = mesh.to_vertices_and_faces()\n    vertices = np.array(V, dtype=np.float64)\n    faces = np.array(F, dtype=np.int32)\n\n    n_vertices = len(vertices)\n\n    # Compute face areas\n    i0, i1, i2 = faces[:, 0], faces[:, 1], faces[:, 2]\n    v0, v1, v2 = vertices[i0], vertices[i1], vertices[i2]\n\n    cross = np.cross(v1 - v0, v2 - v0)\n    face_areas = 0.5 * np.linalg.norm(cross, axis=1)\n\n    # Distribute 1/3 of each face area to each vertex\n    vertex_areas = np.zeros(n_vertices)\n    np.add.at(vertex_areas, i0, face_areas / 3)\n    np.add.at(vertex_areas, i1, face_areas / 3)\n    np.add.at(vertex_areas, i2, face_areas / 3)\n\n    return scipy.sparse.diags(vertex_areas)\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.point_list_to_dict","title":"point_list_to_dict","text":"<pre><code>point_list_to_dict(pts_list)\n</code></pre> <p>Convert list of points/vectors to dict for JSON.</p> <p>Parameters:</p> Name Type Description Default <code>pts_list</code> <code>list[Point | Vector]</code> <p>List of points or vectors.</p> required <p>Returns:</p> Type Description <code>dict[int, list[float]]</code> <p>Dict mapping index to [x, y, z].</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def point_list_to_dict(pts_list: list[Point | Vector]) -&gt; dict[int, list[float]]:\n    \"\"\"Convert list of points/vectors to dict for JSON.\n\n    Parameters\n    ----------\n    pts_list : list[Point | Vector]\n        List of points or vectors.\n\n    Returns\n    -------\n    dict[int, list[float]]\n        Dict mapping index to [x, y, z].\n\n    \"\"\"\n    data: dict[int, list[float]] = {}\n    for i in range(len(pts_list)):\n        data[i] = list(pts_list[i])\n    return data\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.point_list_from_dict","title":"point_list_from_dict","text":"<pre><code>point_list_from_dict(data)\n</code></pre> <p>Convert dict of points to list of [x, y, z].</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[Any, list[float]]</code> <p>Dict mapping keys to [x, y, z].</p> required <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>List of [x, y, z] coordinates.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def point_list_from_dict(data: dict[Any, list[float]]) -&gt; list[list[float]]:\n    \"\"\"Convert dict of points to list of [x, y, z].\n\n    Parameters\n    ----------\n    data : dict[Any, list[float]]\n        Dict mapping keys to [x, y, z].\n\n    Returns\n    -------\n    list[list[float]]\n        List of [x, y, z] coordinates.\n\n    \"\"\"\n    return [[data[i][0], data[i][1], data[i][2]] for i in data]\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.flattened_list_of_dictionary","title":"flattened_list_of_dictionary","text":"<pre><code>flattened_list_of_dictionary(dictionary)\n</code></pre> <p>Flatten dictionary values into a single list.</p> <p>Parameters:</p> Name Type Description Default <code>dictionary</code> <code>dict[Any, list[Any]]</code> <p>Dictionary with list values.</p> required <p>Returns:</p> Type Description <code>list[Any]</code> <p>Flattened list.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def flattened_list_of_dictionary(dictionary: dict[Any, list[Any]]) -&gt; list[Any]:\n    \"\"\"Flatten dictionary values into a single list.\n\n    Parameters\n    ----------\n    dictionary : dict[Any, list[Any]]\n        Dictionary with list values.\n\n    Returns\n    -------\n    list[Any]\n        Flattened list.\n\n    \"\"\"\n    flattened_list: list[Any] = []\n    for key in dictionary:\n        for item in dictionary[key]:\n            flattened_list.append(item)\n    return flattened_list\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.get_dict_key_from_value","title":"get_dict_key_from_value","text":"<pre><code>get_dict_key_from_value(dictionary, val)\n</code></pre> <p>Return the key of a dictionary that stores the value.</p> <p>Parameters:</p> Name Type Description Default <code>dictionary</code> <code>dict</code> <p>The dictionary to search.</p> required <code>val</code> <code>Any</code> <p>Value to find.</p> required <p>Returns:</p> Type Description <code>Any | None</code> <p>The key, or None if not found.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_dict_key_from_value(dictionary: dict[Any, Any], val: Any) -&gt; Any | None:\n    \"\"\"Return the key of a dictionary that stores the value.\n\n    Parameters\n    ----------\n    dictionary : dict\n        The dictionary to search.\n    val : Any\n        Value to find.\n\n    Returns\n    -------\n    Any | None\n        The key, or None if not found.\n\n    \"\"\"\n    for key in dictionary:\n        value = dictionary[key]\n        if val == value:\n            return key\n    return None\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.find_next_printpoint","title":"find_next_printpoint","text":"<pre><code>find_next_printpoint(printpoints, i, j, k)\n</code></pre> <p>Returns the next printpoint from the current printpoint if it exists, otherwise returns None.</p> <p>Parameters:</p> Name Type Description Default <code>printpoints</code> <code>PrintPointsCollection</code> <p>The collection of printpoints.</p> required <code>i</code> <code>int</code> <p>Layer index.</p> required <code>j</code> <code>int</code> <p>Path index.</p> required <code>k</code> <code>int</code> <p>Printpoint index within the path.</p> required <p>Returns:</p> Type Description <code>PrintPoint | None</code> <p>The next printpoint or None if at the end.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def find_next_printpoint(\n    printpoints: PrintPointsCollection, i: int, j: int, k: int\n) -&gt; PrintPoint | None:\n    \"\"\"\n    Returns the next printpoint from the current printpoint if it exists, otherwise returns None.\n\n    Parameters\n    ----------\n    printpoints : PrintPointsCollection\n        The collection of printpoints.\n    i : int\n        Layer index.\n    j : int\n        Path index.\n    k : int\n        Printpoint index within the path.\n\n    Returns\n    -------\n    PrintPoint | None\n        The next printpoint or None if at the end.\n\n    \"\"\"\n    next_ppt = None\n    if k &lt; len(printpoints[i][j]) - 1:  # If there are more ppts in the current path\n        next_ppt = printpoints[i][j][k + 1]\n    else:\n        if j &lt; len(printpoints[i]) - 1:  # Otherwise take the next path\n            next_ppt = printpoints[i][j + 1][0]\n        else:\n            if i &lt; len(printpoints) - 1:  # Otherwise take the next layer\n                next_ppt = printpoints[i + 1][0][0]\n    return next_ppt\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.find_previous_printpoint","title":"find_previous_printpoint","text":"<pre><code>find_previous_printpoint(printpoints, i, j, k)\n</code></pre> <p>Returns the previous printpoint from the current printpoint if it exists, otherwise returns None.</p> <p>Parameters:</p> Name Type Description Default <code>printpoints</code> <code>PrintPointsCollection</code> <p>The collection of printpoints.</p> required <code>i</code> <code>int</code> <p>Layer index.</p> required <code>j</code> <code>int</code> <p>Path index.</p> required <code>k</code> <code>int</code> <p>Printpoint index within the path.</p> required <p>Returns:</p> Type Description <code>PrintPoint | None</code> <p>The previous printpoint or None if at the start.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def find_previous_printpoint(\n    printpoints: PrintPointsCollection, i: int, j: int, k: int\n) -&gt; PrintPoint | None:\n    \"\"\"\n    Returns the previous printpoint from the current printpoint if it exists, otherwise returns None.\n\n    Parameters\n    ----------\n    printpoints : PrintPointsCollection\n        The collection of printpoints.\n    i : int\n        Layer index.\n    j : int\n        Path index.\n    k : int\n        Printpoint index within the path.\n\n    Returns\n    -------\n    PrintPoint | None\n        The previous printpoint or None if at the start.\n\n    \"\"\"\n    prev_ppt = None\n    if k &gt; 0:  # If not the first point in a path\n        prev_ppt = printpoints[i][j][k - 1]\n    else:\n        if j &gt; 0:  # Otherwise take the last point of the previous path\n            prev_ppt = printpoints[i][j - 1][-1]\n        else:\n            if i &gt; 0:  # Otherwise take the last path of the previous layer\n                prev_ppt = printpoints[i - 1][-1][-1]\n    return prev_ppt\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.interrupt","title":"interrupt","text":"<pre><code>interrupt()\n</code></pre> <p>Interrupts the flow of the code while it is running. It asks for the user to press a enter to continue or abort.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def interrupt() -&gt; None:\n    \"\"\"\n    Interrupts the flow of the code while it is running.\n    It asks for the user to press a enter to continue or abort.\n    \"\"\"\n    value = input(\"Press enter to continue, Press 1 to abort \")\n    if isinstance(value, str) and value == '1':\n        raise ValueError(\"Aborted\")\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.get_all_files_with_name","title":"get_all_files_with_name","text":"<pre><code>get_all_files_with_name(startswith, endswith, DATA_PATH)\n</code></pre> <p>Finds all the filenames in the DATA_PATH that start and end with the provided strings</p> <p>Parameters:</p> Name Type Description Default <code>startswith</code> <code>str</code> required <code>endswith</code> <code>str</code> required <code>DATA_PATH</code> <code>str | Path</code> required <p>Returns:</p> Type Description <code>list[str]</code> <p>All the filenames</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def get_all_files_with_name(\n    startswith: str, endswith: str, DATA_PATH: str | Path\n) -&gt; list[str]:\n    \"\"\"\n    Finds all the filenames in the DATA_PATH that start and end with the provided strings\n\n    Parameters\n    ----------\n    startswith: str\n    endswith: str\n    DATA_PATH: str | Path\n\n    Returns\n    ----------\n    list[str]\n        All the filenames\n    \"\"\"\n    files = [f.name for f in Path(DATA_PATH).iterdir()\n             if f.name.startswith(startswith) and f.name.endswith(endswith)]\n    logger.info(f'Reloading: {files}')\n    return files\n</code></pre>"},{"location":"api/utilities/#compas_slicer.utilities.utils.check_package_is_installed","title":"check_package_is_installed","text":"<pre><code>check_package_is_installed(package_name)\n</code></pre> <p>Throws an error if igl python bindings are not installed in the current environment.</p> Source code in <code>src/compas_slicer/utilities/utils.py</code> <pre><code>def check_package_is_installed(package_name: str) -&gt; None:\n    \"\"\" Throws an error if igl python bindings are not installed in the current environment. \"\"\"\n    packages = TerminalCommand('conda list').get_split_output_strings()\n    if package_name not in packages:\n        raise PluginNotInstalledError(\" ATTENTION! Package : \" + package_name +\n                                      \" is missing! Please follow installation guide to install it.\")\n</code></pre>"},{"location":"concepts/","title":"Concepts","text":"<p>Understanding the theory and architecture behind COMPAS Slicer.</p>"},{"location":"concepts/#overview","title":"Overview","text":"<p>These guides explain how COMPAS Slicer works - the data structures, algorithms, and design decisions that power the library.</p> <ul> <li> <p> Architecture</p> <p>Core data structures and pipeline flow - from mesh to G-code.</p> <p> Architecture</p> </li> <li> <p> Slicing Algorithms</p> <p>How planar, curved, and scalar field slicing work under the hood.</p> <p> Slicing Algorithms</p> </li> <li> <p> Print Organization</p> <p>Transforming geometry into fabrication-ready toolpaths.</p> <p> Print Organization</p> </li> </ul>"},{"location":"concepts/#quick-reference","title":"Quick Reference","text":""},{"location":"concepts/#the-pipeline","title":"The Pipeline","text":"<pre><code>Mesh \u2192 Slicer \u2192 Layers/Paths \u2192 PrintOrganizer \u2192 PrintPoints \u2192 Output\n</code></pre>"},{"location":"concepts/#key-classes","title":"Key Classes","text":"Class Purpose <code>Layer</code> One slice containing paths <code>Path</code> Single contour (closed or open) <code>PrintPoint</code> Point with fabrication data <code>PlanarSlicer</code> Horizontal plane slicing <code>InterpolationSlicer</code> Curved slicing between boundaries <code>PlanarPrintOrganizer</code> Generate printpoints from planar paths"},{"location":"concepts/#typical-workflow","title":"Typical Workflow","text":"<pre><code>from compas.datastructures import Mesh\nfrom compas_slicer.slicers import PlanarSlicer\nfrom compas_slicer.print_organization import PlanarPrintOrganizer\n\n# 1. Load\nmesh = Mesh.from_obj(\"model.obj\")\n\n# 2. Slice\nslicer = PlanarSlicer(mesh, layer_height=0.4)\nslicer.generate_paths()\n\n# 3. Organize\norganizer = PlanarPrintOrganizer(slicer)\norganizer.create_printpoints()\n\n# 4. Export\ngcode = organizer.output_gcode()\n</code></pre>"},{"location":"concepts/architecture/","title":"Architecture","text":"<p>This page explains the core architecture of COMPAS Slicer - how data flows from mesh to G-code, and how the main components interact.</p>"},{"location":"concepts/architecture/#the-slicing-pipeline","title":"The Slicing Pipeline","text":"<p>Every slicing workflow follows this pipeline:</p> <pre><code>flowchart LR\n    A[Mesh] --&gt; B[Slicer]\n    B --&gt; C[Layers &amp; Paths]\n    C --&gt; D[PrintOrganizer]\n    D --&gt; E[PrintPoints]\n    E --&gt; F[Output]\n\n    F --&gt; G[G-code]\n    F --&gt; H[JSON]\n    F --&gt; I[Grasshopper]</code></pre> <p>Each stage transforms the data:</p> Stage Input Output Purpose Slicer Mesh Layers containing Paths Intersect mesh with cutting surfaces PrintOrganizer Layers/Paths PrintPoints Add fabrication parameters Output PrintPoints G-code/JSON Export for machines or visualization"},{"location":"concepts/architecture/#core-data-structures","title":"Core Data Structures","text":""},{"location":"concepts/architecture/#hierarchy","title":"Hierarchy","text":"<p>The geometric data is organized hierarchically:</p> <pre><code>Slicer\n\u2514\u2500\u2500 layers: list[Layer]\n    \u2514\u2500\u2500 paths: list[Path]\n        \u2514\u2500\u2500 points: list[Point]\n</code></pre> <p>After print organization:</p> <pre><code>PrintPointsCollection\n\u2514\u2500\u2500 data: dict[layer_key][path_key] = list[PrintPoint]\n</code></pre>"},{"location":"concepts/architecture/#layer","title":"Layer","text":"<p>A <code>Layer</code> represents one \"slice\" of the model. In planar slicing, all points share the same Z height. In non-planar slicing (curved, scalar field), points can vary in height.</p> <pre><code>from compas_slicer.geometry import Layer\n\nlayer = Layer(paths=[path1, path2])\nlayer.is_closed  # True if all paths are closed contours\n</code></pre> <p>Key attributes:</p> <ul> <li><code>paths</code> - List of Path objects in this layer</li> <li><code>is_raft</code> - Whether this is a raft layer (special handling)</li> </ul>"},{"location":"concepts/architecture/#path","title":"Path","text":"<p>A <code>Path</code> is a single contour - either closed (loop) or open (line). A layer can have multiple paths when:</p> <ul> <li>The slice intersects multiple disconnected regions</li> <li>The model has holes (inner and outer contours)</li> </ul> <pre><code>from compas_slicer.geometry import Path\n\npath = Path(points=[pt1, pt2, pt3], is_closed=True)\nlen(path)  # Number of points\n</code></pre> <p>Key attributes:</p> <ul> <li><code>points</code> - List of COMPAS Point objects</li> <li><code>is_closed</code> - Whether the path forms a closed loop</li> </ul>"},{"location":"concepts/architecture/#printpoint","title":"PrintPoint","text":"<p>A <code>PrintPoint</code> extends a geometric point with all the information needed for fabrication:</p> <pre><code>from compas_slicer.geometry import PrintPoint\n\npp = PrintPoint(\n    pt=Point(0, 0, 10),\n    layer_height=0.4,\n    mesh_normal=Vector(0, 0, 1)\n)\n\n# Fabrication parameters (set by PrintOrganizer)\npp.velocity = 30.0          # mm/s\npp.extruder_toggle = True   # extrusion on/off\npp.wait_time = 0.0          # pause at point\n</code></pre> <p>Key attributes:</p> Attribute Type Description <code>pt</code> Point XYZ position <code>layer_height</code> float Layer height at this point <code>mesh_normal</code> Vector Surface normal from mesh <code>up_vector</code> Vector Tool orientation (Z-axis of tool frame) <code>frame</code> Frame Full tool frame for robotic fabrication <code>velocity</code> float Travel/print speed in mm/s <code>extruder_toggle</code> bool Whether extruder is on <code>wait_time</code> float Pause duration in seconds"},{"location":"concepts/architecture/#slicers","title":"Slicers","text":"<p>All slicers inherit from <code>BaseSlicer</code> and implement <code>generate_paths()</code>:</p> <pre><code>class BaseSlicer:\n    def __init__(self, mesh: Mesh):\n        self.mesh = mesh\n        self.layers: list[Layer] = []\n\n    def generate_paths(self) -&gt; None:\n        \"\"\"Override in subclass to generate self.layers\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"concepts/architecture/#available-slicers","title":"Available Slicers","text":"Slicer Algorithm Use Case <code>PlanarSlicer</code> Horizontal plane intersection via CGAL Standard FDM printing <code>InterpolationSlicer</code> Geodesic interpolation between boundaries Curved shells, domes <code>ScalarFieldSlicer</code> Isocurves of scalar field on mesh Custom layer patterns <code>UVSlicer</code> UV parameterization contours Developable surfaces"},{"location":"concepts/architecture/#print-organization","title":"Print Organization","text":"<p>The <code>PrintOrganizer</code> converts geometric paths to fabrication-ready <code>PrintPoints</code>:</p> <pre><code>from compas_slicer.print_organization import PlanarPrintOrganizer\n\n# Create organizer from slicer\norganizer = PlanarPrintOrganizer(slicer)\norganizer.create_printpoints()\n\n# Access printpoints\nfor layer_key in organizer.printpoints_dict:\n    for path_key in organizer.printpoints_dict[layer_key]:\n        printpoints = organizer.printpoints_dict[layer_key][path_key]\n</code></pre>"},{"location":"concepts/architecture/#post-processing-functions","title":"Post-Processing Functions","text":"<p>After creating printpoints, apply fabrication parameters:</p> <pre><code>from compas_slicer.print_organization import (\n    set_linear_velocity_constant,\n    set_extruder_toggle,\n    add_safety_printpoints,\n)\n\n# Set constant velocity\nset_linear_velocity_constant(organizer, velocity=25.0)\n\n# Set extrusion on/off based on path structure\nset_extruder_toggle(organizer, slicer)\n\n# Add safety moves between layers\nadd_safety_printpoints(organizer, z_hop=10.0)\n</code></pre>"},{"location":"concepts/architecture/#data-flow-example","title":"Data Flow Example","text":"<p>Here's the complete flow for planar slicing:</p> <pre><code>from compas.datastructures import Mesh\nfrom compas_slicer.slicers import PlanarSlicer\nfrom compas_slicer.print_organization import PlanarPrintOrganizer\nfrom compas_slicer.print_organization import (\n    set_linear_velocity_constant,\n    set_extruder_toggle,\n)\n\n# 1. Load mesh\nmesh = Mesh.from_obj(\"model.obj\")\n\n# 2. Slice mesh into layers\nslicer = PlanarSlicer(mesh, layer_height=0.4)\nslicer.generate_paths()\n# Result: slicer.layers = [Layer, Layer, ...]\n\n# 3. Create printpoints with fabrication data\norganizer = PlanarPrintOrganizer(slicer)\norganizer.create_printpoints()\n# Result: organizer.printpoints_dict[layer][path] = [PrintPoint, ...]\n\n# 4. Set fabrication parameters\nset_linear_velocity_constant(organizer, velocity=30.0)\nset_extruder_toggle(organizer, slicer)\n\n# 5. Export\norganizer.printpoints_collection.to_json(\"output.json\")\n</code></pre>"},{"location":"concepts/architecture/#module-organization","title":"Module Organization","text":"<pre><code>compas_slicer/\n\u251c\u2500\u2500 geometry/           # Layer, Path, PrintPoint, PrintPointsCollection\n\u251c\u2500\u2500 slicers/            # BaseSlicer, PlanarSlicer, InterpolationSlicer, etc.\n\u251c\u2500\u2500 print_organization/ # PrintOrganizers and parameter functions\n\u251c\u2500\u2500 pre_processing/     # Mesh prep: move_mesh_to_point, get_distance_of_pt_from_mesh\n\u251c\u2500\u2500 post_processing/    # Path mods: simplify_paths_rdp, sort_paths, generate_brim\n\u2514\u2500\u2500 utilities/          # I/O, geometry helpers\n</code></pre>"},{"location":"concepts/architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Slicing Algorithms - Deep dive into how each slicer works</li> <li>Print Organization - Fabrication parameter details</li> <li>Examples - Complete working code</li> </ul>"},{"location":"concepts/print-organization/","title":"Print Organization","text":"<p>This page explains how geometric paths are transformed into fabrication-ready toolpaths with all the parameters needed for 3D printing or robotic fabrication.</p>"},{"location":"concepts/print-organization/#overview","title":"Overview","text":"<p>After slicing, you have geometric data - points forming contours. Print organization adds fabrication data:</p> <pre><code>flowchart LR\n    A[Geometric Paths] --&gt; B[PrintOrganizer]\n    B --&gt; C[PrintPoints]\n    C --&gt; D[Velocity]\n    C --&gt; E[Extrusion]\n    C --&gt; F[Orientation]\n    C --&gt; G[Wait times]</code></pre>"},{"location":"concepts/print-organization/#the-printorganizer","title":"The PrintOrganizer","text":"<p>Each slicer type has a corresponding PrintOrganizer:</p> Slicer PrintOrganizer <code>PlanarSlicer</code> <code>PlanarPrintOrganizer</code> <code>InterpolationSlicer</code> <code>InterpolationPrintOrganizer</code> <code>ScalarFieldSlicer</code> <code>ScalarFieldPrintOrganizer</code>"},{"location":"concepts/print-organization/#basic-usage","title":"Basic Usage","text":"<pre><code>from compas_slicer.slicers import PlanarSlicer\nfrom compas_slicer.print_organization import PlanarPrintOrganizer\n\n# 1. Slice the mesh\nslicer = PlanarSlicer(mesh, layer_height=0.4)\nslicer.generate_paths()\n\n# 2. Create print organizer\norganizer = PlanarPrintOrganizer(slicer)\norganizer.create_printpoints()\n\n# 3. Access printpoints\nfor layer in organizer.printpoints:\n    for path in layer:\n        for printpoint in path:\n            print(printpoint.pt, printpoint.velocity)\n</code></pre>"},{"location":"concepts/print-organization/#what-create_printpoints-does","title":"What <code>create_printpoints()</code> Does","text":"<ol> <li>Creates PrintPoint for each path point</li> <li>Computes layer height at each point (from mesh or constant)</li> <li>Computes mesh normal via raycasting to mesh surface</li> <li>Computes up-vector orthogonal to path direction</li> <li>Builds frame for robotic fabrication (position + orientation)</li> </ol>"},{"location":"concepts/print-organization/#printpoint-attributes","title":"PrintPoint Attributes","text":"<p>A <code>PrintPoint</code> contains everything needed for fabrication:</p>"},{"location":"concepts/print-organization/#geometric","title":"Geometric","text":"Attribute Type Description <code>pt</code> Point XYZ position <code>layer_height</code> float Layer height at this point (mm) <code>mesh_normal</code> Vector Surface normal from mesh"},{"location":"concepts/print-organization/#orientation","title":"Orientation","text":"Attribute Type Description <code>up_vector</code> Vector Tool Z-axis direction <code>frame</code> Frame Full 6DOF frame for robots"},{"location":"concepts/print-organization/#fabrication","title":"Fabrication","text":"Attribute Type Description <code>velocity</code> float Travel speed (mm/s) <code>extruder_toggle</code> bool Extrusion on/off <code>wait_time</code> float Pause duration (seconds) <code>blend_radius</code> float Blend radius for robot motion"},{"location":"concepts/print-organization/#custom-attributes","title":"Custom Attributes","text":"<p>Additional attributes can be stored in <code>printpoint.attributes</code>:</p> <pre><code>printpoint.attributes['temperature'] = 210\nprintpoint.attributes['fan_speed'] = 100\n</code></pre>"},{"location":"concepts/print-organization/#fabrication-parameters","title":"Fabrication Parameters","text":"<p>After creating printpoints, apply fabrication parameters using utility functions.</p>"},{"location":"concepts/print-organization/#velocity","title":"Velocity","text":"<pre><code>from compas_slicer.print_organization import (\n    set_linear_velocity_constant,\n    set_linear_velocity_per_layer,\n    set_linear_velocity_by_overhang,\n)\n\n# Constant velocity\nset_linear_velocity_constant(organizer, v=30.0)  # mm/s\n\n# Different velocity per layer (e.g., slower first layer)\nvelocities = [15.0] + [30.0] * (organizer.number_of_layers - 1)\nset_linear_velocity_per_layer(organizer, velocities)\n\n# Velocity based on overhang angle\nset_linear_velocity_by_overhang(\n    organizer,\n    overhang_range=(0.0, 0.5),   # 0\u00b0 to 45\u00b0 overhang\n    velocity_range=(30.0, 15.0),  # slow down on overhangs\n)\n</code></pre>"},{"location":"concepts/print-organization/#extrusion-toggle","title":"Extrusion Toggle","text":"<p>Control when the extruder is on/off:</p> <pre><code>from compas_slicer.print_organization import set_extruder_toggle\n\n# Based on path structure (travel moves vs print moves)\nset_extruder_toggle(organizer, slicer)\n</code></pre> <p>This sets: - <code>extruder_toggle = True</code> for printing segments - <code>extruder_toggle = False</code> for travel moves between paths</p>"},{"location":"concepts/print-organization/#safety-points","title":"Safety Points","text":"<p>Add Z-hop movements between layers/paths to avoid collisions:</p> <pre><code>from compas_slicer.print_organization import add_safety_printpoints\n\nadd_safety_printpoints(\n    organizer,\n    z_hop=10.0,        # mm to lift between paths\n    retract=True,      # retract filament during travel\n)\n</code></pre> <p>This inserts additional printpoints: 1. Lift up from end of current path 2. Travel to start of next path 3. Lower down to begin printing</p>"},{"location":"concepts/print-organization/#wait-time","title":"Wait Time","text":"<p>Add pauses at specific points (e.g., for cooling):</p> <pre><code>from compas_slicer.print_organization import set_wait_time_on_sharp_corners\n\nset_wait_time_on_sharp_corners(\n    organizer,\n    threshold_angle=45.0,  # degrees\n    wait_time=0.5,         # seconds\n)\n</code></pre>"},{"location":"concepts/print-organization/#blend-radius-robotic","title":"Blend Radius (Robotic)","text":"<p>For robotic fabrication, set blend radius for smooth motion:</p> <pre><code>from compas_slicer.print_organization import set_blend_radius\n\nset_blend_radius(\n    organizer,\n    blend_radius=5.0,  # mm\n)\n</code></pre>"},{"location":"concepts/print-organization/#data-smoothing","title":"Data Smoothing","text":"<p>Smooth attributes across printpoints to avoid abrupt changes:</p> <pre><code>from compas_slicer.print_organization import smooth_printpoints_attribute\n\n# Smooth velocity values\nsmooth_printpoints_attribute(\n    organizer,\n    attr_name='velocity',\n    iterations=3,\n    strength=0.5,\n)\n</code></pre>"},{"location":"concepts/print-organization/#tool-orientation","title":"Tool Orientation","text":""},{"location":"concepts/print-organization/#up-vector-computation","title":"Up Vector Computation","text":"<p>The up-vector determines tool orientation. For planar slicing:</p> <pre><code>        up_vector (Z)\n            \u2191\n            |\n     \u2190------\u25cf-----\u2192 path direction\n            |\n        normal (from mesh)\n</code></pre> <p>The up-vector is computed as: <code>up = normalize(normal \u00d7 path_direction)</code></p>"},{"location":"concepts/print-organization/#frame-construction","title":"Frame Construction","text":"<p>For robotic fabrication, a full Frame is constructed:</p> <pre><code>from compas.geometry import Frame\n\n# At each printpoint:\nframe = Frame(\n    point=printpoint.pt,\n    xaxis=path_direction,\n    yaxis=up_vector\n)\n# Z-axis (tool direction) is computed automatically\n</code></pre>"},{"location":"concepts/print-organization/#output-formats","title":"Output Formats","text":""},{"location":"concepts/print-organization/#g-code","title":"G-code","text":"<p>For desktop 3D printers:</p> <pre><code>from compas_slicer.config import GcodeConfig\n\nconfig = GcodeConfig(\n    nozzle_diameter=0.4,\n    filament_diameter=1.75,\n    print_speed=30,\n    travel_speed=120,\n)\n\ngcode = organizer.output_gcode(config)\nwith open(\"output.gcode\", \"w\") as f:\n    f.write(gcode)\n</code></pre>"},{"location":"concepts/print-organization/#json","title":"JSON","text":"<p>For custom post-processing or visualization:</p> <pre><code>import json\n\n# Flat structure\ndata = organizer.output_printpoints_dict()\nwith open(\"printpoints.json\", \"w\") as f:\n    json.dump(data, f)\n\n# Nested structure (layer &gt; path &gt; printpoint)\nnested_data = organizer.output_nested_printpoints_dict()\n</code></pre>"},{"location":"concepts/print-organization/#grasshopper","title":"Grasshopper","text":"<p>Export for visualization in Rhino/Grasshopper:</p> <pre><code>organizer.printpoints.to_json(\"printpoints.json\")\n# Load in Grasshopper with csLoadPrintpoints component\n</code></pre>"},{"location":"concepts/print-organization/#complete-example","title":"Complete Example","text":"<pre><code>from pathlib import Path\nfrom compas.datastructures import Mesh\nfrom compas_slicer.slicers import PlanarSlicer\nfrom compas_slicer.print_organization import (\n    PlanarPrintOrganizer,\n    set_linear_velocity_constant,\n    set_extruder_toggle,\n    add_safety_printpoints,\n)\nfrom compas_slicer.config import GcodeConfig\n\n# Load mesh\nmesh = Mesh.from_obj(Path(\"model.obj\"))\n\n# Slice\nslicer = PlanarSlicer(mesh, layer_height=0.3)\nslicer.generate_paths()\n\n# Create printpoints\norganizer = PlanarPrintOrganizer(slicer)\norganizer.create_printpoints()\n\n# Set fabrication parameters\nset_linear_velocity_constant(organizer, v=30.0)\nset_extruder_toggle(organizer, slicer)\nadd_safety_printpoints(organizer, z_hop=5.0)\n\n# Print summary\norganizer.printout_info()\n# Output:\n# Number of layers: 250\n# Number of paths: 250\n# Number of PrintPoints: 45000\n# Toolpath length: 12500 mm\n# Total print time: 0 hours, 15 minutes, 30 seconds\n\n# Export G-code\ngcode = organizer.output_gcode(GcodeConfig())\nPath(\"output.gcode\").write_text(gcode)\n</code></pre>"},{"location":"concepts/print-organization/#available-functions","title":"Available Functions","text":""},{"location":"concepts/print-organization/#velocity_1","title":"Velocity","text":"Function Description <code>set_linear_velocity_constant</code> Same velocity everywhere <code>set_linear_velocity_per_layer</code> Different velocity per layer <code>set_linear_velocity_by_range</code> Velocity based on any parameter <code>set_linear_velocity_by_overhang</code> Velocity based on overhang angle"},{"location":"concepts/print-organization/#extrusion","title":"Extrusion","text":"Function Description <code>set_extruder_toggle</code> On/off based on path structure"},{"location":"concepts/print-organization/#safety","title":"Safety","text":"Function Description <code>add_safety_printpoints</code> Z-hop between paths"},{"location":"concepts/print-organization/#timing","title":"Timing","text":"Function Description <code>set_wait_time_on_sharp_corners</code> Pause at sharp corners"},{"location":"concepts/print-organization/#smoothing","title":"Smoothing","text":"Function Description <code>smooth_printpoints_attribute</code> Smooth any attribute <code>smooth_printpoints_layer_height</code> Smooth layer heights"},{"location":"concepts/print-organization/#robotic","title":"Robotic","text":"Function Description <code>set_blend_radius</code> Robot motion blending"},{"location":"concepts/print-organization/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture - Data structures overview</li> <li>Slicing Algorithms - How slicers work</li> <li>G-code Example - Complete G-code workflow</li> </ul>"},{"location":"concepts/slicing-algorithms/","title":"Slicing Algorithms","text":"<p>This page explains how each slicing algorithm works under the hood.</p>"},{"location":"concepts/slicing-algorithms/#overview","title":"Overview","text":"<p>All slicers share a common pattern:</p> <ol> <li>Input: A triangulated mesh</li> <li>Process: Generate cutting surfaces and find intersections</li> <li>Output: Layers containing Paths (contours)</li> </ol> <p>The key difference is what cutting surfaces are used:</p> Slicer Cutting Surface Result <code>PlanarSlicer</code> Horizontal planes at fixed Z heights Parallel horizontal contours <code>InterpolationSlicer</code> Isosurfaces of geodesic distance field Contours that follow mesh curvature <code>ScalarFieldSlicer</code> Isosurfaces of user-defined scalar field Custom contour patterns"},{"location":"concepts/slicing-algorithms/#planar-slicing","title":"Planar Slicing","text":""},{"location":"concepts/slicing-algorithms/#algorithm","title":"Algorithm","text":"<p>The simplest approach - intersect the mesh with horizontal planes:</p> <pre><code>flowchart TD\n    A[Mesh] --&gt; B[Compute Z bounds]\n    B --&gt; C[Generate planes at layer_height intervals]\n    C --&gt; D[CGAL mesh-plane intersection]\n    D --&gt; E[Extract polylines from intersection]\n    E --&gt; F[Create Layer per plane]</code></pre>"},{"location":"concepts/slicing-algorithms/#how-it-works","title":"How It Works","text":"<ol> <li>Compute bounds: Find min/max Z coordinates of mesh vertices</li> <li>Generate planes: Create horizontal planes from <code>z_min</code> to <code>z_max</code> spaced by <code>layer_height</code></li> <li>Intersect: Use CGAL's <code>slicer()</code> function for robust mesh-plane intersection</li> <li>Extract contours: CGAL returns polylines for each connected intersection</li> </ol> <pre><code>from compas_slicer.slicers import PlanarSlicer\n\nslicer = PlanarSlicer(mesh, layer_height=0.4)\nslicer.generate_paths()\n\n# Result: slicer.layers contains one Layer per plane\n# Each Layer contains one or more Paths (contours)\n</code></pre>"},{"location":"concepts/slicing-algorithms/#why-cgal","title":"Why CGAL?","text":"<p>CGAL (Computational Geometry Algorithms Library) provides:</p> <ul> <li>Robustness: Handles degenerate cases (edges exactly on plane, etc.)</li> <li>Speed: Optimized C++ implementation</li> <li>Correctness: Proper handling of mesh topology</li> </ul> <p>The intersection is computed via <code>compas_cgal.slicer.slice_mesh()</code>.</p>"},{"location":"concepts/slicing-algorithms/#parameters","title":"Parameters","text":"Parameter Type Description <code>layer_height</code> float Distance between planes in mm <code>slice_height_range</code> tuple Optional (z_start, z_end) to slice only part of mesh"},{"location":"concepts/slicing-algorithms/#interpolation-slicing-curved-slicing","title":"Interpolation Slicing (Curved Slicing)","text":""},{"location":"concepts/slicing-algorithms/#concept","title":"Concept","text":"<p>Instead of horizontal planes, generate contours that interpolate between two boundary curves. This creates non-planar toolpaths that follow the mesh surface.</p> <pre><code>flowchart TD\n    A[Mesh + Boundaries] --&gt; B[Compute geodesic distances]\n    B --&gt; C[Create distance field on vertices]\n    C --&gt; D[Extract isocurves at regular intervals]\n    D --&gt; E[Non-planar Layers]</code></pre>"},{"location":"concepts/slicing-algorithms/#how-it-works_1","title":"How It Works","text":"<ol> <li>Define boundaries: Mark two sets of mesh vertices as <code>target_LOW</code> and <code>target_HIGH</code></li> <li>Compute distances: Calculate geodesic distance from each vertex to both boundaries</li> <li>Interpolate: For each vertex, compute interpolated distance: <code>d = t * d_low + (1-t) * d_high</code></li> <li>Extract isocurves: Find contours where the interpolated field equals zero</li> </ol> <p>The key insight: by varying <code>t</code> from 0 to 1, the zero-isocurve sweeps from one boundary to the other.</p> <pre><code>from compas_slicer.slicers import InterpolationSlicer\nfrom compas_slicer.pre_processing import InterpolationSlicingPreprocessor\n\n# 1. Define boundaries\npreprocessor = InterpolationSlicingPreprocessor(mesh, ...)\npreprocessor.create_compound_targets()\n\n# 2. Slice with interpolation\nslicer = InterpolationSlicer(mesh, preprocessor)\nslicer.generate_paths()\n</code></pre>"},{"location":"concepts/slicing-algorithms/#mathematical-background","title":"Mathematical Background","text":"<p>For a mesh with vertices \\(V\\), we compute:</p> <ul> <li>\\(d_{low}(v)\\) = geodesic distance from vertex \\(v\\) to lower boundary</li> <li>\\(d_{high}(v)\\) = geodesic distance from vertex \\(v\\) to upper boundary</li> </ul> <p>The interpolated field at parameter \\(t \\in [0, 1]\\):</p> \\[f_t(v) = (1-t) \\cdot d_{low}(v) - t \\cdot d_{high}(v)\\] <p>The zero-level set \\(\\{v : f_t(v) = 0\\}\\) gives one contour. Varying \\(t\\) generates all contours.</p>"},{"location":"concepts/slicing-algorithms/#use-cases","title":"Use Cases","text":"<ul> <li>Domes and shells: Toolpaths follow curvature for better adhesion</li> <li>Overhangs: Reduce support by printing along surface</li> <li>Aesthetic parts: Visible layer lines follow form</li> </ul>"},{"location":"concepts/slicing-algorithms/#scalar-field-slicing","title":"Scalar Field Slicing","text":""},{"location":"concepts/slicing-algorithms/#concept_1","title":"Concept","text":"<p>The most general approach - extract isocurves of any scalar field defined on mesh vertices.</p> <pre><code>flowchart TD\n    A[Mesh + Scalar Field] --&gt; B[Assign field to vertices]\n    B --&gt; C[Find edges with sign change]\n    C --&gt; D[Interpolate crossing points]\n    D --&gt; E[Connect into contours]</code></pre>"},{"location":"concepts/slicing-algorithms/#how-it-works_2","title":"How It Works","text":"<ol> <li>Define scalar field: Assign one float value per vertex</li> <li>Find zero crossings: For each edge, check if field changes sign</li> <li>Interpolate position: Find exact crossing point via linear interpolation</li> <li>Build contours: Connect crossing points around faces to form polylines</li> </ol> <pre><code>from compas_slicer.slicers import ScalarFieldSlicer\n\n# scalar_field: one value per vertex\nslicer = ScalarFieldSlicer(mesh, scalar_field, no_of_isocurves=50)\nslicer.generate_paths()\n</code></pre>"},{"location":"concepts/slicing-algorithms/#zero-crossing-algorithm","title":"Zero-Crossing Algorithm","text":"<p>For an edge with vertices \\((u, v)\\) and field values \\((f_u, f_v)\\):</p> <ol> <li>Test: Edge is crossed if \\(f_u \\cdot f_v \\leq 0\\) (different signs)</li> <li>Interpolate: Crossing point at parameter \\(t = \\frac{|f_u|}{|f_u| + |f_v|}\\)</li> <li>Position: \\(p = (1-t) \\cdot p_u + t \\cdot p_v\\)</li> </ol> <pre><code>     f_u = -2          f_v = +3\n       u \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf v\n              \u2191\n         crossing at t = 2/5\n</code></pre>"},{"location":"concepts/slicing-algorithms/#marching-algorithm","title":"Marching Algorithm","text":"<p>To build connected contours:</p> <ol> <li>Start at any crossed edge</li> <li>Find the face containing this edge</li> <li>Find the other crossed edge in this face</li> <li>Move to adjacent face sharing that edge</li> <li>Repeat until returning to start (closed) or reaching boundary (open)</li> </ol>"},{"location":"concepts/slicing-algorithms/#use-cases_1","title":"Use Cases","text":"<ul> <li>Custom layer patterns: Any scalar field you can compute</li> <li>Distance-based: Contours equidistant from a feature</li> <li>Curvature-based: Highlight geometric features</li> <li>Stress fields: From FEA analysis</li> </ul>"},{"location":"concepts/slicing-algorithms/#contour-assembly","title":"Contour Assembly","text":"<p>All slicers eventually produce contours via the <code>ScalarFieldContours</code> class:</p>"},{"location":"concepts/slicing-algorithms/#from-crossings-to-paths","title":"From Crossings to Paths","text":"<pre><code>flowchart LR\n    A[Edge crossings] --&gt; B[Face traversal]\n    B --&gt; C[Connected polylines]\n    C --&gt; D[Path objects]</code></pre> <ol> <li>Build crossing map: Dictionary of edge \u2192 crossing point</li> <li>Traverse faces: Walk around faces connecting crossings</li> <li>Handle branches: Multiple paths per layer for complex geometry</li> <li>Create Paths: Wrap polylines in Path objects with metadata</li> </ol>"},{"location":"concepts/slicing-algorithms/#handling-complex-topology","title":"Handling Complex Topology","text":"<p>The algorithm handles:</p> <ul> <li>Multiple contours per layer: Holes, disconnected regions</li> <li>Open contours: When path hits mesh boundary</li> <li>Branching: When contours merge or split</li> </ul>"},{"location":"concepts/slicing-algorithms/#performance-considerations","title":"Performance Considerations","text":""},{"location":"concepts/slicing-algorithms/#planar-slicing_1","title":"Planar Slicing","text":"<ul> <li>Fast: Single CGAL call handles all planes</li> <li>Scales well: O(n) in number of faces</li> <li>Memory efficient: Processes planes in batch</li> </ul>"},{"location":"concepts/slicing-algorithms/#interpolationscalar-field-slicing","title":"Interpolation/Scalar Field Slicing","text":"<ul> <li>Slower: One contour extraction per isocurve</li> <li>Preprocessing cost: Geodesic distance computation</li> <li>Mesh quality matters: Irregular tessellation \u2192 irregular contours</li> </ul>"},{"location":"concepts/slicing-algorithms/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Clean mesh: Remove degenerate faces, weld vertices</li> <li>Appropriate resolution: More faces \u2260 better results</li> <li>Layer height: Fewer layers = faster slicing</li> </ol>"},{"location":"concepts/slicing-algorithms/#comparison-summary","title":"Comparison Summary","text":"Aspect Planar Interpolation Scalar Field Speed Fast Medium Medium Setup Simple Requires boundaries Requires field Paths Horizontal only Follow surface Arbitrary Use case Standard FDM Shells, domes Custom patterns"},{"location":"concepts/slicing-algorithms/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture - Data structures overview</li> <li>Print Organization - Adding fabrication parameters</li> <li>Examples - Complete working code</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Complete working examples demonstrating COMPAS Slicer capabilities.</p> <p>All examples are available in the <code>examples/</code> folder of the repository.</p> <ul> <li> <p> Planar Slicing</p> <p>Basic horizontal slicing workflow with brim, raft, and seam alignment</p> <p> Example</p> </li> <li> <p> Curved Slicing</p> <p>Non-planar slicing using interpolation between boundary curves</p> <p> Example</p> </li> <li> <p> Vertical Sorting</p> <p>Organize branching paths into vertical layers for efficient printing</p> <p> Example</p> </li> <li> <p> G-code Generation</p> <p>Export toolpaths to G-code for desktop 3D printers</p> <p> Example</p> </li> <li> <p> Scalar Field Slicing</p> <p>Slice along custom scalar field contours</p> <p> Example</p> </li> <li> <p> Attribute Transfer</p> <p>Transfer mesh attributes (colors, normals) to printpoints</p> <p> Example</p> </li> </ul>"},{"location":"examples/#running-examples","title":"Running Examples","text":"<pre><code># Clone the repository\ngit clone https://github.com/compas-dev/compas_slicer.git\ncd compas_slicer\n\n# Install\npip install -e .\n\n# Run an example\npython examples/1_planar_slicing_simple/example_1_planar_slicing_simple.py\n</code></pre> <p>Output files are saved to <code>examples/&lt;example&gt;/data/output/</code>.</p>"},{"location":"examples/01_planar_slicing/","title":"Planar Slicing","text":"<p>This example demonstrates the complete planar slicing workflow - from mesh to printpoints with brim, raft, and seam control.</p> <p> Left: Without brim. Right: With brim for bed adhesion</p>"},{"location":"examples/01_planar_slicing/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Loading and positioning a mesh</li> <li>Basic planar slicing with <code>PlanarSlicer</code></li> <li>Adding brim and raft for bed adhesion</li> <li>Simplifying paths with RDP algorithm</li> <li>Controlling seam position and smoothness</li> <li>Creating printpoints with fabrication parameters</li> </ul>"},{"location":"examples/01_planar_slicing/#the-pipeline","title":"The Pipeline","text":"<pre><code>flowchart LR\n    A[Load Mesh] --&gt; B[Position at Origin]\n    B --&gt; C[Slice]\n    C --&gt; D[Add Brim/Raft]\n    D --&gt; E[Simplify Paths]\n    E --&gt; F[Align Seams]\n    F --&gt; G[Create PrintPoints]\n    G --&gt; H[Set Parameters]\n    H --&gt; I[Export JSON]</code></pre>"},{"location":"examples/01_planar_slicing/#step-by-step-walkthrough","title":"Step-by-Step Walkthrough","text":""},{"location":"examples/01_planar_slicing/#1-setup-and-load-mesh","title":"1. Setup and Load Mesh","text":"<pre><code>from pathlib import Path\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Point\nfrom compas_slicer.pre_processing import move_mesh_to_point\n\n# Load the mesh\nmesh = Mesh.from_obj(Path(\"data/simple_vase_open_low_res.obj\"))\n\n# Move to origin (important for consistent slicing)\nmove_mesh_to_point(mesh, Point(0, 0, 0))\n</code></pre> <p>Why move to origin?</p> <p>Moving the mesh ensures the first layer starts at Z=0, which is expected by most 3D printers and simplifies debugging.</p>"},{"location":"examples/01_planar_slicing/#2-slice-the-mesh","title":"2. Slice the Mesh","text":"<pre><code>from compas_slicer.slicers import PlanarSlicer\n\nslicer = PlanarSlicer(mesh, layer_height=1.5)\nslicer.slice_model()\n</code></pre> <p>This intersects the mesh with horizontal planes spaced 1.5mm apart using CGAL's robust mesh-plane intersection.</p>"},{"location":"examples/01_planar_slicing/#3-align-seams","title":"3. Align Seams","text":"<pre><code>from compas_slicer.post_processing import seams_align\n\nseams_align(slicer, \"next_path\")\n</code></pre> <p>Seams are where each layer starts/ends. Without alignment, seams appear randomly, creating a visible vertical line. Options:</p> Mode Description <code>\"next_path\"</code> Align with next layer's closest point <code>\"x_axis\"</code> Align along X axis <code>\"y_axis\"</code> Align along Y axis <code>\"origin\"</code> Align toward origin"},{"location":"examples/01_planar_slicing/#4-generate-brim","title":"4. Generate Brim","text":"<pre><code>from compas_slicer.post_processing import generate_brim\n\ngenerate_brim(\n    slicer,\n    layer_width=3.0,           # Width of each brim line\n    number_of_brim_offsets=4   # Number of concentric loops\n)\n</code></pre> <p>A brim adds concentric loops around the first layer to improve bed adhesion. Unlike a raft, the brim is on the same layer as the print.</p>"},{"location":"examples/01_planar_slicing/#5-generate-raft","title":"5. Generate Raft","text":"<pre><code>from compas_slicer.post_processing import generate_raft\n\ngenerate_raft(\n    slicer,\n    raft_offset=20,            # Distance from model edge\n    distance_between_paths=5,   # Spacing between raft lines\n    direction=\"xy_diagonal\",    # Line pattern direction\n    raft_layers=1              # Number of raft layers\n)\n</code></pre> <p>A raft creates a sacrificial base layer beneath the print. The model is printed on top of the raft.</p> <p>Note</p> <p>Typically use brim OR raft, not both. This example shows both for demonstration.</p>"},{"location":"examples/01_planar_slicing/#6-simplify-paths","title":"6. Simplify Paths","text":"<pre><code>from compas_slicer.post_processing import simplify_paths_rdp\n\nsimplify_paths_rdp(slicer, threshold=0.6)\n</code></pre> <p>The Ramer-Douglas-Peucker algorithm removes points that don't contribute significantly to the path shape. A threshold of 0.6mm means points within 0.6mm of the simplified line are removed.</p> <p>Before: 10,000 points \u2192 After: 2,000 points (faster printing, same quality)</p>"},{"location":"examples/01_planar_slicing/#7-smooth-seams","title":"7. Smooth Seams","text":"<pre><code>from compas_slicer.post_processing import seams_smooth\n\nseams_smooth(slicer, smooth_distance=10)\n</code></pre> <p>Smooths the transition between layers by blending the path near the seam point over a 10mm distance.</p>"},{"location":"examples/01_planar_slicing/#8-create-printpoints","title":"8. Create PrintPoints","text":"<pre><code>from compas_slicer.print_organization import PlanarPrintOrganizer\n\nprint_organizer = PlanarPrintOrganizer(slicer)\nprint_organizer.create_printpoints(generate_mesh_normals=False)\n</code></pre> <p>This converts geometric points to <code>PrintPoint</code> objects with fabrication metadata.</p>"},{"location":"examples/01_planar_slicing/#9-set-fabrication-parameters","title":"9. Set Fabrication Parameters","text":"<pre><code>from compas_slicer.print_organization import (\n    set_extruder_toggle,\n    add_safety_printpoints,\n    set_linear_velocity_constant,\n)\n\n# Enable/disable extrusion based on path structure\nset_extruder_toggle(print_organizer, slicer)\n\n# Add Z-hop between paths to avoid collisions\nadd_safety_printpoints(print_organizer, z_hop=10.0)\n\n# Set constant print speed\nset_linear_velocity_constant(print_organizer, v=25.0)\n</code></pre>"},{"location":"examples/01_planar_slicing/#10-export","title":"10. Export","text":"<pre><code>from compas_slicer.utilities import save_to_json\n\n# Flat format\nprintpoints_data = print_organizer.output_printpoints_dict()\nsave_to_json(printpoints_data, OUTPUT_PATH, 'out_printpoints.json')\n\n# Nested format (layer &gt; path &gt; point)\nnested_data = print_organizer.output_nested_printpoints_dict()\nsave_to_json(nested_data, OUTPUT_PATH, 'out_printpoints_nested.json')\n</code></pre>"},{"location":"examples/01_planar_slicing/#complete-code","title":"Complete Code","text":"<pre><code>--8&lt;-- \"examples/1_planar_slicing_simple/example_1_planar_slicing_simple.py\"\n</code></pre>"},{"location":"examples/01_planar_slicing/#running-the-example","title":"Running the Example","text":"<pre><code>cd examples/1_planar_slicing_simple\npython example_1_planar_slicing_simple.py\n</code></pre> <p>Add <code>--visualize</code> flag to see the results:</p> <pre><code>python example_1_planar_slicing_simple.py --visualize\n</code></pre>"},{"location":"examples/01_planar_slicing/#output-files","title":"Output Files","text":"File Description <code>slicer_data.json</code> Raw slicer output (layers, paths) <code>out_printpoints.json</code> Flat list of printpoints <code>out_printpoints_nested.json</code> Nested structure by layer/path"},{"location":"examples/01_planar_slicing/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Order matters: Brim/raft before simplification, seam alignment early</li> <li>Simplification saves time: RDP can reduce points 5x with no quality loss</li> <li>Seam control is important: Random seams create visible artifacts</li> <li>Safety moves prevent crashes: Z-hop between paths avoids collisions</li> </ol>"},{"location":"examples/01_planar_slicing/#next-steps","title":"Next Steps","text":"<ul> <li>Curved Slicing - Non-planar toolpaths</li> <li>G-code Generation - Export for 3D printers</li> <li>Print Organization - Deep dive into fabrication parameters</li> </ul>"},{"location":"examples/02_curved_slicing/","title":"Curved Slicing (Interpolation)","text":"<p>This example demonstrates non-planar slicing using geodesic interpolation between boundary curves - the signature technique from the ETH research.</p>"},{"location":"examples/02_curved_slicing/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Defining boundary curves for interpolation</li> <li>Computing geodesic distance fields</li> <li>Finding critical points (minima, maxima, saddles)</li> <li>Non-planar slicing with <code>InterpolationSlicer</code></li> <li>Variable velocity based on layer height</li> <li>Smoothing tool orientations for robotic fabrication</li> </ul>"},{"location":"examples/02_curved_slicing/#why-curved-slicing","title":"Why Curved Slicing?","text":"<p>Traditional planar slicing creates horizontal layers. For curved surfaces like shells and domes, this causes:</p> <ul> <li>Poor surface finish on overhangs</li> <li>Weak layer adhesion on steep angles</li> <li>Visible stair-stepping</li> </ul> <p>Curved slicing generates toolpaths that follow the surface curvature:</p> <pre><code>Planar slicing:          Curved slicing:\n    ___________              _________\n   |___________|            /         \\\n   |___________|           /           \\\n   |___________|          (             )\n   |___________|           \\           /\n   |___________|            \\_________/\n</code></pre>"},{"location":"examples/02_curved_slicing/#the-pipeline","title":"The Pipeline","text":"<pre><code>flowchart TD\n    A[Load Mesh] --&gt; B[Define Boundaries]\n    B --&gt; C[Compute Gradient Field]\n    C --&gt; D[Find Critical Points]\n    D --&gt; E[Interpolation Slicing]\n    E --&gt; F[Simplify &amp; Smooth]\n    F --&gt; G[Create PrintPoints]\n    G --&gt; H[Smooth Orientations]\n    H --&gt; I[Variable Velocity]</code></pre>"},{"location":"examples/02_curved_slicing/#step-by-step-walkthrough","title":"Step-by-Step Walkthrough","text":""},{"location":"examples/02_curved_slicing/#1-load-mesh-and-boundaries","title":"1. Load Mesh and Boundaries","text":"<pre><code>from pathlib import Path\nfrom compas.datastructures import Mesh\nimport compas_slicer.utilities as utils\nfrom compas_slicer.pre_processing import create_mesh_boundary_attributes\n\n# Load mesh\nmesh = Mesh.from_obj(DATA_PATH / 'mesh.obj')\n\n# Load boundary vertex indices (pre-defined in JSON)\nlow_boundary_vs = utils.load_from_json(DATA_PATH, 'boundaryLOW.json')\nhigh_boundary_vs = utils.load_from_json(DATA_PATH, 'boundaryHIGH.json')\n\n# Mark boundaries on mesh\ncreate_mesh_boundary_attributes(mesh, low_boundary_vs, high_boundary_vs)\n</code></pre> <p>What are boundaries?</p> <p>Boundaries are the start and end curves for interpolation. For a dome:</p> <ul> <li>LOW boundary: Base ring (where printing starts)</li> <li>HIGH boundary: Top ring (where printing ends)</li> </ul> <p>The slicer generates contours that smoothly transition between these boundaries.</p>"},{"location":"examples/02_curved_slicing/#2-configure-interpolation","title":"2. Configure Interpolation","text":"<pre><code>from compas_slicer.config import InterpolationConfig\n\navg_layer_height = 2.0\n\nconfig = InterpolationConfig(\n    avg_layer_height=avg_layer_height,\n    # Other options available\n)\n</code></pre>"},{"location":"examples/02_curved_slicing/#3-create-preprocessor-and-gradient-field","title":"3. Create Preprocessor and Gradient Field","text":"<pre><code>from compas_slicer.pre_processing import InterpolationSlicingPreprocessor\n\npreprocessor = InterpolationSlicingPreprocessor(mesh, config, DATA_PATH)\n\n# Create compound targets from boundaries\npreprocessor.create_compound_targets()\n\n# Compute gradient field between boundaries\ng_eval = preprocessor.create_gradient_evaluation(\n    norm_filename='gradient_norm.json',\n    g_filename='gradient.json',\n    target_1=preprocessor.target_LOW,\n    target_2=preprocessor.target_HIGH\n)\n</code></pre> <p>The gradient evaluation computes:</p> <ol> <li>Geodesic distances from each vertex to both boundaries</li> <li>Gradient field showing direction of steepest descent</li> <li>Gradient magnitude for identifying critical points</li> </ol>"},{"location":"examples/02_curved_slicing/#4-find-critical-points","title":"4. Find Critical Points","text":"<pre><code>preprocessor.find_critical_points(\n    g_eval,\n    output_filenames=['minima.json', 'maxima.json', 'saddles.json']\n)\n</code></pre> <p>Critical points are where the gradient is zero:</p> Type Description Example Minima Local low points Bottom of a valley Maxima Local high points Top of a bump Saddles Neither min nor max Mountain pass <p>These are important for handling branching geometry (like Y-shaped structures).</p>"},{"location":"examples/02_curved_slicing/#5-slice-with-interpolation","title":"5. Slice with Interpolation","text":"<pre><code>from compas_slicer.slicers import InterpolationSlicer\n\nslicer = InterpolationSlicer(mesh, preprocessor, config)\nslicer.slice_model()\n</code></pre> <p>The interpolation slicer:</p> <ol> <li>Creates a distance field that blends from LOW (0) to HIGH (1)</li> <li>Extracts isocurves at regular intervals</li> <li>Each isocurve becomes one layer (non-planar)</li> </ol>"},{"location":"examples/02_curved_slicing/#6-simplify-and-smooth","title":"6. Simplify and Smooth","text":"<pre><code>from compas_slicer.post_processing import simplify_paths_rdp, seams_smooth\n\nsimplify_paths_rdp(slicer, threshold=0.25)\nseams_smooth(slicer, smooth_distance=3)\n</code></pre>"},{"location":"examples/02_curved_slicing/#7-create-printpoints","title":"7. Create PrintPoints","text":"<pre><code>from compas_slicer.print_organization import InterpolationPrintOrganizer\n\nprint_organizer = InterpolationPrintOrganizer(slicer, config, DATA_PATH)\nprint_organizer.create_printpoints()\n</code></pre> <p>For curved slicing, printpoints include:</p> <ul> <li>Variable layer heights (thicker on steep areas)</li> <li>Surface normals for tool orientation</li> <li>Up-vectors for robotic end-effector</li> </ul>"},{"location":"examples/02_curved_slicing/#8-smooth-tool-orientations","title":"8. Smooth Tool Orientations","text":"<pre><code>from compas_slicer.print_organization import (\n    smooth_printpoints_up_vectors,\n    smooth_printpoints_layer_heights,\n)\n\n# Smooth up-vectors to avoid jerky robot motion\nsmooth_printpoints_up_vectors(print_organizer, strength=0.5, iterations=10)\n\n# Smooth layer heights for consistent extrusion\nsmooth_printpoints_layer_heights(print_organizer, strength=0.5, iterations=5)\n</code></pre> <p>Why smooth orientations?</p> <p>Raw orientations can change abruptly between points, causing:</p> <ul> <li>Jerky robot motion</li> <li>Vibrations in the print</li> <li>Potential collisions</li> </ul> <p>Smoothing creates gradual transitions while maintaining overall direction.</p>"},{"location":"examples/02_curved_slicing/#9-variable-velocity-by-layer-height","title":"9. Variable Velocity by Layer Height","text":"<pre><code>from compas_slicer.print_organization import set_linear_velocity_by_range\n\nset_linear_velocity_by_range(\n    print_organizer,\n    param_func=lambda ppt: ppt.layer_height,\n    parameter_range=[avg_layer_height * 0.5, avg_layer_height * 2.0],\n    velocity_range=[150, 70],  # Fast for thin, slow for thick\n    bound_remapping=False\n)\n</code></pre> <p>This sets velocity inversely proportional to layer height:</p> Layer Height Velocity Reason 1.0 mm (thin) 150 mm/s Less material, can go fast 4.0 mm (thick) 70 mm/s More material, need time to deposit"},{"location":"examples/02_curved_slicing/#10-safety-and-export","title":"10. Safety and Export","text":"<pre><code>from compas_slicer.print_organization import set_extruder_toggle, add_safety_printpoints\n\nset_extruder_toggle(print_organizer, slicer)\nadd_safety_printpoints(print_organizer, z_hop=10.0)\n\n# Export\nprintpoints_data = print_organizer.output_printpoints_dict()\nutils.save_to_json(printpoints_data, OUTPUT_PATH, 'out_printpoints.json')\n</code></pre>"},{"location":"examples/02_curved_slicing/#complete-code","title":"Complete Code","text":"<pre><code>--8&lt;-- \"examples/2_curved_slicing/ex2_curved_slicing.py\"\n</code></pre>"},{"location":"examples/02_curved_slicing/#running-the-example","title":"Running the Example","text":"<pre><code>cd examples/2_curved_slicing\npython ex2_curved_slicing.py\n</code></pre> <p>With visualization:</p> <pre><code>python ex2_curved_slicing.py --visualize\n</code></pre>"},{"location":"examples/02_curved_slicing/#input-data","title":"Input Data","text":"<p>The example uses a Y-shaped branching structure:</p> File Description <code>mesh.obj</code> Triangulated mesh <code>boundaryLOW.json</code> Vertex indices of lower boundary <code>boundaryHIGH.json</code> Vertex indices of upper boundary"},{"location":"examples/02_curved_slicing/#output-files","title":"Output Files","text":"File Description <code>gradient_norm.json</code> Gradient magnitude field <code>gradient.json</code> Gradient vector field <code>minima.json</code> Local minimum vertices <code>maxima.json</code> Local maximum vertices <code>saddles.json</code> Saddle point vertices <code>curved_slicer.json</code> Slicer output data <code>out_printpoints.json</code> Final printpoints"},{"location":"examples/02_curved_slicing/#mathematical-background","title":"Mathematical Background","text":"<p>The interpolation is based on geodesic distance fields:</p> <p>For each vertex \\(v\\):</p> <ul> <li>\\(d_{low}(v)\\) = geodesic distance to LOW boundary</li> <li>\\(d_{high}(v)\\) = geodesic distance to HIGH boundary</li> </ul> <p>The interpolated field at parameter \\(t \\in [0, 1]\\):</p> \\[f_t(v) = (1-t) \\cdot d_{low}(v) - t \\cdot d_{high}(v)\\] <p>The zero-level set of \\(f_t\\) gives one contour. Varying \\(t\\) generates all contours.</p>"},{"location":"examples/02_curved_slicing/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Boundaries define the slicing direction: Choose them carefully</li> <li>Mesh quality matters: Use clean, regular triangulation</li> <li>Critical points handle branching: Essential for Y-shapes, trees</li> <li>Smooth everything: Orientations, heights, velocities</li> <li>Variable velocity: Thick layers need slower speeds</li> </ol>"},{"location":"examples/02_curved_slicing/#references","title":"References","text":"<p>This technique is based on research from ETH Zurich:</p> <ul> <li>Mitropoulou, I., et al. \"Nonplanar 3D Printing of Bifurcating Forms\" (3D Printing and Additive Manufacturing, 2022)</li> <li>Mitropoulou, I., et al. \"Print Paths Key-framing\" (SCF 2020)</li> </ul>"},{"location":"examples/02_curved_slicing/#next-steps","title":"Next Steps","text":"<ul> <li>Scalar Field Slicing - Custom slicing patterns</li> <li>Slicing Algorithms - Theory deep dive</li> <li>Attribute Transfer - Custom per-point data</li> </ul>"},{"location":"examples/03_vertical_sorting/","title":"Vertical Layer Sorting","text":"<p>This example demonstrates how to handle models with multiple disconnected regions at the same height - like V-shapes, trees, or branching structures.</p> <p></p>"},{"location":"examples/03_vertical_sorting/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Sorting paths into vertical layers (disconnected regions)</li> <li>Reordering vertical layers for optimal printing</li> <li>Setting blend radius for smooth robotic motion</li> </ul>"},{"location":"examples/03_vertical_sorting/#the-problem","title":"The Problem","text":"<p>When slicing a V-shaped or branching model, a single horizontal slice may intersect multiple disconnected regions:</p> <pre><code>     Layer 5:    \u25cf          \u25cf    (two separate contours)\n     Layer 4:    \u25cf          \u25cf\n     Layer 3:     \u25cf        \u25cf\n     Layer 2:      \u25cf      \u25cf\n     Layer 1:       \u25cf    \u25cf\n     Layer 0:        \u25cf\u25cf\u25cf\u25cf        (one contour at base)\n</code></pre> <p>Without vertical sorting, the printer jumps between left and right branches randomly. With vertical sorting, each branch is printed completely before moving to the next.</p>"},{"location":"examples/03_vertical_sorting/#the-solution","title":"The Solution","text":"<pre><code>flowchart LR\n    A[Planar Slicing] --&gt; B[Sort into Vertical Layers]\n    B --&gt; C[Reorder Vertical Layers]\n    C --&gt; D[Print Organization]</code></pre>"},{"location":"examples/03_vertical_sorting/#step-by-step-walkthrough","title":"Step-by-Step Walkthrough","text":""},{"location":"examples/03_vertical_sorting/#1-standard-planar-slicing","title":"1. Standard Planar Slicing","text":"<pre><code>from compas.datastructures import Mesh\nfrom compas.geometry import Point\nfrom compas_slicer.slicers import PlanarSlicer\nfrom compas_slicer.pre_processing import move_mesh_to_point\n\nmesh = Mesh.from_obj(DATA_PATH / 'distorted_v_closed_mid_res.obj')\nmove_mesh_to_point(mesh, Point(0, 0, 0))\n\nslicer = PlanarSlicer(mesh, layer_height=5.0)\nslicer.slice_model()\n</code></pre>"},{"location":"examples/03_vertical_sorting/#2-sort-into-vertical-layers","title":"2. Sort into Vertical Layers","text":"<pre><code>from compas_slicer.post_processing import sort_into_vertical_layers\n\nsort_into_vertical_layers(\n    slicer,\n    dist_threshold=25.0,    # Max distance to group paths together\n    max_paths_per_layer=25  # Max paths per vertical layer\n)\n</code></pre> <p>This groups paths into \"vertical layers\" - continuous vertical columns that can be printed without jumping.</p> <p>Parameters:</p> Parameter Description <code>dist_threshold</code> Maximum XY distance between paths to be in same vertical layer <code>max_paths_per_layer</code> Limit on paths per vertical layer (prevents huge groups)"},{"location":"examples/03_vertical_sorting/#3-reorder-vertical-layers","title":"3. Reorder Vertical Layers","text":"<pre><code>from compas_slicer.post_processing import reorder_vertical_layers\n\nreorder_vertical_layers(slicer, align_with=\"x_axis\")\n</code></pre> <p>Orders the vertical layers for optimal printing sequence. Options:</p> Mode Description <code>\"x_axis\"</code> Left to right <code>\"y_axis\"</code> Front to back <code>\"centroids\"</code> By centroid position"},{"location":"examples/03_vertical_sorting/#4-standard-post-processing","title":"4. Standard Post-Processing","text":"<pre><code>from compas_slicer.post_processing import generate_brim, simplify_paths_rdp, seams_smooth\n\ngenerate_brim(slicer, layer_width=3.0, number_of_brim_offsets=5)\nsimplify_paths_rdp(slicer, threshold=0.7)\nseams_smooth(slicer, smooth_distance=10)\n</code></pre>"},{"location":"examples/03_vertical_sorting/#5-print-organization-with-blend-radius","title":"5. Print Organization with Blend Radius","text":"<pre><code>from compas_slicer.print_organization import (\n    PlanarPrintOrganizer,\n    set_extruder_toggle,\n    add_safety_printpoints,\n    set_linear_velocity_constant,\n    set_blend_radius,\n)\n\nprint_organizer = PlanarPrintOrganizer(slicer)\nprint_organizer.create_printpoints()\n\nset_extruder_toggle(print_organizer, slicer)\nadd_safety_printpoints(print_organizer, z_hop=10.0)\nset_linear_velocity_constant(print_organizer, v=25.0)\n\n# Blend radius for smooth robot motion\nset_blend_radius(print_organizer, d_fillet=10.0)\n</code></pre> <p>What is blend radius?</p> <p>Blend radius (or fillet) smooths sharp corners in the robot path. Instead of stopping at each point, the robot blends through with a curved motion.</p> <ul> <li><code>d_fillet=0</code>: Stop at each point (precise but slow)</li> <li><code>d_fillet=10</code>: 10mm blend radius (smooth and fast)</li> </ul>"},{"location":"examples/03_vertical_sorting/#complete-code","title":"Complete Code","text":"<pre><code>--8&lt;-- \"examples/3_planar_slicing_vertical_sorting/example_3_planar_vertical_sorting.py\"\n</code></pre>"},{"location":"examples/03_vertical_sorting/#running-the-example","title":"Running the Example","text":"<pre><code>cd examples/3_planar_slicing_vertical_sorting\npython example_3_planar_vertical_sorting.py --visualize\n</code></pre>"},{"location":"examples/03_vertical_sorting/#when-to-use-vertical-sorting","title":"When to Use Vertical Sorting","text":"<p>Use vertical sorting when your model has:</p> <ul> <li>Branching geometry: Y-shapes, trees, coral-like structures</li> <li>Multiple parts: Several objects on one build plate</li> <li>Islands: Disconnected regions at the same height</li> </ul>"},{"location":"examples/03_vertical_sorting/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Vertical sorting groups continuous regions: Print one branch completely before moving to the next</li> <li>Reordering optimizes travel: Choose sensible order to minimize jumps</li> <li>Blend radius matters for robots: Smooth motion reduces wear and improves quality</li> </ol>"},{"location":"examples/03_vertical_sorting/#next-steps","title":"Next Steps","text":"<ul> <li>G-code Generation - Export for desktop printers</li> <li>Curved Slicing - Non-planar approach for branching</li> </ul>"},{"location":"examples/04_gcode/","title":"G-code Generation","text":"<p>This example demonstrates exporting toolpaths to G-code for desktop FDM 3D printers like Prusa, Ender, or Ultimaker.</p>"},{"location":"examples/04_gcode/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Configuring printer parameters with <code>GcodeConfig</code></li> <li>Positioning mesh for delta vs cartesian printers</li> <li>Generating G-code from printpoints</li> <li>Understanding the G-code structure (header, purge, toolpath, footer)</li> </ul>"},{"location":"examples/04_gcode/#g-code-basics","title":"G-code Basics","text":"<p>G-code is the standard language for CNC machines and 3D printers. Each line is a command:</p> <pre><code>G1 X100 Y50 Z0.2 E1.5 F3600  ; Move to X=100, Y=50, Z=0.2 while extruding 1.5mm at 3600mm/min\n</code></pre> <p>Common commands:</p> Command Description <code>G0</code> / <code>G1</code> Linear move (G0 = rapid, G1 = controlled) <code>G28</code> Home axes <code>G90</code> / <code>G91</code> Absolute / relative positioning <code>M104</code> / <code>M109</code> Set extruder temp (no wait / wait) <code>M140</code> / <code>M190</code> Set bed temp (no wait / wait) <code>M106</code> / <code>M107</code> Fan on / off"},{"location":"examples/04_gcode/#the-pipeline","title":"The Pipeline","text":"<pre><code>flowchart LR\n    A[Slice Mesh] --&gt; B[Create PrintPoints]\n    B --&gt; C[Configure GcodeConfig]\n    C --&gt; D[Generate G-code]\n    D --&gt; E[Save .gcode File]</code></pre>"},{"location":"examples/04_gcode/#step-by-step-walkthrough","title":"Step-by-Step Walkthrough","text":""},{"location":"examples/04_gcode/#1-setup-and-configuration","title":"1. Setup and Configuration","text":"<pre><code>from pathlib import Path\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Point\nfrom compas_slicer.config import GcodeConfig\nfrom compas_slicer.pre_processing import move_mesh_to_point\n\nmesh = Mesh.from_obj(DATA_PATH / 'simple_vase_open_low_res.obj')\n\n# Create G-code configuration\ngcode_config = GcodeConfig()\n</code></pre>"},{"location":"examples/04_gcode/#2-position-mesh-for-printer-type","title":"2. Position Mesh for Printer Type","text":"<pre><code>if gcode_config.delta:\n    # Delta printers: origin at center\n    move_mesh_to_point(mesh, Point(0, 0, 0))\nelse:\n    # Cartesian printers: center in build volume\n    move_mesh_to_point(mesh, Point(\n        gcode_config.print_volume_x / 2,\n        gcode_config.print_volume_y / 2,\n        0\n    ))\n</code></pre> <p>Delta vs Cartesian</p> <ul> <li>Delta printers: Circular build plate, origin at center (0, 0, 0)</li> <li>Cartesian printers: Rectangular build plate, origin at corner (0, 0, 0)</li> </ul>"},{"location":"examples/04_gcode/#3-slice-and-process","title":"3. Slice and Process","text":"<pre><code>from compas_slicer.slicers import PlanarSlicer\nfrom compas_slicer.post_processing import generate_brim, simplify_paths_rdp, seams_smooth\n\nslicer = PlanarSlicer(mesh, layer_height=4.5)\nslicer.slice_model()\n\ngenerate_brim(slicer, layer_width=3.0, number_of_brim_offsets=4)\nsimplify_paths_rdp(slicer, threshold=0.6)\nseams_smooth(slicer, smooth_distance=10)\n</code></pre>"},{"location":"examples/04_gcode/#4-create-printpoints","title":"4. Create PrintPoints","text":"<pre><code>from compas_slicer.print_organization import PlanarPrintOrganizer, set_extruder_toggle\n\nprint_organizer = PlanarPrintOrganizer(slicer)\nprint_organizer.create_printpoints()\nset_extruder_toggle(print_organizer, slicer)\n</code></pre>"},{"location":"examples/04_gcode/#5-generate-and-save-g-code","title":"5. Generate and Save G-code","text":"<pre><code>from compas_slicer.utilities import save_to_text_file\n\ngcode_text = print_organizer.output_gcode(gcode_config)\nsave_to_text_file(gcode_text, OUTPUT_PATH, 'my_gcode.gcode')\n</code></pre>"},{"location":"examples/04_gcode/#gcodeconfig-parameters","title":"GcodeConfig Parameters","text":"<p>The <code>GcodeConfig</code> dataclass controls all printer parameters:</p>"},{"location":"examples/04_gcode/#hardware-settings","title":"Hardware Settings","text":"Parameter Default Description <code>nozzle_diameter</code> 0.4 mm Nozzle diameter <code>filament_diameter</code> 1.75 mm Filament diameter (1.75 or 2.85) <code>delta</code> False Delta printer flag <code>print_volume</code> (300, 300, 600) Build volume (x, y, z) in mm"},{"location":"examples/04_gcode/#temperature-fan","title":"Temperature &amp; Fan","text":"Parameter Default Description <code>extruder_temperature</code> 200\u00b0C Hotend temperature <code>bed_temperature</code> 60\u00b0C Heated bed temperature <code>fan_speed</code> 255 Part cooling fan (0-255) <code>fan_start_z</code> 0.0 mm Height to enable fan"},{"location":"examples/04_gcode/#extrusion","title":"Extrusion","text":"Parameter Default Description <code>layer_width</code> 0.6 mm Extrusion width <code>flowrate</code> 1.0 Flow multiplier <code>flow_over</code> 1.0 Overextrusion factor near bed <code>min_over_z</code> 0.0 mm Height for overextrusion"},{"location":"examples/04_gcode/#motion","title":"Motion","text":"Parameter Default Description <code>feedrate</code> 3600 mm/min Print speed (60 mm/s) <code>feedrate_travel</code> 4800 mm/min Travel speed (80 mm/s) <code>feedrate_low</code> 1800 mm/min First layer speed (30 mm/s) <code>feedrate_retraction</code> 2400 mm/min Retraction speed <code>acceleration</code> 0 Acceleration (0 = default) <code>jerk</code> 0 Jerk (0 = default)"},{"location":"examples/04_gcode/#retraction","title":"Retraction","text":"Parameter Default Description <code>z_hop</code> 0.5 mm Z lift during travel <code>retraction_length</code> 1.0 mm Filament retraction distance <code>retraction_min_travel</code> 6.0 mm Minimum travel to trigger retraction"},{"location":"examples/04_gcode/#custom-configuration","title":"Custom Configuration","text":"<p>Override defaults when creating the config:</p> <pre><code>gcode_config = GcodeConfig(\n    extruder_temperature=210,\n    bed_temperature=65,\n    feedrate=2400,  # 40 mm/s\n    layer_width=0.45,\n    retraction_length=0.8,\n)\n</code></pre> <p>Or load from a TOML file using <code>PrintConfig</code>:</p> <pre><code>from compas_slicer.config import PrintConfig\n\nconfig = PrintConfig.from_toml(\"my_printer.toml\")\ngcode_config = config.gcode\n</code></pre>"},{"location":"examples/04_gcode/#g-code-structure","title":"G-code Structure","text":"<p>The generated G-code has four sections:</p>"},{"location":"examples/04_gcode/#1-header","title":"1. Header","text":"<pre><code>;G-code generated by compas_slicer\nT0                             ;select tool 0\nG21                            ;metric units\nG90                            ;absolute positioning\nM140 S60                       ;set bed temp (no wait)\nM104 S200                      ;set extruder temp (no wait)\nM109 S200                      ;wait for extruder temp\nM190 S60                       ;wait for bed temp\nG28 X0 Y0                      ;home X and Y\nG28 Z0                         ;home Z\n</code></pre>"},{"location":"examples/04_gcode/#2-purge-line","title":"2. Purge Line","text":"<pre><code>;Purge line\nG1 Z0.2                        ;move to purge height\nG1 X5 Y5                       ;move to purge start\nG1 Y150 E3.5                   ;purge line 1\nG1 X5.6                        ;step over\nG1 Y5 E3.5                     ;purge line 2\nG92 E0                         ;reset extruder position\n</code></pre>"},{"location":"examples/04_gcode/#3-toolpath","title":"3. Toolpath","text":"<pre><code>;Begin toolpath\nG1 F1800                       ;slow feedrate for adhesion\nG1 X50.000 Y30.000 Z0.200\nG1 X51.234 Y30.567 E0.125\n...\n</code></pre>"},{"location":"examples/04_gcode/#4-footer","title":"4. Footer","text":"<pre><code>;End of print\nG1 E-1.0                       ;final retract\nG1 Z10.000                     ;lift nozzle\nG1 X0 Y0                       ;move to home\nM104 S0                        ;extruder heater off\nM140 S0                        ;bed heater off\nM84                            ;motors off\n</code></pre>"},{"location":"examples/04_gcode/#volumetric-extrusion","title":"Volumetric Extrusion","text":"<p>The G-code generator calculates extrusion using volumetric math:</p> \\[E = \\frac{d \\cdot h \\cdot w}{\\pi (D/2)^2} \\cdot f\\] <p>Where:</p> <ul> <li>\\(E\\) = extrusion length (mm)</li> <li>\\(d\\) = travel distance (mm)</li> <li>\\(h\\) = layer height (mm)</li> <li>\\(w\\) = path width (mm)</li> <li>\\(D\\) = filament diameter (mm)</li> <li>\\(f\\) = flow rate multiplier</li> </ul> <p>This ensures correct material deposition regardless of layer height or path width.</p>"},{"location":"examples/04_gcode/#complete-code","title":"Complete Code","text":"<pre><code>--8&lt;-- \"examples/4_gcode_generation/example_4_gcode.py\"\n</code></pre>"},{"location":"examples/04_gcode/#running-the-example","title":"Running the Example","text":"<pre><code>cd examples/4_gcode_generation\npython example_4_gcode.py\n</code></pre> <p>With visualization:</p> <pre><code>python example_4_gcode.py --visualize\n</code></pre> <p>Output: <code>examples/4_gcode_generation/data/output/my_gcode.gcode</code></p>"},{"location":"examples/04_gcode/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Configure for your printer: Set temperatures, speeds, and retraction for your specific machine</li> <li>Position mesh correctly: Delta vs cartesian printers have different origins</li> <li>Volumetric extrusion: Automatically calculates correct E values</li> <li>Modular structure: Header/purge/toolpath/footer makes debugging easier</li> </ol>"},{"location":"examples/04_gcode/#next-steps","title":"Next Steps","text":"<ul> <li>Scalar Field Slicing - Custom slicing patterns</li> <li>Print Organization - More fabrication parameters</li> </ul>"},{"location":"examples/05_scalar_field/","title":"Scalar Field Slicing","text":"<p>This example demonstrates non-planar slicing using a custom scalar field - enabling you to print along arbitrary surfaces rather than horizontal planes.</p>"},{"location":"examples/05_scalar_field/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Creating a scalar field from geometric distance</li> <li>Assigning scalar values to mesh vertices</li> <li>Slicing with <code>ScalarFieldSlicer</code></li> <li>Printing on top of existing geometry</li> </ul>"},{"location":"examples/05_scalar_field/#why-scalar-field-slicing","title":"Why Scalar Field Slicing?","text":"<p>Traditional planar slicing creates horizontal layers. But what if you want to:</p> <ul> <li>Print on a curved base: Add features on top of an existing surface</li> <li>Follow terrain: Print conformal layers over a landscape</li> <li>Custom layer patterns: Define exactly where each layer goes</li> </ul> <p>Scalar field slicing generates isocurves (contours) from any per-vertex scalar field, not just Z-height.</p> <pre><code>Planar slicing:              Scalar field slicing:\n     _____                        _____\n    |_____|  Z=3                 /     \\  u=3\n    |_____|  Z=2                /       \\ u=2\n    |_____|  Z=1               (         ) u=1\n    |_____|  Z=0                \\_______/  u=0 (base surface)\n</code></pre>"},{"location":"examples/05_scalar_field/#the-pipeline","title":"The Pipeline","text":"<pre><code>flowchart TD\n    A[Load Mesh to Slice] --&gt; B[Load Base Surface]\n    B --&gt; C[Compute Distance Field]\n    C --&gt; D[Assign to Vertices]\n    D --&gt; E[ScalarFieldSlicer]\n    E --&gt; F[Extract Isocurves]\n    F --&gt; G[Create PrintPoints]</code></pre>"},{"location":"examples/05_scalar_field/#step-by-step-walkthrough","title":"Step-by-Step Walkthrough","text":""},{"location":"examples/05_scalar_field/#1-load-meshes","title":"1. Load Meshes","text":"<p>We need two meshes:</p> <ul> <li>Mesh to slice: The geometry you want to print</li> <li>Base surface: The surface to print on top of</li> </ul> <pre><code>from pathlib import Path\nfrom compas.datastructures import Mesh\n\nmesh = Mesh.from_obj(DATA_PATH / 'geom_to_slice.obj')  # Geometry to slice\nbase = Mesh.from_obj(DATA_PATH / 'custom_base.obj')    # Base surface\n</code></pre>"},{"location":"examples/05_scalar_field/#2-compute-distance-field","title":"2. Compute Distance Field","text":"<p>For each vertex of the mesh, compute its distance to the base surface:</p> <pre><code>from compas.geometry import distance_point_point\nimport compas_slicer.utilities as utils\n\n# Get all vertex coordinates\npts = [mesh.vertex_coordinates(v_key, axes='xyz') for v_key in mesh.vertices()]\n\n# Project points onto base surface\n_, projected_pts = utils.pull_pts_to_mesh_faces(base, pts)\n\n# Compute distance from each point to its projection\nu = [distance_point_point(pt, proj_pt) for pt, proj_pt in zip(pts, projected_pts)]\n</code></pre> <p>This creates a scalar field <code>u</code> where:</p> <ul> <li><code>u = 0</code> at points on the base surface</li> <li><code>u &gt; 0</code> at points above the base</li> <li>The value increases with distance from the base</li> </ul>"},{"location":"examples/05_scalar_field/#3-assign-scalar-field-to-mesh","title":"3. Assign Scalar Field to Mesh","text":"<p>Store the scalar values as vertex attributes:</p> <pre><code>mesh.update_default_vertex_attributes({'scalar_field': 0.0})\n\nfor i, (v_key, data) in enumerate(mesh.vertices(data=True)):\n    data['scalar_field'] = u[i]\n</code></pre>"},{"location":"examples/05_scalar_field/#4-slice-with-scalar-field","title":"4. Slice with Scalar Field","text":"<pre><code>from compas_slicer.slicers import ScalarFieldSlicer\n\nslicer = ScalarFieldSlicer(mesh, u, no_of_isocurves=50)\nslicer.slice_model()\n</code></pre> <p>The slicer:</p> <ol> <li>Sorts vertices by scalar value</li> <li>Determines the range <code>[u_min, u_max]</code></li> <li>Creates <code>no_of_isocurves</code> evenly spaced threshold values</li> <li>Extracts the zero-crossing contour for each threshold</li> </ol> <p>Parameters:</p> Parameter Description <code>mesh</code> The mesh to slice <code>u</code> List of scalar values (one per vertex) <code>no_of_isocurves</code> Number of contours to extract"},{"location":"examples/05_scalar_field/#5-simplify-and-create-printpoints","title":"5. Simplify and Create PrintPoints","text":"<pre><code>from compas_slicer.post_processing import simplify_paths_rdp\nfrom compas_slicer.print_organization import ScalarFieldPrintOrganizer\n\nsimplify_paths_rdp(slicer, threshold=0.3)\n\nprint_organizer = ScalarFieldPrintOrganizer(slicer, DATA_PATH=DATA_PATH)\nprint_organizer.create_printpoints()\n</code></pre>"},{"location":"examples/05_scalar_field/#6-export-results","title":"6. Export Results","text":"<pre><code>printpoints_data = print_organizer.output_printpoints_dict()\nutils.save_to_json(printpoints_data, OUTPUT_PATH, 'out_printpoints.json')\n</code></pre>"},{"location":"examples/05_scalar_field/#how-it-works","title":"How It Works","text":""},{"location":"examples/05_scalar_field/#isocurve-extraction","title":"Isocurve Extraction","text":"<p>An isocurve is a contour where the scalar field equals a specific value. For a threshold \\(t\\):</p> \\[\\text{isocurve}_t = \\{p \\in \\text{mesh} : u(p) = t\\}\\] <p>The algorithm finds edges where the scalar field crosses the threshold:</p> <pre><code>Vertex A (u=2.3)\n    \u25cf\n     \\        Threshold t=2.0\n      \\       Isocurve crosses here!\n       \u25cf\nVertex B (u=1.7)\n</code></pre> <p>The crossing point is found by linear interpolation:</p> \\[p = A + \\frac{t - u_A}{u_B - u_A}(B - A)\\]"},{"location":"examples/05_scalar_field/#choosing-number-of-isocurves","title":"Choosing Number of Isocurves","text":"<p>The number of isocurves determines layer height:</p> \\[\\text{avg layer height} \\approx \\frac{u_{max} - u_{min}}{\\text{no\\_of\\_isocurves}}\\] <p>More isocurves = thinner layers = smoother surface but longer print time.</p>"},{"location":"examples/05_scalar_field/#custom-scalar-fields","title":"Custom Scalar Fields","text":"<p>You can use any scalar field, not just distance:</p>"},{"location":"examples/05_scalar_field/#height-based-field","title":"Height-Based Field","text":"<pre><code>u = [mesh.vertex_coordinates(v)[2] for v in mesh.vertices()]\n</code></pre> <p>This is equivalent to planar slicing.</p>"},{"location":"examples/05_scalar_field/#radial-field","title":"Radial Field","text":"<pre><code>from compas.geometry import Point, distance_point_point\n\ncenter = Point(0, 0, 0)\nu = [distance_point_point(mesh.vertex_coordinates(v), center)\n     for v in mesh.vertices()]\n</code></pre> <p>Creates concentric circular layers (spiral vase mode).</p>"},{"location":"examples/05_scalar_field/#geodesic-field","title":"Geodesic Field","text":"<pre><code># Using igl for geodesic distance from boundary vertices\nimport igl\ndistances = igl.exact_geodesic(V, F, boundary_vertices)\n</code></pre> <p>Creates layers that follow surface curvature.</p>"},{"location":"examples/05_scalar_field/#complete-code","title":"Complete Code","text":"<pre><code>--8&lt;-- \"examples/5_non_planar_slicing_on_custom_base/scalar_field_slicing.py\"\n</code></pre>"},{"location":"examples/05_scalar_field/#running-the-example","title":"Running the Example","text":"<pre><code>cd examples/5_non_planar_slicing_on_custom_base\npython scalar_field_slicing.py\n</code></pre> <p>With visualization:</p> <pre><code>python scalar_field_slicing.py --visualize\n</code></pre>"},{"location":"examples/05_scalar_field/#output-files","title":"Output Files","text":"File Description <code>distance_field.json</code> Scalar values for visualization <code>isocontours.json</code> Slicer output data <code>out_printpoints.json</code> Final printpoints"},{"location":"examples/05_scalar_field/#use-cases","title":"Use Cases","text":""},{"location":"examples/05_scalar_field/#printing-on-curved-surfaces","title":"Printing on Curved Surfaces","text":"<p>Print text or patterns on top of a curved object:</p> <ol> <li>Load the base object</li> <li>Create the feature geometry offset above the surface</li> <li>Use distance-to-surface as scalar field</li> <li>Layers conform to the base curvature</li> </ol>"},{"location":"examples/05_scalar_field/#conformal-printing","title":"Conformal Printing","text":"<p>Print a thin shell that follows terrain:</p> <ol> <li>Load terrain mesh as base</li> <li>Create offset shell above terrain</li> <li>Scalar field = distance from terrain</li> <li>Each layer follows the terrain contours</li> </ol>"},{"location":"examples/05_scalar_field/#variable-layer-height","title":"Variable Layer Height","text":"<p>Combine with other slicing methods:</p> <ol> <li>Planar slice the main body</li> <li>Scalar field slice the curved top</li> <li>Merge the toolpaths</li> </ol>"},{"location":"examples/05_scalar_field/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Scalar field defines layers: Any per-vertex value can drive slicing</li> <li>Distance field is common: Distance from base surface creates conformal layers</li> <li>Isocurves are contours: Zero-crossings at each threshold value</li> <li>Number of curves = resolution: More isocurves = finer layers</li> </ol>"},{"location":"examples/05_scalar_field/#next-steps","title":"Next Steps","text":"<ul> <li>Attribute Transfer - Transfer mesh properties to toolpaths</li> <li>Slicing Algorithms - Deep dive into theory</li> <li>Curved Slicing - Geodesic interpolation approach</li> </ul>"},{"location":"examples/06_attributes/","title":"Attribute Transfer","text":"<p>This example demonstrates how to transfer mesh attributes (overhang angles, normals, colors, custom data) to printpoints for variable printing parameters based on geometry.</p>"},{"location":"examples/06_attributes/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Adding face and vertex attributes to meshes</li> <li>Transferring attributes from mesh to printpoints</li> <li>Using transferred data for variable printing</li> <li>Understanding face vs vertex attribute interpolation</li> </ul>"},{"location":"examples/06_attributes/#why-attribute-transfer","title":"Why Attribute Transfer?","text":"<p>Different parts of a model may need different printing parameters:</p> <ul> <li>Overhangs need slower speeds and more cooling</li> <li>Visible surfaces need finer resolution</li> <li>Structural areas need higher infill</li> <li>Colored regions need different materials</li> </ul> <p>Attribute transfer lets you encode this information on the mesh and automatically apply it to toolpaths.</p>"},{"location":"examples/06_attributes/#the-pipeline","title":"The Pipeline","text":"<pre><code>flowchart LR\n    A[Mesh] --&gt; B[Add Attributes]\n    B --&gt; C[Slice]\n    C --&gt; D[Create PrintPoints]\n    D --&gt; E[Transfer Attributes]\n    E --&gt; F[Variable Parameters]</code></pre>"},{"location":"examples/06_attributes/#step-by-step-walkthrough","title":"Step-by-Step Walkthrough","text":""},{"location":"examples/06_attributes/#1-load-mesh","title":"1. Load Mesh","text":"<pre><code>from pathlib import Path\nfrom compas.datastructures import Mesh\n\nmesh = Mesh.from_obj(DATA_PATH / 'distorted_v_closed_low_res.obj')\n</code></pre>"},{"location":"examples/06_attributes/#2-add-face-attributes","title":"2. Add Face Attributes","text":"<p>Face attributes are values assigned to each face of the mesh. They can be any type: float, bool, string, list, etc.</p>"},{"location":"examples/06_attributes/#overhang-angle-float","title":"Overhang Angle (Float)","text":"<p>Calculate how much each face is tilted from vertical:</p> <pre><code>from compas.geometry import Vector\n\nmesh.update_default_face_attributes({'overhang': 0.0})\n\nfor f_key, data in mesh.faces(data=True):\n    face_normal = mesh.face_normal(f_key, unitized=True)\n    # Dot product with up vector: 1 = horizontal face, 0 = vertical face\n    data['overhang'] = Vector(0.0, 0.0, 1.0).dot(face_normal)\n</code></pre> Overhang Value Meaning 1.0 Horizontal (flat top) 0.0 Vertical (wall) -1.0 Horizontal facing down (overhang)"},{"location":"examples/06_attributes/#boolean-attribute","title":"Boolean Attribute","text":"<p>Check if face normal points toward positive Y:</p> <pre><code>mesh.update_default_face_attributes({'positive_y_axis': False})\n\nfor f_key, data in mesh.faces(data=True):\n    face_normal = mesh.face_normal(f_key, unitized=True)\n    is_positive_y = Vector(0.0, 1.0, 0.0).dot(face_normal) &gt; 0\n    data['positive_y_axis'] = is_positive_y\n</code></pre>"},{"location":"examples/06_attributes/#3-add-vertex-attributes","title":"3. Add Vertex Attributes","text":"<p>Vertex attributes must be numeric types that can be interpolated (float, numpy array).</p>"},{"location":"examples/06_attributes/#distance-from-plane-float","title":"Distance from Plane (Float)","text":"<pre><code>from compas.geometry import Point, Vector, distance_point_plane\n\nmesh.update_default_vertex_attributes({'dist_from_plane': 0.0})\n\nplane = (Point(0.0, 0.0, -30.0), Vector(0.0, 0.5, 0.5))\n\nfor v_key, data in mesh.vertices(data=True):\n    v_coord = mesh.vertex_coordinates(v_key, axes='xyz')\n    data['dist_from_plane'] = distance_point_plane(v_coord, plane)\n</code></pre>"},{"location":"examples/06_attributes/#direction-vector-array","title":"Direction Vector (Array)","text":"<pre><code>import numpy as np\nfrom compas.geometry import normalize_vector\n\nmesh.update_default_vertex_attributes({'direction_to_pt': 0.0})\n\ntarget_pt = Point(4.0, 1.0, 0.0)\n\nfor v_key, data in mesh.vertices(data=True):\n    v_coord = mesh.vertex_coordinates(v_key, axes='xyz')\n    direction = Vector.from_start_end(v_coord, target_pt)\n    data['direction_to_pt'] = np.array(normalize_vector(direction))\n</code></pre>"},{"location":"examples/06_attributes/#4-slice-and-create-printpoints","title":"4. Slice and Create PrintPoints","text":"<pre><code>from compas_slicer.slicers import PlanarSlicer\nfrom compas_slicer.post_processing import simplify_paths_rdp\nfrom compas_slicer.print_organization import PlanarPrintOrganizer\n\nslicer = PlanarSlicer(mesh, layer_height=5.0)\nslicer.slice_model()\nsimplify_paths_rdp(slicer, threshold=1.0)\n\nprint_organizer = PlanarPrintOrganizer(slicer)\nprint_organizer.create_printpoints()\n</code></pre>"},{"location":"examples/06_attributes/#5-transfer-attributes","title":"5. Transfer Attributes","text":"<pre><code>from compas_slicer.utilities.attributes_transfer import transfer_mesh_attributes_to_printpoints\n\ntransfer_mesh_attributes_to_printpoints(mesh, print_organizer.printpoints)\n</code></pre> <p>This function:</p> <ol> <li>Finds which mesh face each printpoint lies on</li> <li>For face attributes: Directly copies the value</li> <li>For vertex attributes: Interpolates using barycentric coordinates</li> </ol>"},{"location":"examples/06_attributes/#6-access-transferred-attributes","title":"6. Access Transferred Attributes","text":"<pre><code># Get all values of an attribute across all printpoints\noverhangs = print_organizer.get_printpoints_attribute(attr_name='overhang')\npositive_y = print_organizer.get_printpoints_attribute(attr_name='positive_y_axis')\ndistances = print_organizer.get_printpoints_attribute(attr_name='dist_from_plane')\ndirections = print_organizer.get_printpoints_attribute(attr_name='direction_to_pt')\n</code></pre> <p>Or access individual printpoint attributes:</p> <pre><code>for ppt in print_organizer.printpoints_iterator():\n    if ppt.attributes.get('overhang', 0) &lt; 0:\n        # This is an overhang - adjust printing parameters\n        ppt.velocity = 20.0  # Slow down\n</code></pre>"},{"location":"examples/06_attributes/#how-interpolation-works","title":"How Interpolation Works","text":""},{"location":"examples/06_attributes/#face-attributes","title":"Face Attributes","text":"<p>Face attributes are discrete - each point on a face gets the same value:</p> <pre><code>Face A (overhang=0.8)    Face B (overhang=0.3)\n      _____                  _____\n     |  \u25cf  |                |  \u25cf  |\n     |_____|                |_____|\n\n   Point gets 0.8         Point gets 0.3\n</code></pre>"},{"location":"examples/06_attributes/#vertex-attributes","title":"Vertex Attributes","text":"<p>Vertex attributes are interpolated using barycentric coordinates:</p> <pre><code>        V1 (dist=10)\n           \u25cf\n          /|\\\n         / | \\\n        /  \u25cfP \\      P is at barycentric coords (0.2, 0.3, 0.5)\n       /   |   \\     dist(P) = 0.2\u00d710 + 0.3\u00d75 + 0.5\u00d72 = 4.5\n      \u25cf----+----\u25cf\n    V2 (dist=5)  V3 (dist=2)\n</code></pre> <p>The interpolation formula:</p> \\[\\text{attr}(P) = \\lambda_1 \\cdot \\text{attr}(V_1) + \\lambda_2 \\cdot \\text{attr}(V_2) + \\lambda_3 \\cdot \\text{attr}(V_3)\\] <p>Where \\(\\lambda_1 + \\lambda_2 + \\lambda_3 = 1\\) are the barycentric coordinates.</p>"},{"location":"examples/06_attributes/#practical-applications","title":"Practical Applications","text":""},{"location":"examples/06_attributes/#variable-velocity-by-overhang","title":"Variable Velocity by Overhang","text":"<p>Slow down on overhangs for better print quality:</p> <pre><code>from compas_slicer.print_organization import set_linear_velocity_by_range\n\nset_linear_velocity_by_range(\n    print_organizer,\n    param_func=lambda ppt: ppt.attributes.get('overhang', 0),\n    parameter_range=[-1.0, 1.0],    # overhang range\n    velocity_range=[15, 60],         # slow for overhangs, fast for flat\n)\n</code></pre>"},{"location":"examples/06_attributes/#color-based-material-selection","title":"Color-Based Material Selection","text":"<pre><code># Assume 'color' attribute is 0 (white) or 1 (black)\nfor ppt in print_organizer.printpoints_iterator():\n    if ppt.attributes.get('color', 0) &gt; 0.5:\n        ppt.extruder_id = 1  # Use second extruder\n    else:\n        ppt.extruder_id = 0\n</code></pre>"},{"location":"examples/06_attributes/#structural-reinforcement","title":"Structural Reinforcement","text":"<pre><code># Higher flow rate in structural regions\nfor ppt in print_organizer.printpoints_iterator():\n    if ppt.attributes.get('is_structural', False):\n        ppt.flowrate = 1.2  # 20% more material\n</code></pre>"},{"location":"examples/06_attributes/#attribute-type-requirements","title":"Attribute Type Requirements","text":"Attribute Location Allowed Types Interpolation Face Any (float, bool, str, list, dict) None (direct copy) Vertex Numeric only (float, np.array) Barycentric <p>Vertex Attribute Limitation</p> <p>Vertex attributes must be numeric types that can be meaningfully multiplied by floats. Boolean or string vertex attributes will cause errors during interpolation.</p>"},{"location":"examples/06_attributes/#complete-code","title":"Complete Code","text":"<pre><code>--8&lt;-- \"examples/6_attributes_transfer/example_6_attributes_transfer.py\"\n</code></pre>"},{"location":"examples/06_attributes/#running-the-example","title":"Running the Example","text":"<pre><code>cd examples/6_attributes_transfer\npython example_6_attributes_transfer.py\n</code></pre> <p>With visualization:</p> <pre><code>python example_6_attributes_transfer.py --visualize\n</code></pre>"},{"location":"examples/06_attributes/#output-files","title":"Output Files","text":"File Description <code>slicer_data.json</code> Sliced geometry <code>out_printpoints.json</code> PrintPoints with attributes <code>overhangs_list.json</code> Overhang values per point <code>positive_y_axis_list.json</code> Boolean values per point <code>dist_from_plane_list.json</code> Distance values per point <code>direction_to_pt_list.json</code> Direction vectors per point"},{"location":"examples/06_attributes/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Face vs vertex attributes: Face attributes are discrete, vertex attributes are interpolated</li> <li>Numeric vertex attributes only: Must be floats or arrays for barycentric interpolation</li> <li>Automatic transfer: One function call transfers all mesh attributes to printpoints</li> <li>Variable parameters: Use transferred attributes to drive printing parameters</li> </ol>"},{"location":"examples/06_attributes/#next-steps","title":"Next Steps","text":"<ul> <li>Print Organization - More on fabrication parameters</li> <li>Curved Slicing - Combine with non-planar techniques</li> <li>API Reference - <code>transfer_mesh_attributes_to_printpoints</code> details</li> </ul>"},{"location":"examples/07_medial_axis/","title":"Medial Axis Infill","text":"<p>This example demonstrates generating infill paths using the medial axis (straight skeleton) of each layer contour - a geometry-aware approach that adapts to the shape.</p>"},{"location":"examples/07_medial_axis/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Generating medial axis infill using CGAL's straight skeleton</li> <li>Controlling infill density with <code>min_length</code></li> <li>Understanding bisector vs inner_bisector edges</li> <li>When to use medial axis vs traditional infill patterns</li> </ul>"},{"location":"examples/07_medial_axis/#why-medial-axis-infill","title":"Why Medial Axis Infill?","text":"<p>Traditional infill patterns (grid, honeycomb, gyroid) ignore the geometry - they apply the same pattern everywhere. Medial axis infill follows the natural centerlines of the shape:</p> <pre><code>Traditional Grid:              Medial Axis:\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502               \u2502      \u2502      \u2502\n  \u2502\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u2502               \u2502   \u2572  \u2502  \u2571   \u2502\n  \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502               \u2502    \u2572 \u2502 \u2571    \u2502\n  \u2502\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u2502               \u2502\u2500\u2500\u2500\u2500\u2500\u2573\u2502\u2573\u2500\u2500\u2500\u2500\u2500\u2502\n  \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502               \u2502    \u2571 \u2502 \u2572    \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   (ignores shape)              (follows geometry)\n</code></pre> <p>Benefits:</p> <ul> <li>Adaptive density: Naturally denser in thin walls, sparser in open areas</li> <li>Follows geometry: Infill aligns with the shape's structure</li> <li>Handles complexity: Works well with irregular shapes, holes, and thin features</li> </ul>"},{"location":"examples/07_medial_axis/#the-pipeline","title":"The Pipeline","text":"<pre><code>flowchart LR\n    A[Slice Mesh] --&gt; B[For Each Layer]\n    B --&gt; C[Compute Straight Skeleton]\n    C --&gt; D[Extract Skeleton Edges]\n    D --&gt; E[Filter by Length]\n    E --&gt; F[Add as Infill Paths]</code></pre>"},{"location":"examples/07_medial_axis/#step-by-step-walkthrough","title":"Step-by-Step Walkthrough","text":""},{"location":"examples/07_medial_axis/#1-load-and-slice","title":"1. Load and Slice","text":"<pre><code>from pathlib import Path\nfrom compas.datastructures import Mesh\nfrom compas_slicer.slicers import PlanarSlicer\nfrom compas_slicer.post_processing import simplify_paths_rdp\n\nmesh = Mesh.from_obj(DATA_PATH / 'simple_vase_open_low_res.obj')\n\nslicer = PlanarSlicer(mesh, layer_height=2.0)\nslicer.slice_model()\n\n# Simplify paths first (recommended)\nsimplify_paths_rdp(slicer, threshold=0.5)\n</code></pre>"},{"location":"examples/07_medial_axis/#2-generate-medial-axis-infill","title":"2. Generate Medial Axis Infill","text":"<pre><code>from compas_slicer.post_processing import generate_medial_axis_infill\n\ngenerate_medial_axis_infill(\n    slicer,\n    min_length=2.0,        # Skip edges shorter than 2mm\n    include_bisectors=True  # Include spokes to boundary\n)\n</code></pre> <p>Parameters:</p> Parameter Description <code>min_length</code> Minimum skeleton edge length to include (mm) <code>include_bisectors</code> Include edges connecting skeleton to boundary"},{"location":"examples/07_medial_axis/#3-continue-with-print-organization","title":"3. Continue with Print Organization","text":"<pre><code>from compas_slicer.print_organization import PlanarPrintOrganizer\n\nprint_organizer = PlanarPrintOrganizer(slicer)\nprint_organizer.create_printpoints()\n# ... rest of print organization\n</code></pre>"},{"location":"examples/07_medial_axis/#how-it-works","title":"How It Works","text":""},{"location":"examples/07_medial_axis/#the-straight-skeleton","title":"The Straight Skeleton","text":"<p>The straight skeleton is computed by \"shrinking\" the polygon inward at constant speed. Where the shrinking boundary meets itself, skeleton edges form:</p> <pre><code>Original polygon:           After shrinking:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502       \u2502                  \u2502\u2572     \u2571\u2502\n    \u2502       \u2502        \u2192         \u2502 \u2572   \u2571 \u2502\n    \u2502       \u2502                  \u2502  \u2572 \u2571  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2573\u2500\u2500\u2500\u2518\n                                  skeleton\n</code></pre> <p>CGAL's <code>interior_straight_skeleton()</code> returns a graph with:</p> <ul> <li>Boundary edges: Original polygon edges</li> <li>Inner bisector edges: Internal skeleton (medial axis)</li> <li>Bisector edges: Spokes connecting skeleton to boundary vertices</li> </ul>"},{"location":"examples/07_medial_axis/#edge-types","title":"Edge Types","text":"<pre><code>      \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\n     \u2571\u2502   boundary  \u2502\u2572\n    \u2571 \u2502             \u2502 \u2572\n   \u2571  \u2502   inner_    \u2502  \u2572\n  \u25cf\u2500\u2500\u2500\u25cf   bisector  \u25cf\u2500\u2500\u2500\u25cf\n   \u2572  \u2502             \u2502  \u2571\n    \u2572 \u2502   bisector  \u2502 \u2571\n     \u2572\u2502   (spoke)   \u2502\u2571\n      \u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\n</code></pre> Edge Type Description Use Case <code>boundary</code> Original polygon edges Skipped (already in perimeter) <code>inner_bisector</code> Internal skeleton Always included <code>bisector</code> Skeleton to boundary Optional (include_bisectors)"},{"location":"examples/07_medial_axis/#tuning-parameters","title":"Tuning Parameters","text":""},{"location":"examples/07_medial_axis/#min_length","title":"min_length","text":"<p>Controls infill density:</p> Value Effect Small (1-2mm) Dense infill, more paths Medium (5-10mm) Moderate infill Large (20mm+) Sparse, only main skeleton"},{"location":"examples/07_medial_axis/#include_bisectors","title":"include_bisectors","text":"<pre><code>include_bisectors=True:     include_bisectors=False:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502\u2572     \u2571\u2502                   \u2502       \u2502\n    \u2502 \u2572   \u2571 \u2502                   \u2502   \u2502   \u2502\n    \u2502  \u2572 \u2571  \u2502                   \u2502   \u2502   \u2502\n    \u2502\u2500\u2500\u2500\u2573\u2500\u2500\u2500\u2502                   \u2502\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2502\n    \u2502  \u2571 \u2572  \u2502                   \u2502   \u2502   \u2502\n    \u2502 \u2571   \u2572 \u2502                   \u2502       \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  (more support)              (cleaner look)\n</code></pre>"},{"location":"examples/07_medial_axis/#complete-code","title":"Complete Code","text":"<pre><code>--8&lt;-- \"examples/7_medial_axis_infill/example_7_medial_axis_infill.py\"\n</code></pre>"},{"location":"examples/07_medial_axis/#running-the-example","title":"Running the Example","text":"<pre><code>cd examples/7_medial_axis_infill\npython example_7_medial_axis_infill.py\n</code></pre> <p>With visualization:</p> <pre><code>python example_7_medial_axis_infill.py --visualize\n</code></pre>"},{"location":"examples/07_medial_axis/#when-to-use-medial-axis-infill","title":"When to Use Medial Axis Infill","text":"<p>Good for:</p> <ul> <li>Irregular shapes with varying wall thickness</li> <li>Organic geometries (vases, sculptures)</li> <li>Parts with thin features that need internal support</li> <li>Single-wall prints that need occasional bridging</li> </ul> <p>Not ideal for:</p> <ul> <li>Regular mechanical parts (use grid/honeycomb)</li> <li>High infill density requirements (use traditional patterns)</li> <li>Parts needing uniform strength in all directions</li> </ul>"},{"location":"examples/07_medial_axis/#comparison-with-traditional-infill","title":"Comparison with Traditional Infill","text":"Aspect Medial Axis Grid/Honeycomb Adapts to geometry Yes No Density control Via min_length Via infill % Thin wall support Excellent May miss thin areas Computation Per-layer skeleton Simple patterns Uniform strength No (follows shape) Yes"},{"location":"examples/07_medial_axis/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Geometry-aware: Infill follows the natural structure of the shape</li> <li>Adaptive density: Automatically denser where needed</li> <li>CGAL powered: Uses robust straight skeleton computation</li> <li>Tunable: Control density with <code>min_length</code>, coverage with <code>include_bisectors</code></li> </ol>"},{"location":"examples/07_medial_axis/#next-steps","title":"Next Steps","text":"<ul> <li>Planar Slicing - Basic slicing workflow</li> <li>Print Organization - Fabrication parameters</li> <li>API Reference - Full function documentation</li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Step-by-step guides to learn COMPAS Slicer fundamentals.</p> <ul> <li> <p> Introduction</p> <p>Understand the core concepts and architecture of COMPAS Slicer</p> <p> Read</p> </li> <li> <p> Grasshopper Visualization</p> <p>Learn how to visualize slicing results in Rhino/Grasshopper</p> <p> Read</p> </li> </ul>"},{"location":"tutorials/grasshopper/","title":"Grasshopper Visualization","text":"<p>This tutorial explains how to visualize COMPAS Slicer results in Rhino/Grasshopper.</p> <p>Important</p> <p>The Grasshopper components only visualize existing results. All slicing computation happens in Python - the components load and display the JSON output files.</p>"},{"location":"tutorials/grasshopper/#setup","title":"Setup","text":"<ol> <li>Install COMPAS Slicer (see Installation)</li> <li> <p>Install Grasshopper components:</p> <pre><code>python -m compas_rhino.install -v 8.0\n</code></pre> </li> </ol>"},{"location":"tutorials/grasshopper/#workflow","title":"Workflow","text":"<pre><code>graph LR\n    A[Python Script] --&gt;|generates| B[JSON Files]\n    B --&gt;|loaded by| C[GH Components]\n    C --&gt;|displays| D[Rhino Geometry]</code></pre> <ol> <li>Run your Python slicing script</li> <li>Output files are saved to <code>project/data/output/</code></li> <li>Open the Grasshopper file in <code>project/</code></li> <li>Click Recompute on components to load latest results</li> </ol>"},{"location":"tutorials/grasshopper/#project-structure","title":"Project Structure","text":"<pre><code>my_project/\n\u251c\u2500\u2500 data/\n\u2502   \u251c\u2500\u2500 model.obj           # Input mesh\n\u2502   \u2514\u2500\u2500 output/\n\u2502       \u251c\u2500\u2500 slicer_data.json\n\u2502       \u2514\u2500\u2500 out_printpoints.json\n\u251c\u2500\u2500 my_script.py            # Python slicing code\n\u2514\u2500\u2500 visualization.gh        # Grasshopper file\n</code></pre> <p>Tip</p> <p>Place your <code>.gh</code> file in the project root folder so components can find the <code>data/output/</code> folder.</p>"},{"location":"tutorials/grasshopper/#components","title":"Components","text":""},{"location":"tutorials/grasshopper/#csloadslicer","title":"csLoadSlicer","text":"<p>Loads slicer results from JSON, including all layer and path data.</p> <p></p> <p>Outputs:</p> <ul> <li>Layers (list of paths per layer)</li> <li>Path geometry (polylines)</li> <li>Layer heights</li> </ul>"},{"location":"tutorials/grasshopper/#csloadprintpoints","title":"csLoadPrintpoints","text":"<p>Loads the printpoints dictionary with all fabrication parameters.</p> <p></p> <p>Outputs:</p> <ul> <li>Point locations</li> <li>Velocities</li> <li>Extruder states</li> <li>Up vectors</li> </ul>"},{"location":"tutorials/grasshopper/#cslightpathviz","title":"csLightPathViz","text":"<p>Creates a lightweight visualization of toolpaths.</p> <p></p> <ul> <li>White tubes: Print paths</li> <li>Orange tubes: Travel moves</li> </ul>"},{"location":"tutorials/grasshopper/#csrenderpathviz","title":"csRenderPathViz","text":"<p>Creates a detailed visualization with actual path cross-sections.</p> <p></p> <p>Requires a cross-section curve as input for accurate representation.</p>"},{"location":"tutorials/grasshopper/#example-workflow","title":"Example Workflow","text":"<ol> <li> <p>Run Python script:</p> <pre><code>from compas_slicer.slicers import PlanarSlicer\nfrom compas_slicer.utilities import save_to_json\n\nslicer = PlanarSlicer(mesh, layer_height=2.0)\nslicer.slice_model()\nsave_to_json(slicer.to_data(), OUTPUT_PATH, 'slicer_data.json')\n</code></pre> </li> <li> <p>In Grasshopper:</p> <ul> <li>Add <code>csLoadSlicer</code> component</li> <li>Connect to visualization components</li> <li>Click Recompute after each Python run</li> </ul> </li> </ol>"},{"location":"tutorials/introduction/","title":"Introduction","text":"<p>This tutorial introduces the core concepts and architecture of COMPAS Slicer.</p>"},{"location":"tutorials/introduction/#overview","title":"Overview","text":"<p>COMPAS Slicer is organized into four main components:</p> <pre><code>graph TB\n    subgraph \"1. Geometry\"\n        Layer --&gt; Path\n        Path --&gt; PrintPoint\n    end\n\n    subgraph \"2. Slicers\"\n        PlanarSlicer\n        InterpolationSlicer\n        ScalarFieldSlicer\n    end\n\n    subgraph \"3. Print Organization\"\n        PrintOrganizer --&gt; PrintPoint\n    end\n\n    subgraph \"4. Output\"\n        GCode\n        JSON\n        Grasshopper\n    end</code></pre> Component Purpose Geometry Core geometric entities: <code>Layer</code>, <code>Path</code>, <code>PrintPoint</code> Slicers Generate sliced paths from meshes Print Organizers Embed fabrication parameters into paths Visualization Display results in Rhino/Grasshopper"},{"location":"tutorials/introduction/#geometry","title":"Geometry","text":""},{"location":"tutorials/introduction/#layer","title":"Layer","text":"<p>A <code>Layer</code> represents a single slice of the model. In planar slicing, all points in a layer are at the same Z height. In non-planar slicing, points can vary in height.</p> <p></p>"},{"location":"tutorials/introduction/#verticallayer","title":"VerticalLayer","text":"<p>A <code>VerticalLayer</code> groups multiple layers together - useful for models with branching geometry.</p> <p></p>"},{"location":"tutorials/introduction/#path","title":"Path","text":"<p>A <code>Path</code> is a closed or open contour containing a list of points. A layer can contain multiple paths (e.g., for models with holes or branches).</p>"},{"location":"tutorials/introduction/#printpoint","title":"PrintPoint","text":"<p>A <code>PrintPoint</code> extends a geometric point with fabrication parameters:</p> <ul> <li>Velocity</li> <li>Extrusion rate</li> <li>Layer height</li> <li>Up vector (tool orientation)</li> <li>Extruder toggle (on/off)</li> </ul>"},{"location":"tutorials/introduction/#slicers","title":"Slicers","text":"Slicer Description Use Case <code>PlanarSlicer</code> Intersects mesh with horizontal planes Standard FDM printing <code>InterpolationSlicer</code> Interpolates between boundary curves Non-planar surfaces, shells <code>ScalarFieldSlicer</code> Follows scalar field contours Custom layer patterns"},{"location":"tutorials/introduction/#print-organizers","title":"Print Organizers","text":"<p>After slicing, print organizers convert geometric points to <code>PrintPoints</code> with fabrication data:</p> <pre><code>from compas_slicer.print_organization import PlanarPrintOrganizer\n\norganizer = PlanarPrintOrganizer(slicer)\norganizer.create_printpoints()\n\n# Add fabrication parameters\nset_linear_velocity_constant(organizer, velocity=25)\nset_extruder_toggle(organizer, slicer)\nadd_safety_printpoints(organizer, z_hop=5.0)\n</code></pre>"},{"location":"tutorials/introduction/#package-structure","title":"Package Structure","text":"<pre><code>compas_slicer/\n\u251c\u2500\u2500 geometry/          # Layer, Path, PrintPoint\n\u251c\u2500\u2500 slicers/           # PlanarSlicer, InterpolationSlicer, etc.\n\u251c\u2500\u2500 print_organization/# PrintOrganizers and utilities\n\u251c\u2500\u2500 pre_processing/    # Mesh preparation (positioning, boundaries)\n\u251c\u2500\u2500 post_processing/   # Path modifications (brim, raft, sorting)\n\u251c\u2500\u2500 utilities/         # Helper functions\n\u2514\u2500\u2500 visualization/     # Viewer utilities\n</code></pre>"},{"location":"tutorials/introduction/#next-steps","title":"Next Steps","text":"<ul> <li>Grasshopper Visualization - Visualize results in Rhino</li> <li>Examples - Complete working examples</li> </ul>"}]}