from __future__ import annotations

from abc import abstractmethod
from pathlib import Path as FilePath
from typing import TYPE_CHECKING, Any

import numpy as np
from compas.datastructures import Mesh
from compas.geometry import bounding_box, distance_point_point_sqrd
from loguru import logger

from compas_slicer.geometry import Layer, VerticalLayer
from compas_slicer.post_processing.seams_align import seams_align
from compas_slicer.post_processing.unify_paths_orientation import unify_paths_orientation
from compas_slicer.utilities import utils

if TYPE_CHECKING:
    from compas_slicer.geometry import Path


__all__ = ["BaseSlicer"]


class BaseSlicer:
    """Base class for slicers that holds all information for the slice process.

    Do not use this class directly. Instead use PlanarSlicer or InterpolationSlicer.
    This class is meant to be extended for implementing various slicers.

    Attributes
    ----------
    mesh : Mesh
        Input mesh, must be triangular (no quads or n-gons allowed).
    layer_height : float | None
        Height between layers.
    layers : list[Layer]
        List of layers generated by slicing.

    """

    def __init__(self, mesh: Mesh) -> None:
        if not isinstance(mesh, Mesh):
            raise TypeError(f"Input mesh must be Mesh, not {type(mesh)}")
        utils.check_triangular_mesh(mesh)

        self.mesh = mesh
        logger.info(f"Input Mesh with: {len(list(self.mesh.vertices()))} vertices, {len(list(self.mesh.faces()))} faces")

        self.layer_height: float | None = None
        self.layers: list[Layer] = []

    @property
    def number_of_points(self) -> int:
        """Total number of points in the slicer."""
        return sum(len(path.points) for layer in self.layers for path in layer.paths)

    @property
    def number_of_layers(self) -> int:
        """Total number of layers."""
        return len(self.layers)

    @property
    def number_of_paths(self) -> tuple[int, int, int]:
        """Total paths, open paths, closed paths."""
        total = 0
        closed = 0
        open_paths = 0
        for layer in self.layers:
            total += len(layer.paths)
            for path in layer.paths:
                if path.is_closed:
                    closed += 1
                else:
                    open_paths += 1
        return total, closed, open_paths

    @property
    def vertical_layers(self) -> list[VerticalLayer]:
        """List of all vertical layers in the slicer."""
        return [layer for layer in self.layers if isinstance(layer, VerticalLayer)]

    @property
    def horizontal_layers(self) -> list[Layer]:
        """List of all non-vertical layers in the slicer."""
        return [layer for layer in self.layers if not isinstance(layer, VerticalLayer)]

    def slice_model(self, *args: Any, **kwargs: Any) -> None:
        """Slices the model and applies standard post-processing."""
        self.generate_paths()
        self.remove_invalid_paths_and_layers()
        self.post_processing()

    @abstractmethod
    def generate_paths(self) -> None:
        """Generate paths. To be implemented by inheriting classes."""
        pass

    def post_processing(self) -> None:
        """Applies standard post-processing: seams_align and unify_paths."""
        self.close_paths()
        seams_align(self, align_with="next_path")
        unify_paths_orientation(self)
        self.close_paths()
        logger.info(f"Created {len(self.layers)} Layers with {self.number_of_points} total points")

    def close_paths(self) -> None:
        """For closed paths, ensures first and last point are identical."""
        for layer in self.layers:
            for path in layer.paths:
                if path.is_closed and distance_point_point_sqrd(path.points[0], path.points[-1]) > 0.00001:
                    path.points.append(path.points[0])

    def remove_invalid_paths_and_layers(self) -> None:
        """Removes invalid layers and paths from the slicer."""
        paths_to_remove = []
        layers_to_remove = []

        for i, layer in enumerate(self.layers):
            for j, path in enumerate(layer.paths):
                if len(path.points) < 2:
                    paths_to_remove.append(path)
                    logger.warning(f"Invalid Path: Layer {i}, Path {j}, {path}")
                    if len(layer.paths) == 1:
                        layers_to_remove.append(layer)
                        logger.warning(f"Invalid Layer: Layer {i}, {layer}")
            if len(layer.paths) < 1:
                layers_to_remove.append(layer)
                logger.warning(f"Invalid Layer: Layer {i}, {layer}")

        for layer in self.layers:
            for path in list(layer.paths):
                if path in paths_to_remove:
                    layer.paths.remove(path)
            if layer in layers_to_remove:
                self.layers.remove(layer)

    def find_vertical_layers_with_first_path_on_base(self) -> tuple[list[Path], list[int]]:
        """Find vertical layers whose first path is on the base.

        Returns
        -------
        tuple[list[Path], list[int]]
            Paths on base and their vertical layer indices.

        """
        vertices = list(self.mesh.vertices_attributes('xyz'))
        bbox = bounding_box(vertices)
        z_min = min(p[2] for p in bbox)
        paths_on_base = []
        vertical_layer_indices = []
        d_threshold = 30

        for i, vertical_layer in enumerate(self.vertical_layers):
            first_path = vertical_layer.paths[0]
            avg_z_dist = np.average(np.array([abs(pt[2] - z_min) for pt in first_path.points]))
            if avg_z_dist < d_threshold:
                paths_on_base.append(first_path)
                vertical_layer_indices.append(i)

        return paths_on_base, vertical_layer_indices

    def printout_info(self) -> None:
        """Prints out slicing information."""
        no_of_paths, closed_paths, open_paths = self.number_of_paths
        logger.info("---- Slicer Info ----")
        logger.info(f"Number of layers: {self.number_of_layers}")
        logger.info(f"Number of paths: {no_of_paths}, open: {open_paths}, closed: {closed_paths}")
        logger.info(f"Number of sampling printpoints: {self.number_of_points}")

    @classmethod
    def from_data(cls, data: dict[str, Any]) -> BaseSlicer:
        """Construct a slicer from its data representation.

        Parameters
        ----------
        data : dict
            The data dictionary.

        Returns
        -------
        BaseSlicer
            The constructed slicer.

        """
        mesh = Mesh.__from_data__(data["mesh"])
        slicer = cls(mesh)
        layers_data = data["layers"]
        for layer_key in layers_data:
            if layers_data[layer_key]["layer_type"] == "horizontal_layer":
                slicer.layers.append(Layer.from_data(layers_data[layer_key]))
            else:
                slicer.layers.append(VerticalLayer.from_data(layers_data[layer_key]))
        slicer.layer_height = data["layer_height"]
        return slicer

    def to_json(self, filepath: str | FilePath, name: str) -> None:
        """Writes the slicer to a JSON file."""
        utils.save_to_json(self.to_data(), filepath, name)

    def to_data(self) -> dict[str, Any]:
        """Returns a dictionary of structured data representing the slicer.

        Returns
        -------
        dict
            The slicer's data.

        """
        mesh = self.mesh.copy()
        v_key = next(iter(mesh.vertices()))
        v_attrs = mesh.vertex_attributes(v_key)
        for attr_key in v_attrs:
            if not utils.is_jsonable(v_attrs[attr_key]):
                logger.error(f"vertex: {attr_key} {v_attrs[attr_key]}")
                for v in mesh.vertices():
                    mesh.unset_vertex_attribute(v, attr_key)

        f_key = next(iter(mesh.faces()))
        f_attrs = mesh.face_attributes(f_key)
        for attr_key in f_attrs:
            if not utils.is_jsonable(f_attrs[attr_key]):
                logger.error(f"face: {attr_key} {f_attrs[attr_key]}")
                mesh.update_default_face_attributes({attr_key: 0.0})

        return {
            "layers": self.get_layers_dict(),
            "mesh": mesh.__data__,
            "layer_height": self.layer_height,
        }

    def get_layers_dict(self) -> dict[int, dict[str, Any]]:
        """Returns a dictionary of layers."""
        return {i: layer.to_data() for i, layer in enumerate(self.layers)}
