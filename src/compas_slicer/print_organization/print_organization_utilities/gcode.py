"""G-code generation for compas_slicer.

This module generates G-code for FDM 3D printing from organized print points.
"""

from __future__ import annotations

import math
from datetime import datetime
from typing import TYPE_CHECKING

from compas.geometry import Point
from loguru import logger

from compas_slicer.config import GcodeConfig

if TYPE_CHECKING:
    from compas_slicer.print_organization import BasePrintOrganizer

__all__ = ["create_gcode_text", "GcodeBuilder"]

# =============================================================================
# Constants
# =============================================================================

PURGE_LENGTH = 145.0  # mm, Y travel for purge line
PURGE_START_X = 5.0  # mm
PURGE_START_Y = 5.0  # mm
PURGE_HEIGHT = 0.2  # mm, first layer height for purge
STARTUP_FEEDRATE = 4500  # mm/min
SHUTDOWN_FEEDRATE = 1000  # mm/min
SHUTDOWN_ACCEL = 500  # mm/s^2


# =============================================================================
# GcodeBuilder
# =============================================================================


class GcodeBuilder:
    """Builder for constructing G-code output efficiently.

    Uses a list internally and joins at the end for better performance
    than repeated string concatenation.
    """

    def __init__(self) -> None:
        self._lines: list[str] = []

    def comment(self, text: str) -> None:
        """Add a comment line."""
        self._lines.append(f";{text}")

    def cmd(self, gcode: str, comment: str = "") -> None:
        """Add a G-code command with optional inline comment."""
        if comment:
            self._lines.append(f"{gcode:<30} ;{comment}")
        else:
            self._lines.append(gcode)

    def blank(self) -> None:
        """Add a blank line."""
        self._lines.append("")

    def build(self) -> str:
        """Return the complete G-code as a string."""
        return "\n".join(self._lines)


# =============================================================================
# Helper Functions
# =============================================================================


def _calc_extrusion(
    distance: float,
    layer_height: float,
    path_width: float,
    filament_diameter: float,
    flowrate: float = 1.0,
) -> float:
    """Calculate extrusion amount using volumetric math.

    Parameters
    ----------
    distance : float
        Travel distance in mm.
    layer_height : float
        Layer height in mm.
    path_width : float
        Extrusion width in mm.
    filament_diameter : float
        Filament diameter in mm.
    flowrate : float
        Flow multiplier (default 1.0).

    Returns
    -------
    float
        Extrusion length in mm.

    """
    cross_section = layer_height * path_width
    filament_area = math.pi * (filament_diameter / 2) ** 2
    return flowrate * distance * cross_section / filament_area


def _distance_3d(p1: Point, p2: Point) -> float:
    """Calculate 3D Euclidean distance between two points."""
    return math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2 + (p2.z - p1.z) ** 2)


# =============================================================================
# G-code Sections
# =============================================================================


def _write_header(gb: GcodeBuilder, config: GcodeConfig, timestamp: str) -> None:
    """Write G-code header with machine setup commands."""
    # File info
    gb.comment("G-code generated by compas_slicer")
    gb.comment(f"Generated: {timestamp}")
    gb.comment("MIT License")
    gb.blank()

    # Machine setup
    gb.cmd("T0", "select tool 0")
    gb.cmd("G21", "metric units")
    gb.cmd("G90", "absolute positioning")
    gb.cmd("M107", "fan off")
    gb.blank()

    # Heating
    gb.cmd(f"M140 S{config.bed_temperature}", "set bed temp (no wait)")
    gb.cmd(f"M104 S{config.extruder_temperature}", "set extruder temp (no wait)")
    gb.cmd(f"M109 S{config.extruder_temperature}", "wait for extruder temp")
    gb.cmd(f"M190 S{config.bed_temperature}", "wait for bed temp")
    gb.blank()

    # Motion setup
    gb.cmd("G21", "metric units")
    gb.cmd("G90", "absolute positioning")
    gb.cmd("M83", "relative extrusion")

    if config.acceleration > 0:
        gb.cmd(f"M201 X{config.acceleration} Y{config.acceleration}", "set max acceleration")
    if config.jerk > 0:
        gb.cmd(f"M205 X{config.jerk} Y{config.jerk}", "set jerk")

    gb.blank()

    # Homing
    gb.cmd("G28 X0 Y0", "home X and Y")
    gb.cmd("G28 Z0", "home Z")
    gb.blank()


def _write_purge_line(gb: GcodeBuilder, config: GcodeConfig) -> None:
    """Write purge/prime line sequence to prepare the nozzle."""
    gb.comment("Purge line")
    gb.cmd(f"G1 F{STARTUP_FEEDRATE}", "set feedrate")
    gb.cmd(f"G1 Z{PURGE_HEIGHT}", "move to purge height")
    gb.cmd(f"G1 X{PURGE_START_X} Y{PURGE_START_Y}", "move to purge start")

    # Calculate extrusion for purge lines
    e_purge = _calc_extrusion(
        PURGE_LENGTH, PURGE_HEIGHT, config.layer_width, config.filament_diameter
    )

    # First purge line
    gb.cmd(f"G1 Y{PURGE_START_Y + PURGE_LENGTH} E{e_purge:.3f}", "purge line 1")
    # Move over
    gb.cmd(f"G1 X{PURGE_START_X + config.layer_width:.3f}", "step over")
    # Second purge line
    gb.cmd(f"G1 Y{PURGE_START_Y} E{e_purge:.3f}", "purge line 2")

    # Prepare for print
    gb.cmd("G1 Z2", "lift nozzle")
    gb.cmd("G92 E0", "reset extruder position")
    gb.cmd(f"G1 F{config.feedrate_travel}", "set travel feedrate")
    gb.cmd("M117 Printing...", "LCD status")
    gb.blank()


def _write_toolpath(
    gb: GcodeBuilder, print_organizer: BasePrintOrganizer, config: GcodeConfig
) -> float:
    """Write the main toolpath G-code.

    Returns the final Z height for use in footer.
    """
    gb.comment("Begin toolpath")

    fan_on = False
    prev_pt = Point(0, 0, 0)
    prev_z = 0.0
    layer_height = PURGE_HEIGHT

    for ppt, layer_idx, _path_idx, point_idx in print_organizer.printpoints_indices_iterator():
        pt = ppt.pt
        layer_height = ppt.layer_height
        distance = _distance_3d(prev_pt, pt)

        if point_idx == 0:
            # First point in path - handle travel move
            _write_travel_to_path_start(gb, config, prev_pt, pt, distance)

            # Set feedrate based on Z height (slower near bed for adhesion)
            if pt.z < config.min_over_z:
                gb.cmd(f"G1 F{config.feedrate_low}", "slow feedrate for adhesion")
            else:
                gb.cmd(f"G1 F{config.feedrate}", "print feedrate")
        else:
            # Subsequent points - extrude
            e_val = _calc_extrusion(
                distance,
                layer_height,
                config.layer_width,
                config.filament_diameter,
                config.flowrate,
            )
            # Apply overextrusion near bed
            if pt.z < config.min_over_z:
                e_val *= config.flow_over

            gb.cmd(f"G1 X{pt.x:.3f} Y{pt.y:.3f} E{e_val:.3f}")

        # Fan control
        if not fan_on and layer_idx * layer_height >= config.fan_start_z:
            gb.cmd(f"M106 S{config.fan_speed}", "fan on")
            fan_on = True

        prev_pt = pt
        prev_z = pt.z

    gb.blank()
    return prev_z


def _write_travel_to_path_start(
    gb: GcodeBuilder,
    config: GcodeConfig,
    prev_pt: Point,
    target_pt: Point,
    distance: float,
) -> None:
    """Write travel move to start of a new path, with retraction if needed."""
    needs_retract = distance > config.retraction_min_travel

    if needs_retract:
        # Retract
        gb.cmd(f"G1 F{config.feedrate_retraction}", "retraction feedrate")
        gb.cmd(f"G1 E-{config.retraction_length}", "retract")
        # Z-hop
        gb.cmd(f"G1 Z{prev_pt.z + config.z_hop:.3f}", "z-hop")
        # Travel
        gb.cmd(f"G1 F{config.feedrate_travel}", "travel feedrate")

    # Move to target
    if prev_pt.z != target_pt.z or needs_retract:
        gb.cmd(f"G1 X{target_pt.x:.3f} Y{target_pt.y:.3f} Z{target_pt.z:.3f}")
    else:
        gb.cmd(f"G1 X{target_pt.x:.3f} Y{target_pt.y:.3f}")

    if needs_retract:
        # Reverse z-hop and retraction
        gb.cmd(f"G1 F{config.feedrate_retraction}", "retraction feedrate")
        gb.cmd(f"G1 Z{target_pt.z:.3f}", "reverse z-hop")
        gb.cmd(f"G1 E{config.retraction_length}", "unretract")


def _write_footer(gb: GcodeBuilder, config: GcodeConfig, final_z: float) -> None:
    """Write G-code footer with shutdown sequence."""
    gb.comment("End of print")

    # Final retract and lift
    gb.cmd(f"G1 F{config.feedrate_retraction}", "retraction feedrate")
    gb.cmd(f"G1 E-{config.retraction_length}", "final retract")
    gb.cmd(f"G1 Z{min(final_z + config.z_hop * 3, config.print_volume_z):.3f}", "lift nozzle")
    gb.blank()

    # Shutdown sequence
    gb.cmd(f"M201 X{SHUTDOWN_ACCEL} Y{SHUTDOWN_ACCEL}", "reduce acceleration")
    gb.cmd(f"G1 F{SHUTDOWN_FEEDRATE}", "slow feedrate")
    gb.cmd("G1 X0 Y0", "move to home")
    gb.cmd("M104 S0", "extruder heater off")
    gb.cmd("M140 S0", "bed heater off")
    gb.cmd("M84", "motors off")
    gb.cmd("M106 S0", "fan off")


# =============================================================================
# Main Function
# =============================================================================


def create_gcode_text(
    print_organizer: BasePrintOrganizer, config: GcodeConfig | None = None
) -> str:
    """Create G-code text from organized print points.

    Parameters
    ----------
    print_organizer : BasePrintOrganizer
        The print organizer containing printpoints.
    config : GcodeConfig | None
        G-code configuration. If None, uses defaults.

    Returns
    -------
    str
        Complete G-code file content.

    """
    config = config or GcodeConfig()
    logger.info("Generating G-code")

    gb = GcodeBuilder()
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    _write_header(gb, config, timestamp)
    _write_purge_line(gb, config)
    final_z = _write_toolpath(gb, print_organizer, config)
    _write_footer(gb, config, final_z)

    return gb.build()
